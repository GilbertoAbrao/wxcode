"""Starter Kit Generator - Creates the base FastAPI + Jinja2 project structure.

This is a deterministic generator that creates the target stack skeleton
before any LLM-based page conversion happens.
"""

from dataclasses import dataclass, field
from pathlib import Path
from typing import Any


@dataclass
class StarterKitConfig:
    """Configuration for the starter kit."""

    # Project metadata
    project_name: str = "app"
    project_description: str = "Application generated by wxcode"

    # Database connections (from SchemaConnection)
    connections: list[Any] = field(default_factory=list)

    # Stack options
    use_mongodb: bool = True  # vs SQLAlchemy/PostgreSQL
    use_htmx: bool = True
    use_bootstrap: bool = True
    bootstrap_version: str = "5.3.2"

    # Features
    include_auth: bool = False
    include_docker: bool = True
    include_tests: bool = True

    # Python version
    python_version: str = "3.11"


@dataclass
class StarterKitResult:
    """Result of starter kit generation."""

    output_dir: Path
    files_created: list[str] = field(default_factory=list)
    directories_created: list[str] = field(default_factory=list)

    def summary(self) -> str:
        """Generate summary of what was created."""
        return (
            f"Starter Kit created at: {self.output_dir}\n"
            f"Directories: {len(self.directories_created)}\n"
            f"Files: {len(self.files_created)}"
        )


class StarterKitGenerator:
    """Generates the base FastAPI + Jinja2 project structure.

    This creates a complete, runnable skeleton that the LLM-based
    converters will populate with converted pages and logic.
    """

    # Directory structure for FastAPI + Jinja2 project
    DIRECTORIES = [
        "app",
        "app/api",
        "app/core",
        "app/models",
        "app/routers",
        "app/services",
        "app/templates",
        "app/templates/pages",
        "app/templates/components",
        "app/templates/layouts",
        "app/static",
        "app/static/css",
        "app/static/js",
        "app/static/images",
        "tests",
        "tests/api",
        "tests/routes",
    ]

    def __init__(self, output_dir: Path, config: StarterKitConfig | None = None):
        """Initialize generator.

        Args:
            output_dir: Root directory where project will be created
            config: Optional configuration, uses defaults if not provided
        """
        self.output_dir = Path(output_dir)
        self.config = config or StarterKitConfig()
        self.result = StarterKitResult(output_dir=self.output_dir)

    def generate(self) -> StarterKitResult:
        """Generate the complete starter kit.

        Returns:
            StarterKitResult with details of what was created
        """
        # Create directory structure
        self._create_directories()

        # Generate Python files
        self._generate_main_py()
        self._generate_config_py()
        self._generate_database_py()
        self._generate_init_files()
        self._generate_auth_service()
        self._generate_security_utils()

        # Generate templates
        self._generate_base_template()
        self._generate_layout_templates()
        self._generate_component_templates()

        # Generate static files
        self._generate_css()
        self._generate_js()

        # Generate deployment files
        if self.config.include_docker:
            self._generate_dockerfile()
            self._generate_docker_compose()

        self._generate_pyproject_toml()
        self._generate_requirements_txt()
        self._generate_readme()
        self._generate_env_example()
        self._generate_gitignore()

        # Generate test files
        if self.config.include_tests:
            self._generate_test_files()

        return self.result

    def _create_directories(self) -> None:
        """Create all directories."""
        for dir_path in self.DIRECTORIES:
            full_path = self.output_dir / dir_path
            full_path.mkdir(parents=True, exist_ok=True)
            self.result.directories_created.append(dir_path)

    def _write_file(self, relative_path: str, content: str) -> Path:
        """Write a file and track it.

        Args:
            relative_path: Path relative to output_dir
            content: File content

        Returns:
            Full path to created file
        """
        full_path = self.output_dir / relative_path
        full_path.parent.mkdir(parents=True, exist_ok=True)
        full_path.write_text(content, encoding="utf-8")
        self.result.files_created.append(relative_path)
        return full_path

    def _has_active_imports(self, content: str) -> bool:
        """Check if content has active router imports.

        Args:
            content: File content to check

        Returns:
            True if file has active imports (from .xxx import)
        """
        import re
        # Look for uncommented imports from relative modules
        pattern = r"^from \.\w+ import"
        for line in content.split("\n"):
            line = line.strip()
            if line.startswith("#"):
                continue
            if re.match(pattern, line):
                return True
        return False

    def _should_preserve_file(self, relative_path: str) -> bool:
        """Check if file should be preserved (not overwritten).

        Args:
            relative_path: Path relative to output_dir

        Returns:
            True if file exists and has meaningful content
        """
        full_path = self.output_dir / relative_path
        if not full_path.exists():
            return False
        content = full_path.read_text(encoding="utf-8")
        return self._has_active_imports(content)

    # =========================================================================
    # Python Files
    # =========================================================================

    def _generate_main_py(self) -> None:
        """Generate main.py FastAPI application."""
        content = f'''"""FastAPI application - Generated by wxcode.

Stack: FastAPI + Jinja2 + {"MongoDB" if self.config.use_mongodb else "SQLAlchemy"}
"""

from contextlib import asynccontextmanager

from fastapi import FastAPI, Request
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from fastapi.responses import HTMLResponse

from app.config import settings
from app.database import init_db, close_db


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan - startup and shutdown."""
    await init_db()
    yield
    await close_db()


app = FastAPI(
    title=settings.app_name,
    description="{self.config.project_description}",
    version="1.0.0",
    lifespan=lifespan,
)

# Static files
app.mount("/static", StaticFiles(directory="app/static"), name="static")

# Templates
templates = Jinja2Templates(directory="app/templates")


# Include routers
from app.routers import router as pages_router
from app.api import router as api_router

app.include_router(pages_router)
app.include_router(api_router, prefix="/api/v1")


@app.get("/", response_class=HTMLResponse)
async def home(request: Request):
    """Home page."""
    return templates.TemplateResponse(
        "pages/home.html",
        {{"request": request, "title": settings.app_name}}
    )


@app.get("/health")
async def health():
    """Health check endpoint."""
    return {{"status": "healthy", "app": settings.app_name}}
'''
        self._write_file("app/main.py", content)

    def _generate_config_py(self) -> None:
        """Generate config.py with settings."""
        # Generate database settings based on connections
        if self.config.connections:
            db_settings = []
            for conn in self.config.connections:
                conn_var = conn.name.lower()
                db_settings.append(f"    # {conn.name} ({conn.driver_name})")
                db_settings.append(f'    {conn_var}_host: str = "{conn.source or "localhost"}"')
                db_settings.append(f'    {conn_var}_port: str = "{conn.port or "5432"}"')
                db_settings.append(f'    {conn_var}_database: str = "{conn.database or "app_db"}"')
                db_settings.append(f'    {conn_var}_user: str = "{conn.user or "user"}"')
                db_settings.append(f'    {conn_var}_password: str = ""')
                db_settings.append("")
            db_settings_str = "\n".join(db_settings)
        else:
            db_settings_str = f'''    # Database
    {"database_url: str = 'mongodb://localhost:27017'" if self.config.use_mongodb else "database_url: str = 'postgresql://localhost:5432/app'"}
    database_name: str = "{self.config.project_name}_db"'''

        content = f'''"""Application configuration."""

from pydantic_settings import BaseSettings


class Settings(BaseSettings):
    """Application settings from environment variables."""

    # Application
    app_name: str = "{self.config.project_name}"
    debug: bool = False

{db_settings_str}

    # Security
    secret_key: str = "change-me-in-production"

    # Session
    session_expire_minutes: int = 60 * 24  # 24 hours

    model_config = {{
        "env_file": ".env",
        "env_file_encoding": "utf-8",
        "extra": "ignore",  # Permite variáveis extras no .env
    }}


settings = Settings()
'''
        self._write_file("app/config.py", content)

    def _generate_database_py(self) -> None:
        """Generate database.py connection."""
        # If connections are provided, generate multi-connection support
        if self.config.connections:
            connections = self.config.connections
            types_needed = {conn.database_type for conn in connections if conn.database_type not in ("hyperfile", "hyperfile_cs", "unknown")}

            imports = []
            if any(t in types_needed for t in ("sqlserver", "mysql", "postgresql", "oracle")):
                imports.append("from sqlalchemy.ext.asyncio import create_async_engine, AsyncEngine, AsyncSession")
                imports.append("from sqlalchemy.orm import sessionmaker")

            imports_str = "\n".join(imports) if imports else ""

            # Generate connection initialization
            connections_init = []
            connections_close = []

            for conn in connections:
                conn_var = conn.name.lower()

                if conn.database_type in ("sqlserver", "mysql", "postgresql", "oracle"):
                    driver_map = {
                        "sqlserver": "mssql+aioodbc",
                        "mysql": "mysql+aiomysql",
                        "postgresql": "postgresql+asyncpg",
                        "oracle": "oracle+oracledb"
                    }
                    driver = driver_map.get(conn.database_type, conn.database_type)

                    connections_init.append(f'''    # {conn.name} ({conn.driver_name})
    engine_{conn_var} = create_async_engine(
        f"{driver}://{{settings.{conn_var}_user}}:{{settings.{conn_var}_password}}@{{settings.{conn_var}_host}}:{{settings.{conn_var}_port}}/{{settings.{conn_var}_database}}"
    )
    session_factory_{conn_var} = sessionmaker(engine_{conn_var}, class_=AsyncSession, expire_on_commit=False)
    connections["{conn.name}"] = {{"engine": engine_{conn_var}, "session_factory": session_factory_{conn_var}}}''')

                    connections_close.append(f'    await connections["{conn.name}"]["engine"].dispose()')

                elif conn.database_type in ("hyperfile", "hyperfile_cs"):
                    connections_init.append(f'''    # {conn.name} ({conn.driver_name})
    # HyperFile connections not yet supported - TODO: Implement HyperFile REST API client''')

            connections_init_str = "\n".join(connections_init)
            connections_close_str = "\n".join(connections_close) if connections_close else "    pass"

            content = f'''"""Database connections."""

{imports_str}
from app.config import settings

# Connection registry
connections: dict[str, dict] = {{}}


async def init_db() -> None:
    """Initialize all database connections."""
{connections_init_str}


async def close_db() -> None:
    """Close all database connections."""
{connections_close_str}


def get_db(connection_name: str = "{connections[0].name if connections else 'default'}"):
    """Get database session for specific connection."""
    if connection_name not in connections:
        raise ValueError(f"Unknown connection: {{connection_name}}")
    return connections[connection_name]["session_factory"]
'''
            self._write_file("app/database.py", content)

        elif self.config.use_mongodb:
            content = '''"""MongoDB database connection."""

from motor.motor_asyncio import AsyncIOMotorClient, AsyncIOMotorDatabase

from app.config import settings

client: AsyncIOMotorClient | None = None
db: AsyncIOMotorDatabase | None = None


async def init_db() -> None:
    """Initialize database connection."""
    global client, db
    client = AsyncIOMotorClient(settings.database_url)
    db = client[settings.database_name]


async def close_db() -> None:
    """Close database connection."""
    global client
    if client:
        client.close()


def get_db() -> AsyncIOMotorDatabase:
    """Get database instance."""
    if db is None:
        raise RuntimeError("Database not initialized")
    return db
'''
            self._write_file("app/database.py", content)
        else:
            content = '''"""SQLAlchemy database connection."""

from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker

from app.config import settings

engine = create_async_engine(settings.database_url, echo=settings.debug)
async_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)


async def init_db() -> None:
    """Initialize database."""
    pass  # Tables created via migrations


async def close_db() -> None:
    """Close database connections."""
    await engine.dispose()


async def get_db() -> AsyncSession:
    """Get database session."""
    async with async_session() as session:
        yield session
'''
            self._write_file("app/database.py", content)

    def _generate_init_files(self) -> None:
        """Generate __init__.py files."""
        # app/__init__.py
        self._write_file("app/__init__.py", '"""Application package."""\n')

        # app/api/__init__.py
        api_init = '''"""API routes package."""

from fastapi import APIRouter

router = APIRouter(tags=["api"])


# Import and include API routes here
# from app.api.users import router as users_router
# router.include_router(users_router)
'''
        self._write_file("app/api/__init__.py", api_init)

        # app/routers/__init__.py - preserve if has active imports
        if not self._should_preserve_file("app/routers/__init__.py"):
            routers_init = '''"""Routers package."""

from fastapi import APIRouter

router = APIRouter()
'''
            self._write_file("app/routers/__init__.py", routers_init)

        # app/models/__init__.py
        self._write_file("app/models/__init__.py", '"""Data models package."""\n')

        # app/services/__init__.py
        self._write_file("app/services/__init__.py", '"""Business logic services."""\n')

        # app/core/__init__.py
        self._write_file("app/core/__init__.py", '"""Core utilities package."""\n')

        # tests/__init__.py
        self._write_file("tests/__init__.py", '"""Test package."""\n')

    def _generate_auth_service(self) -> None:
        """Generate default auth service with get_current_user."""
        # Don't overwrite if file exists
        if self._should_preserve_file("app/services/auth.py"):
            return

        content = '''"""Authentication service."""

from fastapi import Request, HTTPException, status
from typing import Optional


class CurrentUser:
    """Represents the current authenticated user."""

    def __init__(self, id: int, username: str):
        self.id = id
        self.username = username


async def get_current_user(request: Request) -> Optional[CurrentUser]:
    """Get current user from session/cookie.

    TODO: Implement proper JWT/session validation.
    For now, returns a mock user for development.
    """
    # Check for access token in cookies
    token = request.cookies.get("access_token")

    if not token:
        # For development, allow unauthenticated access
        return CurrentUser(id=1, username="dev_user")

    # TODO: Validate JWT token and extract user info
    return CurrentUser(id=1, username="authenticated_user")
'''
        self._write_file("app/services/auth.py", content)

    def _generate_security_utils(self) -> None:
        """Generate default security utilities."""
        # Don't overwrite if file exists
        if self._should_preserve_file("app/core/security.py"):
            return

        content = '''"""Security utilities."""

from datetime import datetime, timedelta
from typing import Any

# Note: jose requires python-jose[cryptography] in requirements.txt
try:
    from jose import jwt
except ImportError:
    jwt = None  # type: ignore


def create_access_token(
    data: dict[str, Any],
    secret_key: str = "change-me-in-production",
    expires_delta: timedelta | None = None
) -> str:
    """Create JWT access token.

    Args:
        data: Data to encode in the token
        secret_key: Secret key for signing
        expires_delta: Token expiration time

    Returns:
        Encoded JWT token
    """
    if jwt is None:
        # Fallback if jose not installed
        import hashlib
        import json
        payload = json.dumps(data)
        return hashlib.sha256(payload.encode()).hexdigest()

    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(hours=24))
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, secret_key, algorithm="HS256")


def verify_token(token: str, secret_key: str = "change-me-in-production") -> dict | None:
    """Verify JWT token.

    Args:
        token: JWT token to verify
        secret_key: Secret key for verification

    Returns:
        Decoded payload or None if invalid
    """
    if jwt is None:
        return None

    try:
        payload = jwt.decode(token, secret_key, algorithms=["HS256"])
        return payload
    except Exception:
        return None
'''
        self._write_file("app/core/security.py", content)

    # =========================================================================
    # Templates
    # =========================================================================

    def _generate_base_template(self) -> None:
        """Generate base.html template."""
        htmx_script = '<script src="https://unpkg.com/htmx.org@1.9.10"></script>' if self.config.use_htmx else ''
        bootstrap_css = f'<link href="https://cdn.jsdelivr.net/npm/bootstrap@{self.config.bootstrap_version}/dist/css/bootstrap.min.css" rel="stylesheet">' if self.config.use_bootstrap else ''
        bootstrap_js = f'<script src="https://cdn.jsdelivr.net/npm/bootstrap@{self.config.bootstrap_version}/dist/js/bootstrap.bundle.min.js"></script>' if self.config.use_bootstrap else ''

        content = f'''<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{% block title %}}{{{{ title | default("{self.config.project_name}") }}}}{{% endblock %}}</title>

    {bootstrap_css}
    {htmx_script}

    <link rel="stylesheet" href="{{{{ url_for('static', path='css/app.css') }}}}">
    {{% block head_extra %}}{{% endblock %}}
</head>
<body>
    {{% block navbar %}}
    {{% include "components/navbar.html" %}}
    {{% endblock %}}

    {{% block flash_messages %}}
    <div class="container mt-3">
        {{% if messages %}}
        {{% for category, message in messages %}}
        <div class="alert alert-{{{{ category | default('info') }}}} alert-dismissible fade show" role="alert">
            {{{{ message }}}}
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        </div>
        {{% endfor %}}
        {{% endif %}}
    </div>
    {{% endblock %}}

    <main class="container mt-4">
        {{% block content %}}{{% endblock %}}
    </main>

    {{% block footer %}}
    {{% include "components/footer.html" %}}
    {{% endblock %}}

    {bootstrap_js}
    <script src="{{{{ url_for('static', path='js/app.js') }}}}"></script>
    {{% block scripts_extra %}}{{% endblock %}}
</body>
</html>
'''
        self._write_file("app/templates/base.html", content)

    def _generate_layout_templates(self) -> None:
        """Generate layout templates."""
        # Form layout
        form_layout = '''{% extends "base.html" %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-8 col-lg-6">
        <div class="card shadow-sm">
            <div class="card-header">
                <h4 class="mb-0">{% block form_title %}{{ title }}{% endblock %}</h4>
            </div>
            <div class="card-body">
                {% block form_content %}{% endblock %}
            </div>
        </div>
    </div>
</div>
{% endblock %}
'''
        self._write_file("app/templates/layouts/form.html", form_layout)

        # List layout
        list_layout = '''{% extends "base.html" %}

{% block content %}
<div class="d-flex justify-content-between align-items-center mb-4">
    <h2>{% block list_title %}{{ title }}{% endblock %}</h2>
    {% block list_actions %}{% endblock %}
</div>

<div class="card shadow-sm">
    <div class="card-body">
        {% block list_content %}{% endblock %}
    </div>
</div>

{% block pagination %}{% endblock %}
{% endblock %}
'''
        self._write_file("app/templates/layouts/list.html", list_layout)

    def _generate_component_templates(self) -> None:
        """Generate reusable component templates."""
        # Navbar
        navbar = f'''<nav class="navbar navbar-expand-lg navbar-dark bg-primary">
    <div class="container">
        <a class="navbar-brand" href="/">{self.config.project_name}</a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNav">
            <ul class="navbar-nav me-auto">
                <!-- Navigation items -->
            </ul>
            <ul class="navbar-nav">
                <!-- Right-side items (login, user menu, etc.) -->
            </ul>
        </div>
    </div>
</nav>
'''
        self._write_file("app/templates/components/navbar.html", navbar)

        # Footer - use current year at generation time
        from datetime import datetime
        current_year = datetime.now().year
        footer = f'''<footer class="footer mt-auto py-3 bg-light">
    <div class="container text-center text-muted">
        <span>&copy; {current_year} - Generated by wxcode</span>
    </div>
</footer>
'''
        self._write_file("app/templates/components/footer.html", footer)

        # Home page
        home = '''{% extends "base.html" %}

{% block content %}
<div class="text-center py-5">
    <h1>{{ title }}</h1>
    <p class="lead">Application successfully generated by wxcode.</p>
    <a href="/health" class="btn btn-primary">Health Check</a>
</div>
{% endblock %}
'''
        self._write_file("app/templates/pages/home.html", home)

    # =========================================================================
    # Static Files
    # =========================================================================

    def _generate_css(self) -> None:
        """Generate CSS files."""
        app_css = '''/* Application styles - Generated by wxcode */

/* Layout */
.page-container {
    padding: 1rem 0;
}

/* Forms */
.form-group {
    margin-bottom: 1rem;
}

.form-actions {
    display: flex;
    justify-content: flex-end;
    gap: 0.5rem;
    margin-top: 1.5rem;
}

/* Tables */
.table-actions {
    white-space: nowrap;
}

/* Cards */
.card {
    margin-bottom: 1rem;
}

/* HTMX loading indicator */
.htmx-request {
    opacity: 0.7;
    transition: opacity 200ms;
}

.htmx-indicator {
    display: none;
}

.htmx-request .htmx-indicator {
    display: inline-block;
}

/* Utilities */
.cursor-pointer {
    cursor: pointer;
}
'''
        self._write_file("app/static/css/app.css", app_css)

    def _generate_js(self) -> None:
        """Generate JavaScript files."""
        app_js = '''/* Application scripts - Generated by wxcode */

document.addEventListener('DOMContentLoaded', function() {
    console.log('Application initialized');

    // Initialize Bootstrap tooltips
    const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]');
    tooltipTriggerList.forEach(el => new bootstrap.Tooltip(el));

    // Form validation
    const forms = document.querySelectorAll('.needs-validation');
    forms.forEach(form => {
        form.addEventListener('submit', event => {
            if (!form.checkValidity()) {
                event.preventDefault();
                event.stopPropagation();
            }
            form.classList.add('was-validated');
        });
    });
});

// HTMX event handlers
document.body.addEventListener('htmx:beforeRequest', function(evt) {
    // Show loading indicator
});

document.body.addEventListener('htmx:afterRequest', function(evt) {
    // Hide loading indicator
});

document.body.addEventListener('htmx:responseError', function(evt) {
    console.error('Request failed:', evt.detail);
    // Show error notification
});

// Utility functions
function showNotification(message, type = 'info') {
    const container = document.querySelector('.container');
    const alert = document.createElement('div');
    alert.className = `alert alert-${type} alert-dismissible fade show`;
    alert.innerHTML = `
        ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
    container.insertBefore(alert, container.firstChild);

    setTimeout(() => alert.remove(), 5000);
}
'''
        self._write_file("app/static/js/app.js", app_js)

    # =========================================================================
    # Deployment Files
    # =========================================================================

    def _generate_dockerfile(self) -> None:
        """Generate Dockerfile."""
        content = f'''FROM python:{self.config.python_version}-slim

WORKDIR /app

# Install dependencies
COPY pyproject.toml .
RUN pip install --no-cache-dir .

# Copy application
COPY app/ app/

# Expose port
EXPOSE 8000

# Run application
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
'''
        self._write_file("Dockerfile", content)

    def _generate_docker_compose(self) -> None:
        """Generate docker-compose.yml."""
        if self.config.use_mongodb:
            db_service = '''  mongo:
    image: mongo:7
    ports:
      - "27017:27017"
    volumes:
      - mongo_data:/data/db
    environment:
      MONGO_INITDB_DATABASE: app_db

volumes:
  mongo_data:'''
            db_env = '''      - DATABASE_URL=mongodb://mongo:27017
      - DATABASE_NAME=app_db'''
            db_depends = "mongo"
        else:
            db_service = '''  postgres:
    image: postgres:16
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    environment:
      POSTGRES_DB: app_db
      POSTGRES_USER: app
      POSTGRES_PASSWORD: secret

volumes:
  postgres_data:'''
            db_env = "      - DATABASE_URL=postgresql://app:secret@postgres:5432/app_db"
            db_depends = "postgres"

        content = f'''version: "3.8"

services:
  app:
    build: .
    ports:
      - "8000:8000"
    environment:
{db_env}
      - DEBUG=false
    depends_on:
      - {db_depends}
    volumes:
      - ./app:/app/app:ro

{db_service}
'''
        self._write_file("docker-compose.yml", content)

    def _generate_pyproject_toml(self) -> None:
        """Generate pyproject.toml."""
        db_deps = '    "motor>=3.3.0",\n    "beanie>=1.25.0",' if self.config.use_mongodb else '    "sqlalchemy[asyncio]>=2.0.0",\n    "asyncpg>=0.29.0",'

        content = f'''[project]
name = "{self.config.project_name}"
version = "1.0.0"
description = "{self.config.project_description}"
requires-python = ">={self.config.python_version}"
dependencies = [
    "fastapi>=0.109.0",
    "uvicorn[standard]>=0.27.0",
{db_deps}
    "pydantic>=2.5.0",
    "pydantic-settings>=2.1.0",
    "jinja2>=3.1.0",
    "python-multipart>=0.0.6",
    "httpx>=0.26.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=8.0.0",
    "pytest-asyncio>=0.23.0",
    "pytest-cov>=4.1.0",
    "ruff>=0.1.0",
    "mypy>=1.8.0",
]

[tool.pytest.ini_options]
asyncio_mode = "auto"
testpaths = ["tests"]

[tool.ruff]
line-length = 100
target-version = "py311"

[tool.mypy]
python_version = "{self.config.python_version}"
strict = true
'''
        self._write_file("pyproject.toml", content)

    def _generate_requirements_txt(self) -> None:
        """Generate requirements.txt for pip install."""
        # Determine database dependencies
        db_deps_list = []

        if self.config.connections:
            types_needed = {conn.database_type for conn in self.config.connections}

            # Add SQLAlchemy if any SQL database
            if any(t in types_needed for t in ("sqlserver", "mysql", "postgresql", "oracle")):
                db_deps_list.append("sqlalchemy[asyncio]>=2.0.0")

            # Add specific drivers
            if "sqlserver" in types_needed:
                db_deps_list.append("aioodbc>=0.5.0")
                db_deps_list.append("pyodbc>=5.0.0")
            if "mysql" in types_needed:
                db_deps_list.append("aiomysql>=0.2.0")
            if "postgresql" in types_needed:
                db_deps_list.append("asyncpg>=0.29.0")
            if "oracle" in types_needed:
                db_deps_list.append("oracledb>=2.0.0")

            db_deps = "\n".join(db_deps_list) if db_deps_list else "# No database dependencies"

        elif self.config.use_mongodb:
            db_deps = "motor>=3.3.0\nbeanie>=1.25.0"
        else:
            db_deps = "sqlalchemy[asyncio]>=2.0.0\nasyncpg>=0.29.0"

        content = f'''# Generated by wxcode
# Install with: pip install -r requirements.txt

# Web framework
fastapi>=0.109.0
uvicorn[standard]>=0.27.0

# Database
{db_deps}

# Validation & Settings
pydantic>=2.5.0
pydantic-settings>=2.1.0

# Templates
jinja2>=3.1.0

# Forms & HTTP
python-multipart>=0.0.6
httpx>=0.26.0

# Development (optional)
# pytest>=8.0.0
# pytest-asyncio>=0.23.0
# ruff>=0.1.0
'''
        self._write_file("requirements.txt", content)

    def _generate_readme(self) -> None:
        """Generate README.md with project documentation."""
        db_name = "MongoDB" if self.config.use_mongodb else "PostgreSQL"
        db_url = "mongodb://localhost:27017" if self.config.use_mongodb else "postgresql://localhost:5432/app"

        content = f'''# {self.config.project_name}

{self.config.project_description}

## Stack

- **Framework:** FastAPI
- **Templates:** Jinja2
- **Database:** {db_name}
- **Python:** {self.config.python_version}+

## Quick Start

### 1. Install dependencies

```bash
pip install -r requirements.txt
```

### 2. Configure environment

```bash
cp .env.example .env
# Edit .env with your settings
```

### 3. Run the application

```bash
uvicorn app.main:app --reload
```

The application will be available at http://127.0.0.1:8000

## Project Structure

```
{self.config.project_name}/
├── app/
│   ├── main.py           # FastAPI application
│   ├── config.py         # Settings
│   ├── database.py       # Database connection
│   ├── api/              # API routes (JSON)
│   ├── routes/           # Page routes (HTML)
│   ├── models/           # Data models
│   ├── services/         # Business logic
│   ├── templates/        # Jinja2 templates
│   │   ├── base.html
│   │   ├── pages/
│   │   ├── components/
│   │   └── layouts/
│   └── static/           # Static files (CSS, JS, images)
├── tests/                # Test files
├── requirements.txt
├── pyproject.toml
├── Dockerfile
└── docker-compose.yml
```

## Endpoints

- `GET /` - Home page
- `GET /health` - Health check
- `GET /api/v1/...` - API endpoints

## Docker

```bash
# Build and run
docker-compose up --build

# Run in background
docker-compose up -d
```

## Development

```bash
# Install dev dependencies
pip install -e ".[dev]"

# Run tests
pytest

# Run with auto-reload
uvicorn app.main:app --reload
```

---

Generated by [wxcode](https://github.com/wxcode/wxcode)
'''
        self._write_file("README.md", content)

    def _generate_env_example(self) -> None:
        """Generate .env.example with dynamic database connections."""
        content = f"# Application\nAPP_NAME={self.config.project_name}\nDEBUG=false\n\n"

        if self.config.connections:
            # Generate environment variables for each connection
            for conn in self.config.connections:
                conn_var = conn.name.upper()
                content += f"# Database: {conn.name} ({conn.driver_name})\n"
                content += f"{conn_var}_HOST={conn.source or 'localhost'}\n"
                content += f"{conn_var}_PORT={conn.port or '5432'}\n"
                content += f"{conn_var}_DATABASE={conn.database or 'app_db'}\n"
                content += f"{conn_var}_USER={conn.user or 'user'}\n"
                content += f"{conn_var}_PASSWORD=\n"
                content += f"{conn_var}_TYPE={conn.database_type}\n"
                content += "\n"
        else:
            # Default database connection
            db_url = "mongodb://localhost:27017" if self.config.use_mongodb else "postgresql://localhost:5432/app"
            content += f"# Database\nDATABASE_URL={db_url}\nDATABASE_NAME={self.config.project_name}_db\n\n"

        content += "# Security\nSECRET_KEY=change-me-in-production\n"

        self._write_file(".env.example", content)

    def _generate_gitignore(self) -> None:
        """Generate .gitignore."""
        content = '''# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
.venv/
venv/
ENV/

# IDE
.idea/
.vscode/
*.swp
*.swo

# Testing
.pytest_cache/
.coverage
htmlcov/

# Environment
.env
.env.local

# Docker
.docker/

# OS
.DS_Store
Thumbs.db
'''
        self._write_file(".gitignore", content)

    def _generate_test_files(self) -> None:
        """Generate test files."""
        conftest = '''"""Pytest configuration."""

import pytest
from httpx import AsyncClient

from app.main import app


@pytest.fixture
async def client():
    """Async HTTP client for testing."""
    async with AsyncClient(app=app, base_url="http://test") as ac:
        yield ac
'''
        self._write_file("tests/conftest.py", conftest)

        test_health = '''"""Health endpoint tests."""

import pytest


@pytest.mark.asyncio
async def test_health(client):
    """Test health endpoint returns healthy status."""
    response = await client.get("/health")
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "healthy"


@pytest.mark.asyncio
async def test_home(client):
    """Test home page loads."""
    response = await client.get("/")
    assert response.status_code == 200
'''
        self._write_file("tests/test_health.py", test_health)


def generate_starter_kit(
    output_dir: Path,
    project_name: str = "app",
    use_mongodb: bool = True,
) -> StarterKitResult:
    """Convenience function to generate starter kit.

    Args:
        output_dir: Where to create the project
        project_name: Name of the project
        use_mongodb: Use MongoDB (True) or PostgreSQL (False)

    Returns:
        StarterKitResult with details of created files
    """
    config = StarterKitConfig(
        project_name=project_name,
        use_mongodb=use_mongodb,
    )
    generator = StarterKitGenerator(output_dir, config)
    return generator.generate()
