"""Base generator class for FastAPI+Jinja2 code generation."""

from abc import ABC, abstractmethod
from datetime import datetime
from pathlib import Path
from typing import Any, TypeVar

from bson import ObjectId
from jinja2 import Environment, PackageLoader, select_autoescape

from wxcode.models.element import (
    ConversionStatus,
    ConvertedFile,
    Element,
    ElementConversion,
)

from .result import GenerationResult

# Type variable for elements that can be tracked
T = TypeVar("T")


class ElementFilter:
    """Filter for selecting elements to convert."""

    def __init__(
        self,
        element_ids: list[str] | None = None,
        element_names: list[str] | None = None,
        include_converted: bool = False,
    ):
        """Initialize element filter.

        Args:
            element_ids: List of element ObjectId strings to include
            element_names: List of element names to include (supports wildcards with *)
            include_converted: If True, include already converted elements
        """
        self.element_ids = element_ids
        self.element_names = element_names
        self.include_converted = include_converted

    def matches(self, element: Any) -> bool:
        """Check if element matches the filter.

        Args:
            element: Element to check

        Returns:
            True if element matches filter criteria
        """
        # If no filters specified, match all
        if not self.element_ids and not self.element_names:
            # But check converted status
            if not self.include_converted and element.is_converted:
                return False
            return True

        # Check by ID
        if self.element_ids:
            if str(element.id) in self.element_ids:
                return True

        # Check by name (with wildcard support)
        if self.element_names:
            import fnmatch
            for pattern in self.element_names:
                if fnmatch.fnmatch(element.source_name, pattern):
                    return True

        return False

    def to_query(self, project_id: ObjectId) -> dict[str, Any]:
        """Convert filter to MongoDB query.

        Args:
            project_id: Project ObjectId

        Returns:
            MongoDB query dictionary
        """
        # project_id is a Link[Project] (DBRef), so query using $id
        query: dict[str, Any] = {"project_id.$id": project_id}

        # Filter by IDs
        if self.element_ids:
            query["_id"] = {"$in": [ObjectId(eid) for eid in self.element_ids]}

        # Filter by names (regex for wildcards)
        if self.element_names and not self.element_ids:
            import re
            patterns = []
            for name in self.element_names:
                # Convert wildcard to regex
                regex = "^" + re.escape(name).replace(r"\*", ".*") + "$"
                patterns.append({"source_name": {"$regex": regex}})
            if len(patterns) == 1:
                query.update(patterns[0])
            else:
                query["$or"] = patterns

        # Exclude converted unless requested
        if not self.include_converted:
            query["conversion.status"] = {"$nin": ["converted", "validated"]}

        return query


class BaseGenerator(ABC):
    """Abstract base class for all code generators.

    Provides common functionality for file generation and template rendering.
    Subclasses must implement the generate() method.

    Attributes:
        project_id: MongoDB ObjectId string for the project
        output_dir: Root directory for generated files
        generated_files: List of files generated by this generator
        element_filter: Optional filter for selecting elements
    """

    # Template subdirectory for this generator type
    # Subclasses can override (e.g., 'python', 'jinja2', 'deploy')
    template_subdir: str = "python"

    def __init__(
        self,
        project_id: str,
        output_dir: Path,
        element_filter: ElementFilter | None = None,
    ):
        """Initialize the generator.

        Args:
            project_id: MongoDB ObjectId string for the project to generate from
            output_dir: Root directory where files will be written
            element_filter: Optional filter for selecting elements to convert
        """
        self.project_id = project_id
        self.output_dir = Path(output_dir)
        self.generated_files: list[Path] = []
        self.element_filter = element_filter
        self._jinja_env: Environment | None = None
        self._converted_elements: list[Element] = []  # Track converted elements
        self._element_files: dict[str, list[str]] = {}  # element_id -> [file_paths]

    @property
    def jinja_env(self) -> Environment:
        """Get or create Jinja2 environment for template rendering.

        Uses templates from src/wxcode/generator/templates/<subdir>/
        """
        if self._jinja_env is None:
            self._jinja_env = Environment(
                loader=PackageLoader(
                    "wxcode.generator",
                    f"templates/{self.template_subdir}"
                ),
                autoescape=select_autoescape(
                    enabled_extensions=("html", "xml"),
                    default_for_string=False,
                ),
                trim_blocks=True,
                lstrip_blocks=True,
                keep_trailing_newline=True,
            )
            # Add custom filters
            self._jinja_env.filters["snake_case"] = self._to_snake_case
            self._jinja_env.filters["pascal_case"] = self._to_pascal_case
            self._jinja_env.filters["camel_case"] = self._to_camel_case

        return self._jinja_env

    @abstractmethod
    async def generate(self) -> list[Path]:
        """Generate files from the knowledge base.

        Must be implemented by subclasses. Should:
        1. Query MongoDB for relevant data
        2. Process and transform data
        3. Use write_file() to create output files
        4. Return list of generated file paths

        Returns:
            List of Path objects for generated files
        """
        pass

    def write_file(self, relative_path: str, content: str) -> Path:
        """Write content to a file, creating directories as needed.

        Args:
            relative_path: Path relative to output_dir (e.g., 'app/models/cliente.py')
            content: String content to write to the file

        Returns:
            Full Path to the created file
        """
        full_path = self.output_dir / relative_path
        full_path.parent.mkdir(parents=True, exist_ok=True)
        full_path.write_text(content, encoding="utf-8")
        self.generated_files.append(full_path)
        return full_path

    def render_template(self, template_name: str, context: dict[str, Any]) -> str:
        """Render a Jinja2 template with the given context.

        Args:
            template_name: Name of template file (e.g., 'model.py.j2')
            context: Dictionary of variables to pass to template

        Returns:
            Rendered template string
        """
        template = self.jinja_env.get_template(template_name)
        return template.render(**context)

    def render_template_string(self, template_str: str, context: dict[str, Any]) -> str:
        """Render a template from string (for dynamic templates).

        Args:
            template_str: Jinja2 template as string
            context: Dictionary of variables to pass to template

        Returns:
            Rendered template string
        """
        template = self.jinja_env.from_string(template_str)
        return template.render(**context)

    # Element tracking methods

    def track_element(self, element: Element) -> None:
        """Track an element for conversion status update.

        Args:
            element: Element being converted
        """
        if element not in self._converted_elements:
            self._converted_elements.append(element)
            self._element_files[str(element.id)] = []

    def write_file_for_element(
        self, element: Element, relative_path: str, content: str, file_type: str
    ) -> Path:
        """Write content to a file and track it for the element.

        This method combines writing the file with tracking which files
        were generated for which element, enabling:
        - Idempotent conversion (delete old files before regenerating)
        - Status tracking (update Element.conversion after generation)

        Args:
            element: Element this file was generated from
            relative_path: Path relative to output_dir
            content: String content to write
            file_type: Type of file (model, service, route, template)

        Returns:
            Full Path to the created file
        """
        # Track the element
        self.track_element(element)

        # Track file for this element
        element_id = str(element.id)
        if element_id in self._element_files:
            self._element_files[element_id].append(relative_path)

        # Write the file
        return self.write_file(relative_path, content)

    async def update_element_status(
        self,
        element: Element,
        status: ConversionStatus = ConversionStatus.CONVERTED,
        issues: list[str] | None = None,
        human_review_required: bool = False,
    ) -> None:
        """Update element conversion status in MongoDB.

        Accumulates target_files from multiple generators instead of replacing.

        Args:
            element: Element to update
            status: New conversion status
            issues: List of issues found during conversion
            human_review_required: Whether human review is needed
        """
        element_id = str(element.id)

        # Build list of new converted files from this generator
        new_files = []
        new_file_types = set()
        for relative_path in self._element_files.get(element_id, []):
            full_path = self.output_dir / relative_path
            if full_path.exists():
                file_type = self._detect_file_type(relative_path)
                new_files.append(ConvertedFile(
                    path=relative_path,
                    file_type=file_type,
                    content=full_path.read_text(encoding="utf-8"),
                ))
                new_file_types.add(file_type)

        # Keep existing files from other generators (different file types)
        existing_files = []
        if element.conversion and element.conversion.target_files:
            for f in element.conversion.target_files:
                if f.file_type not in new_file_types:
                    existing_files.append(f)

        # Combine existing files with new files
        all_files = existing_files + new_files

        # Update element conversion metadata
        element.conversion.status = status
        element.conversion.target_files = all_files
        element.conversion.issues = (element.conversion.issues or []) + (issues or [])
        element.conversion.human_review_required = (
            element.conversion.human_review_required or human_review_required
        )
        element.conversion.converted_at = datetime.utcnow()
        element.updated_at = datetime.utcnow()

        await element.save()

    async def update_all_converted_elements(
        self,
        status: ConversionStatus = ConversionStatus.CONVERTED,
    ) -> int:
        """Update status for all tracked converted elements.

        Args:
            status: Status to set for all elements

        Returns:
            Number of elements updated
        """
        count = 0
        for element in self._converted_elements:
            await self.update_element_status(element, status)
            count += 1
        return count

    def _detect_file_type(self, path: str) -> str:
        """Detect file type from path.

        Args:
            path: File path

        Returns:
            File type string
        """
        if "/models/" in path:
            return "model"
        elif "/services/" in path:
            return "service"
        elif "/routes/" in path:
            return "route"
        elif "/api/" in path:
            return "api"
        elif "/templates/" in path:
            return "template"
        elif "/domain/" in path:
            return "domain"
        elif path.endswith(".css"):
            return "style"
        elif path.endswith(".js"):
            return "script"
        else:
            return "other"

    def get_element_query(self, source_types: list[str] | str) -> dict[str, Any]:
        """Get MongoDB query for elements with filter applied.

        Args:
            source_types: Single source type or list of source types

        Returns:
            MongoDB query dictionary
        """
        # Start with base filter if available
        if self.element_filter:
            query = self.element_filter.to_query(ObjectId(self.project_id))
        else:
            # project_id is a Link[Project] (DBRef), so query using $id
            query = {"project_id.$id": ObjectId(self.project_id)}

        # Add source type filter
        if isinstance(source_types, str):
            query["source_type"] = source_types
        else:
            query["source_type"] = {"$in": source_types}

        return query

    async def clean_previous_files(
        self, element: Element, file_types: list[str] | None = None
    ) -> int:
        """Remove previously generated files for an element.

        This enables idempotent conversion by cleaning up old files
        before regenerating. Only removes files matching the specified
        file types to avoid deleting files from other generators.

        Args:
            element: Element whose files should be cleaned
            file_types: List of file types to clean (e.g., ["route", "template"]).
                       If None, cleans all files (use with caution).

        Returns:
            Number of files removed
        """
        removed = 0

        # Check if element has previous target files
        if element.conversion and element.conversion.target_files:
            remaining_files = []
            for converted_file in element.conversion.target_files:
                # Only clean files of specified types
                if file_types is None or converted_file.file_type in file_types:
                    file_path = self.output_dir / converted_file.path
                    if file_path.exists():
                        file_path.unlink()
                        removed += 1
                else:
                    # Keep files from other generators
                    remaining_files.append(converted_file)

            # Update element to only keep non-deleted files
            element.conversion.target_files = remaining_files

        return removed

    # Utility methods for name conversion

    @staticmethod
    def _to_snake_case(name: str) -> str:
        """Convert name to snake_case.

        Examples:
            'ClienteService' -> 'cliente_service'
            'PAGE_Login' -> 'page_login'
            'sNomeUsuario' -> 's_nome_usuario'
            'CLIENTE' -> 'cliente'
        """
        import re

        # If name is all uppercase, just lowercase it
        if name.isupper():
            return name.lower()

        # Handle prefixes like PAGE_, EDT_, BTN_
        if "_" in name and name.split("_")[0].isupper():
            return name.lower()

        # Insert underscore before capitals (for PascalCase/camelCase)
        name = re.sub(r"(?<!^)(?=[A-Z])", "_", name).lower()

        # Clean up multiple underscores
        name = re.sub(r"_+", "_", name)
        return name.strip("_")

    @staticmethod
    def _to_pascal_case(name: str) -> str:
        """Convert name to PascalCase.

        Examples:
            'cliente_service' -> 'ClienteService'
            'page_login' -> 'PageLogin'
        """
        # Split on underscores and capitalize each part
        parts = name.replace("-", "_").split("_")
        return "".join(part.capitalize() for part in parts if part)

    @staticmethod
    def _to_camel_case(name: str) -> str:
        """Convert name to camelCase.

        Examples:
            'cliente_service' -> 'clienteService'
            'page_login' -> 'pageLogin'
        """
        pascal = BaseGenerator._to_pascal_case(name)
        if pascal:
            return pascal[0].lower() + pascal[1:]
        return ""
