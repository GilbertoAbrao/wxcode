---
phase: 06-graph-analysis-tools
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/wxcode/mcp/tools/graph.py
autonomous: true

must_haves:
  truths:
    - "User can identify hub nodes (elements with many connections)"
    - "User can detect potentially dead code (unused procedures/classes)"
    - "User can find circular dependencies in the codebase"
  artifacts:
    - path: "src/wxcode/mcp/tools/graph.py"
      provides: "Advanced graph analysis MCP tools"
      exports: ["find_hubs", "find_dead_code", "find_cycles"]
  key_links:
    - from: "find_hubs"
      to: "ImpactAnalyzer.find_hubs"
      via: "method call"
      pattern: "analyzer\\.find_hubs"
    - from: "find_dead_code"
      to: "ImpactAnalyzer.find_dead_code"
      via: "method call"
      pattern: "analyzer\\.find_dead_code"
    - from: "find_cycles"
      to: "ImpactAnalyzer.find_cycles"
      via: "method call"
      pattern: "analyzer\\.find_cycles"
---

<objective>
Add advanced graph analysis tools for hub detection, dead code, and cycle detection.

Purpose: Complete the graph analysis toolkit with tools for identifying critical elements, cleanup opportunities, and problematic circular dependencies.

Output:
- 3 additional tools in `graph.py`: find_hubs, find_dead_code, find_cycles
- Total: 6 graph tools, 15 MCP tools overall
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-graph-analysis-tools/06-RESEARCH.md
@.planning/phases/06-graph-analysis-tools/06-01-SUMMARY.md
@src/wxcode/graph/impact_analyzer.py
@src/wxcode/mcp/tools/graph.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add find_hubs tool</name>
  <files>src/wxcode/mcp/tools/graph.py</files>
  <action>
Add `find_hubs` tool to `graph.py`.

**Parameters:**
- `min_connections: int = 10` - Minimum total connections to be considered a hub
- `project_name: str | None = None` - Optional project filter

**Implementation:**
1. Use `_check_neo4j(ctx)` helper (already exists from 06-01)
2. Instantiate `ImpactAnalyzer(conn)`
3. Call `analyzer.find_hubs(min_connections=min_connections, project=project_name)`
4. Handle `result.error` with code "ANALYSIS_ERROR"

**Return format:**
```python
{
    "error": False,
    "data": {
        "min_connections": 10,
        "hub_count": 5,
        "hubs": [
            {
                "name": "ServerProcedures",
                "type": "Procedure",
                "incoming": 25,
                "outgoing": 15,
                "total": 40
            }
        ]
    }
}
```

**Dataclass conversion:**
- `HubResult.hubs` contains `HubNode` objects
- Convert each: name, node_type->type, incoming, outgoing, total_connections->total

**Docstring:**
- Explain that hubs are critical elements with many dependencies
- Changes to hubs have high impact across the codebase
  </action>
  <verify>
    python -c "from wxcode.mcp.tools.graph import find_hubs; print('find_hubs imported')"
  </verify>
  <done>
    find_hubs tool added and importable
  </done>
</task>

<task type="auto">
  <name>Task 2: Add find_dead_code tool</name>
  <files>src/wxcode/mcp/tools/graph.py</files>
  <action>
Add `find_dead_code` tool to `graph.py`.

**Parameters:**
- `project_name: str | None = None` - Optional project filter
- `exclude_prefixes: list[str] | None = None` - Entry point prefixes to exclude

**Implementation:**
1. Use `_check_neo4j(ctx)` helper
2. Instantiate `ImpactAnalyzer(conn)`
3. Call `analyzer.find_dead_code(project=project_name, entry_point_prefixes=exclude_prefixes)`
4. Handle `result.error` with code "ANALYSIS_ERROR"

**Return format:**
```python
{
    "error": False,
    "data": {
        "total": 12,
        "procedures": ["proc_OldValidation", "proc_Unused"],
        "classes": ["classLegacy"],
        "excluded_prefixes": ["API", "Task", "PAGE_", "WIN_"]
    }
}
```

**Default prefixes:** When `exclude_prefixes` is None, include default list in response: `["API", "Task", "PAGE_", "WIN_"]`

**Docstring:**
- Explain these are potentially unused (no incoming calls/uses)
- Entry points (APIs, Pages, Tasks) are excluded by default
  </action>
  <verify>
    python -c "from wxcode.mcp.tools.graph import find_dead_code; print('find_dead_code imported')"
  </verify>
  <done>
    find_dead_code tool added and importable
  </done>
</task>

<task type="auto">
  <name>Task 3: Add find_cycles tool and verify all 6 graph tools</name>
  <files>src/wxcode/mcp/tools/graph.py</files>
  <action>
Add `find_cycles` tool to `graph.py` and verify all 6 tools work together.

**Parameters:**
- `node_type: str = "Procedure"` - Type of nodes to check for cycles
- `max_length: int = 10` - Maximum cycle length to detect
- `project_name: str | None = None` - Optional project filter

**Implementation:**
1. Use `_check_neo4j(ctx)` helper
2. Instantiate `ImpactAnalyzer(conn)`
3. Call `analyzer.find_cycles(node_type=node_type, max_length=max_length, project=project_name)`
4. Note: find_cycles returns `list[list[str]]` directly, not a dataclass with error field
5. Wrap in try/except for INTERNAL_ERROR handling

**Return format:**
```python
{
    "error": False,
    "data": {
        "node_type": "Procedure",
        "cycle_count": 3,
        "cycles": [
            ["procA", "procB", "procC", "procA"],
            ["procX", "procY", "procX"]
        ]
    }
}
```

**Docstring:**
- Explain cycles are circular dependencies where A depends on B depends on A
- Limited to 100 cycles to prevent explosion
- Mention that max_length affects performance (lower is faster)

**Final verification after adding:**
- All 6 graph tools should be importable
- MCP server should load with 15 total tools (9 + 6)
  </action>
  <verify>
    python -c "
from wxcode.mcp.tools.graph import (
    get_dependencies, get_impact, get_path,
    find_hubs, find_dead_code, find_cycles
)
print('All 6 graph tools imported successfully')
"
  </verify>
  <done>
    All 6 graph tools implemented and importable
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
# Verify all 6 tools exist
python -c "
from wxcode.mcp.tools import graph
tools = [t for t in dir(graph) if not t.startswith('_') and callable(getattr(graph, t, None))]
print(f'Graph tools: {tools}')
assert len([t for t in tools if t in ['get_dependencies', 'get_impact', 'get_path', 'find_hubs', 'find_dead_code', 'find_cycles']]) == 6
print('All 6 graph tools verified')
"

# Verify MCP server loads all tools
python -c "
from wxcode.mcp.server import mcp
from wxcode.mcp import tools
print('MCP server ready with full graph analysis toolkit')
"
```
</verification>

<success_criteria>
- [ ] `find_hubs` returns hub nodes with connection counts
- [ ] `find_dead_code` returns potentially unused procedures and classes
- [ ] `find_cycles` returns circular dependency chains
- [ ] All 6 graph tools importable from graph module
- [ ] All tools return structured error when Neo4j unavailable
- [ ] MCP server starts without errors (15 total tools)
- [ ] Phase 6 requirements GRAPH-01 through GRAPH-06 all satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/06-graph-analysis-tools/06-02-SUMMARY.md`
</output>
