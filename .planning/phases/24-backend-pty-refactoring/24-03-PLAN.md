---
phase: 24-backend-pty-refactoring
plan: 03
type: execute
wave: 2
depends_on: ["24-01"]
files_modified:
  - src/wxcode/services/input_validator.py
  - tests/test_bidirectional_pty.py
  - tests/test_input_validator.py
autonomous: true

must_haves:
  truths:
    - "Input validator rejects inputs exceeding size limit"
    - "Input validator detects dangerous escape sequences"
    - "Input validator can sanitize input by removing dangerous sequences"
    - "BidirectionalPTY unit tests cover start, write, read, resize, close"
    - "InputValidator unit tests cover all dangerous sequence patterns"
  artifacts:
    - path: "src/wxcode/services/input_validator.py"
      provides: "Input validation and sanitization for PTY input"
      min_lines: 50
      exports: ["validate_input", "sanitize_input", "InputValidationError"]
    - path: "tests/test_bidirectional_pty.py"
      provides: "Unit tests for BidirectionalPTY"
      min_lines: 80
    - path: "tests/test_input_validator.py"
      provides: "Unit tests for input validation"
      min_lines: 60
  key_links:
    - from: "tests/test_bidirectional_pty.py"
      to: "src/wxcode/services/bidirectional_pty.py"
      via: "import BidirectionalPTY"
      pattern: "from.*bidirectional_pty.*import.*BidirectionalPTY"
    - from: "tests/test_input_validator.py"
      to: "src/wxcode/services/input_validator.py"
      via: "import validate_input"
      pattern: "from.*input_validator.*import"
---

<objective>
Create input validation module and unit tests for PTY security.

Purpose: Prevent malicious escape sequences and oversized inputs from being piped to Claude Code process. Security is critical since user input goes directly to terminal.

Output: input_validator.py module and comprehensive unit tests for both BidirectionalPTY and InputValidator.
</objective>

<execution_context>
@/Users/gilberto/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gilberto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/24-backend-pty-refactoring/24-RESEARCH.md
@src/wxcode/services/bidirectional_pty.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create input_validator.py</name>
  <files>src/wxcode/services/input_validator.py</files>
  <action>
Create input validation module based on research (24-RESEARCH.md lines 533-568):

```python
"""
Input Validator - Security validation for PTY input.

Prevents malicious escape sequences and oversized inputs from being
piped to Claude Code process. Based on OWASP guidelines and terminal
security research.
"""

import re
from typing import Optional

__all__ = [
    "validate_input",
    "sanitize_input",
    "InputValidationError",
    "MAX_MESSAGE_SIZE",
    "MAX_INPUT_RATE",
]


class InputValidationError(Exception):
    """Raised when input validation fails."""

    def __init__(self, message: str, reason: str):
        super().__init__(message)
        self.reason = reason


# Maximum single message size: 2KB
MAX_MESSAGE_SIZE = 2 * 1024

# Maximum input rate: 10KB/second (for rate limiting in caller)
MAX_INPUT_RATE = 10 * 1024

# Dangerous escape sequences to filter
# Based on terminal escape injection research
DANGEROUS_SEQUENCES = [
    re.compile(rb"\x1b\]0;"),      # OSC title change (can spoof prompts)
    re.compile(rb"\x1b\]52;"),     # OSC clipboard manipulation
    re.compile(rb"\x1bP"),          # DCS (device control string)
    re.compile(rb"\x1b\[.*?p"),     # Key remapping (DECUDK)
    re.compile(rb"\x1b\]4;"),       # Color palette modification
    re.compile(rb"\x1b\]10;"),      # Foreground color change
    re.compile(rb"\x1b\]11;"),      # Background color change
    re.compile(rb"\x1b\[!p"),       # Soft terminal reset
]


def validate_input(data: bytes) -> tuple[bool, Optional[str]]:
    """Validate terminal input for security.

    Args:
        data: Raw bytes to validate

    Returns:
        Tuple of (is_valid, error_message or None)

    Examples:
        >>> validate_input(b"hello")
        (True, None)
        >>> validate_input(b"x" * 3000)
        (False, "Input too large: 3000 bytes (max 2048)")
    """
    # Check size limit
    if len(data) > MAX_MESSAGE_SIZE:
        return False, f"Input too large: {len(data)} bytes (max {MAX_MESSAGE_SIZE})"

    # Check for dangerous escape sequences
    for pattern in DANGEROUS_SEQUENCES:
        if pattern.search(data):
            return False, "Potentially dangerous escape sequence detected"

    return True, None


def sanitize_input(data: bytes) -> bytes:
    """Remove dangerous escape sequences from input.

    Use this as alternative to rejection when you want to allow
    the input but strip dangerous parts.

    Args:
        data: Raw bytes to sanitize

    Returns:
        Sanitized bytes with dangerous sequences removed
    """
    result = data
    for pattern in DANGEROUS_SEQUENCES:
        result = pattern.sub(b"", result)
    return result


def is_control_sequence(data: bytes) -> bool:
    """Check if data is a terminal control sequence.

    Useful for detecting Ctrl+C (0x03), Ctrl+D (0x04), etc.

    Args:
        data: Raw bytes to check

    Returns:
        True if data is a single control character
    """
    if len(data) == 1:
        byte = data[0]
        # Control characters are 0x00-0x1F
        return 0 <= byte <= 0x1F
    return False


# Map of common control sequences to signal names
CONTROL_TO_SIGNAL = {
    b"\x03": "SIGINT",   # Ctrl+C
    b"\x04": "EOF",      # Ctrl+D
    b"\x1a": "SIGTSTP",  # Ctrl+Z
    b"\x1c": "SIGQUIT",  # Ctrl+\
}


def get_control_signal(data: bytes) -> Optional[str]:
    """Get signal name for control sequence if applicable.

    Args:
        data: Raw bytes (should be single control character)

    Returns:
        Signal name or None if not a recognized control
    """
    return CONTROL_TO_SIGNAL.get(data)
```

Key implementation details:
- MAX_MESSAGE_SIZE = 2KB (prevent buffer overflow attempts)
- DANGEROUS_SEQUENCES from research + additional patterns
- validate_input returns tuple (not raises) for caller flexibility
- sanitize_input for when rejection is too strict
- Control sequence detection for Ctrl+C handling
  </action>
  <verify>
```bash
python -c "
from wxcode.services.input_validator import (
    validate_input,
    sanitize_input,
    InputValidationError,
    MAX_MESSAGE_SIZE,
    is_control_sequence,
    get_control_signal,
)
# Test basic validation
assert validate_input(b'hello') == (True, None)
assert validate_input(b'x' * 3000)[0] == False
# Test dangerous sequence detection
assert validate_input(b'\x1b]0;malicious title\x07')[0] == False
# Test sanitization
assert sanitize_input(b'hello\x1b]0;bad\x07world') == b'helloworld'
# Test control detection
assert is_control_sequence(b'\x03') == True
assert get_control_signal(b'\x03') == 'SIGINT'
print('All validation tests passed')
"
```
  </verify>
  <done>input_validator.py with validate_input, sanitize_input, and control sequence helpers</done>
</task>

<task type="auto">
  <name>Task 2: Create BidirectionalPTY unit tests</name>
  <files>tests/test_bidirectional_pty.py</files>
  <action>
Create comprehensive unit tests for BidirectionalPTY:

```python
"""Unit tests for BidirectionalPTY."""

import asyncio
import os
import signal
import pytest

from wxcode.services.bidirectional_pty import BidirectionalPTY


class TestBidirectionalPTY:
    """Test cases for BidirectionalPTY class."""

    @pytest.mark.asyncio
    async def test_start_creates_pty(self):
        """Test that start() creates PTY and starts process."""
        pty = BidirectionalPTY(
            cmd=["echo", "hello"],
            cwd="/tmp",
        )
        await pty.start()

        assert pty.master_fd is not None
        assert pty.pid is not None
        assert pty.pid > 0

        await pty.close()

    @pytest.mark.asyncio
    async def test_read_output(self):
        """Test reading output from PTY."""
        pty = BidirectionalPTY(
            cmd=["echo", "hello world"],
            cwd="/tmp",
        )
        await pty.start()

        # Collect output
        output = b""
        async for chunk in pty.stream_output():
            output += chunk

        assert b"hello world" in output
        await pty.close()

    @pytest.mark.asyncio
    async def test_write_input(self):
        """Test writing input to PTY."""
        # Use cat which echoes input
        pty = BidirectionalPTY(
            cmd=["cat"],
            cwd="/tmp",
        )
        await pty.start()

        # Write some input
        await pty.write(b"test input\n")

        # Read output (cat echoes back)
        output = await pty.read(1024)
        # Note: PTY may echo the input
        assert output is not None

        # Send EOF to terminate cat
        await pty.write(b"\x04")  # Ctrl+D
        await asyncio.sleep(0.1)
        await pty.close()

    @pytest.mark.asyncio
    async def test_resize(self):
        """Test terminal resize."""
        pty = BidirectionalPTY(
            cmd=["sleep", "1"],
            cwd="/tmp",
            rows=24,
            cols=80,
        )
        await pty.start()

        # Resize should not raise
        await pty.resize(40, 120)

        assert pty.rows == 40
        assert pty.cols == 120

        await pty.close()

    @pytest.mark.asyncio
    async def test_send_signal(self):
        """Test sending signal to process."""
        pty = BidirectionalPTY(
            cmd=["sleep", "10"],
            cwd="/tmp",
        )
        await pty.start()

        # Send SIGTERM
        await pty.send_signal(signal.SIGTERM)

        # Wait for process to exit
        await asyncio.sleep(0.2)

        # Process should have exited
        assert pty.returncode is not None

        await pty.close()

    @pytest.mark.asyncio
    async def test_close_graceful_termination(self):
        """Test graceful termination on close."""
        pty = BidirectionalPTY(
            cmd=["sleep", "60"],
            cwd="/tmp",
        )
        await pty.start()
        pid = pty.pid

        await pty.close()

        # Process should be terminated
        assert pty._closed is True
        # Verify process is gone (will raise if still exists)
        with pytest.raises(ProcessLookupError):
            os.kill(pid, 0)

    @pytest.mark.asyncio
    async def test_returncode_property(self):
        """Test returncode property."""
        pty = BidirectionalPTY(
            cmd=["true"],  # Exits with 0
            cwd="/tmp",
        )
        await pty.start()

        # Wait for completion
        await asyncio.sleep(0.1)

        # Should have exit code 0
        assert pty.returncode == 0

        await pty.close()

    @pytest.mark.asyncio
    async def test_process_group_created(self):
        """Test that process is started in new session (process group)."""
        pty = BidirectionalPTY(
            cmd=["sleep", "1"],
            cwd="/tmp",
        )
        await pty.start()

        # Process group ID should equal PID (new session leader)
        pgid = os.getpgid(pty.pid)
        assert pgid == pty.pid

        await pty.close()

    @pytest.mark.asyncio
    async def test_env_variables(self):
        """Test custom environment variables."""
        env = os.environ.copy()
        env["TEST_VAR"] = "test_value"

        pty = BidirectionalPTY(
            cmd=["sh", "-c", "echo $TEST_VAR"],
            cwd="/tmp",
            env=env,
        )
        await pty.start()

        output = b""
        async for chunk in pty.stream_output():
            output += chunk

        assert b"test_value" in output
        await pty.close()

    @pytest.mark.asyncio
    async def test_operations_after_close_are_safe(self):
        """Test that operations after close don't raise."""
        pty = BidirectionalPTY(
            cmd=["true"],
            cwd="/tmp",
        )
        await pty.start()
        await pty.close()

        # These should not raise
        await pty.write(b"test")
        await pty.resize(24, 80)
        await pty.send_signal(signal.SIGTERM)
        # Double close should be safe
        await pty.close()
```

Key test patterns:
- Use pytest.mark.asyncio for async tests
- Use simple commands (echo, cat, sleep, true) for predictability
- Test edge cases (operations after close, signal handling)
- Verify process group creation for clean termination
  </action>
  <verify>
```bash
cd /Users/gilberto/projetos/wxk/wxcode && python -m pytest tests/test_bidirectional_pty.py -v --tb=short 2>&1 | head -50
```
  </verify>
  <done>Unit tests pass for BidirectionalPTY (start, read, write, resize, signal, close)</done>
</task>

<task type="auto">
  <name>Task 3: Create InputValidator unit tests</name>
  <files>tests/test_input_validator.py</files>
  <action>
Create comprehensive unit tests for input validation:

```python
"""Unit tests for input validation."""

import pytest

from wxcode.services.input_validator import (
    validate_input,
    sanitize_input,
    InputValidationError,
    MAX_MESSAGE_SIZE,
    is_control_sequence,
    get_control_signal,
    DANGEROUS_SEQUENCES,
)


class TestValidateInput:
    """Test cases for validate_input function."""

    def test_valid_simple_text(self):
        """Test valid simple text input."""
        is_valid, error = validate_input(b"hello world")
        assert is_valid is True
        assert error is None

    def test_valid_utf8(self):
        """Test valid UTF-8 input."""
        is_valid, error = validate_input("ol√° mundo".encode("utf-8"))
        assert is_valid is True
        assert error is None

    def test_valid_newlines(self):
        """Test input with newlines is valid."""
        is_valid, error = validate_input(b"line1\nline2\r\nline3")
        assert is_valid is True
        assert error is None

    def test_valid_control_c(self):
        """Test Ctrl+C is valid (not a dangerous sequence)."""
        is_valid, error = validate_input(b"\x03")
        assert is_valid is True

    def test_invalid_too_large(self):
        """Test rejection of oversized input."""
        large_input = b"x" * (MAX_MESSAGE_SIZE + 1)
        is_valid, error = validate_input(large_input)
        assert is_valid is False
        assert "too large" in error.lower()

    def test_invalid_exactly_at_limit(self):
        """Test input exactly at limit is valid."""
        exactly_max = b"x" * MAX_MESSAGE_SIZE
        is_valid, error = validate_input(exactly_max)
        assert is_valid is True

    def test_invalid_osc_title(self):
        """Test rejection of OSC title change."""
        malicious = b"\x1b]0;malicious title\x07"
        is_valid, error = validate_input(malicious)
        assert is_valid is False
        assert "escape sequence" in error.lower()

    def test_invalid_osc_clipboard(self):
        """Test rejection of clipboard manipulation."""
        malicious = b"\x1b]52;c;base64data\x07"
        is_valid, error = validate_input(malicious)
        assert is_valid is False

    def test_invalid_dcs(self):
        """Test rejection of device control string."""
        malicious = b"\x1bPsome control\x1b\\"
        is_valid, error = validate_input(malicious)
        assert is_valid is False

    def test_invalid_key_remapping(self):
        """Test rejection of key remapping sequence."""
        malicious = b"\x1b[0;59;\"cmd\np"
        is_valid, error = validate_input(malicious)
        assert is_valid is False

    def test_invalid_embedded_in_text(self):
        """Test rejection when dangerous sequence embedded in text."""
        mixed = b"normal text \x1b]0;title\x07 more text"
        is_valid, error = validate_input(mixed)
        assert is_valid is False


class TestSanitizeInput:
    """Test cases for sanitize_input function."""

    def test_sanitize_clean_text(self):
        """Test clean text passes through unchanged."""
        result = sanitize_input(b"hello world")
        assert result == b"hello world"

    def test_sanitize_removes_osc_title(self):
        """Test removal of OSC title sequence."""
        input_bytes = b"before\x1b]0;title\x07after"
        result = sanitize_input(input_bytes)
        assert b"\x1b]0;" not in result
        assert b"before" in result
        assert b"after" in result

    def test_sanitize_removes_multiple_sequences(self):
        """Test removal of multiple dangerous sequences."""
        input_bytes = b"\x1b]0;a\x07text\x1b]52;b\x07more"
        result = sanitize_input(input_bytes)
        assert b"\x1b]0;" not in result
        assert b"\x1b]52;" not in result

    def test_sanitize_preserves_safe_ansi(self):
        """Test that common ANSI codes are preserved."""
        # Color codes should be preserved (not in dangerous list)
        input_bytes = b"\x1b[32mgreen\x1b[0m"
        result = sanitize_input(input_bytes)
        assert result == input_bytes


class TestControlSequences:
    """Test cases for control sequence detection."""

    def test_is_control_ctrl_c(self):
        """Test Ctrl+C detection."""
        assert is_control_sequence(b"\x03") is True

    def test_is_control_ctrl_d(self):
        """Test Ctrl+D detection."""
        assert is_control_sequence(b"\x04") is True

    def test_is_control_regular_char(self):
        """Test regular character is not control."""
        assert is_control_sequence(b"a") is False

    def test_is_control_multi_byte(self):
        """Test multi-byte is not single control."""
        assert is_control_sequence(b"\x03\x03") is False

    def test_get_signal_ctrl_c(self):
        """Test Ctrl+C maps to SIGINT."""
        assert get_control_signal(b"\x03") == "SIGINT"

    def test_get_signal_ctrl_d(self):
        """Test Ctrl+D maps to EOF."""
        assert get_control_signal(b"\x04") == "EOF"

    def test_get_signal_ctrl_z(self):
        """Test Ctrl+Z maps to SIGTSTP."""
        assert get_control_signal(b"\x1a") == "SIGTSTP"

    def test_get_signal_unknown(self):
        """Test unknown returns None."""
        assert get_control_signal(b"\x01") is None
        assert get_control_signal(b"a") is None


class TestDangerousPatternsCoverage:
    """Ensure all dangerous patterns are tested."""

    @pytest.mark.parametrize("pattern,test_input", [
        ("osc_title", b"\x1b]0;x"),
        ("osc_clipboard", b"\x1b]52;x"),
        ("dcs", b"\x1bPx"),
        ("key_remap", b"\x1b[0p"),
        ("color_palette", b"\x1b]4;x"),
        ("fg_color", b"\x1b]10;x"),
        ("bg_color", b"\x1b]11;x"),
        ("soft_reset", b"\x1b[!p"),
    ])
    def test_dangerous_pattern(self, pattern, test_input):
        """Test each dangerous pattern is rejected."""
        is_valid, error = validate_input(test_input)
        assert is_valid is False, f"Pattern {pattern} should be rejected"
```

Key test patterns:
- Use parametrize for exhaustive pattern coverage
- Test edge cases (exactly at limit, embedded sequences)
- Test sanitization preserves safe content
- Map all DANGEROUS_SEQUENCES to test cases
  </action>
  <verify>
```bash
cd /Users/gilberto/projetos/wxk/wxcode && python -m pytest tests/test_input_validator.py -v --tb=short 2>&1 | head -50
```
  </verify>
  <done>Unit tests pass for InputValidator (validate_input, sanitize_input, control sequences)</done>
</task>

</tasks>

<verification>
1. input_validator.py exists with all functions
2. test_bidirectional_pty.py passes all tests
3. test_input_validator.py passes all tests
4. Run full test suite: `pytest tests/test_bidirectional_pty.py tests/test_input_validator.py -v`
</verification>

<success_criteria>
- input_validator.py exists with validate_input, sanitize_input, is_control_sequence, get_control_signal
- All dangerous sequences from research are covered in DANGEROUS_SEQUENCES
- test_bidirectional_pty.py has 10+ test cases covering all methods
- test_input_validator.py has 20+ test cases covering validation and sanitization
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/24-backend-pty-refactoring/24-03-SUMMARY.md`
</output>
