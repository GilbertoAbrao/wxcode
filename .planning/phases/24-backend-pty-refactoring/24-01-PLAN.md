---
phase: 24-backend-pty-refactoring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/wxcode/services/bidirectional_pty.py
  - src/wxcode/services/gsd_invoker.py
autonomous: true

must_haves:
  truths:
    - "BidirectionalPTY can start a process with PTY allocation"
    - "BidirectionalPTY can write user input to process stdin"
    - "BidirectionalPTY can read process output asynchronously"
    - "BidirectionalPTY can resize terminal with TIOCSWINSZ"
    - "BidirectionalPTY terminates entire process group on close"
  artifacts:
    - path: "src/wxcode/services/bidirectional_pty.py"
      provides: "BidirectionalPTY class with bidirectional communication"
      min_lines: 150
      exports: ["BidirectionalPTY"]
  key_links:
    - from: "src/wxcode/services/gsd_invoker.py"
      to: "src/wxcode/services/bidirectional_pty.py"
      via: "import BidirectionalPTY"
      pattern: "from.*bidirectional_pty.*import.*BidirectionalPTY"
---

<objective>
Extract PTY handling from gsd_invoker.py into a reusable BidirectionalPTY class with enhanced features.

Purpose: Enable bidirectional PTY communication (read/write) for interactive terminal sessions with Claude Code. The existing PTYStdin and PTYProcess classes are duplicated inline and lack resize support.

Output: New bidirectional_pty.py module that gsd_invoker.py imports, replacing inline classes.
</objective>

<execution_context>
@/Users/gilberto/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gilberto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-backend-pty-refactoring/24-RESEARCH.md
@src/wxcode/services/gsd_invoker.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BidirectionalPTY class</name>
  <files>src/wxcode/services/bidirectional_pty.py</files>
  <action>
Create new file with BidirectionalPTY class:

1. Extract patterns from gsd_invoker.py (PTYStdin lines 287-298, PTYProcess lines 301-327)

2. Implement BidirectionalPTY class with:
   - `__init__(cmd, cwd, env, rows=24, cols=80)` - Store config
   - `async start()` - Create PTY with pty.openpty(), set non-blocking, start Popen with preexec_fn=os.setsid
   - `async write(data: bytes)` - Write to master_fd via run_in_executor (NOT synchronous os.write)
   - `async read(size=4096)` - Read from master_fd via run_in_executor
   - `async stream_output() -> AsyncIterator[bytes]` - Yield output chunks using select
   - `async resize(rows, cols)` - Set window size with TIOCSWINSZ ioctl, send SIGWINCH to process group
   - `async send_signal(sig)` - Send signal to process group via os.killpg
   - `async close()` - Graceful termination (SIGTERM, wait 5s, SIGKILL), close master_fd
   - `returncode` property - Poll process exit code

3. Use stdlib only: pty, asyncio, fcntl, termios, struct, os, signal, subprocess, select

4. Key implementation details from research:
   - Set O_NONBLOCK on master_fd
   - Use struct.pack("HHHH", rows, cols, 0, 0) for winsize
   - Use termios.TIOCSWINSZ constant
   - Store self._closed flag to prevent operations on closed PTY
   - Handle ProcessLookupError and OSError in signal operations

Include module docstring explaining this is for interactive Claude Code sessions.
  </action>
  <verify>
```bash
python -c "from wxcode.services.bidirectional_pty import BidirectionalPTY; print('Import OK')"
```
  </verify>
  <done>BidirectionalPTY class importable with start, write, read, stream_output, resize, send_signal, close methods</done>
</task>

<task type="auto">
  <name>Task 2: Update gsd_invoker.py to use BidirectionalPTY</name>
  <files>src/wxcode/services/gsd_invoker.py</files>
  <action>
Refactor gsd_invoker.py to import and use BidirectionalPTY:

1. Add import at top:
   ```python
   from wxcode.services.bidirectional_pty import BidirectionalPTY
   ```

2. In invoke_with_streaming():
   - Remove inline PTYStdin class (lines 287-298)
   - Remove inline PTYProcess class (lines 301-327)
   - Replace PTY creation code (lines 256-284) with:
     ```python
     pty = BidirectionalPTY(
         cmd=cmd,
         cwd=str(self.working_dir),
         env=env,
         rows=24,
         cols=80,
     )
     await pty.start()
     ```
   - Update stream_pty_output to use pty.stream_output() or keep existing pattern but use pty.master_fd
   - Update cleanup to use await pty.close()

3. In resume_with_streaming():
   - Apply same refactoring pattern as invoke_with_streaming
   - Remove duplicated PTYStdin class (lines 746-758)
   - Remove duplicated PTYProcess class (lines 760-785)

4. Preserve existing functionality:
   - Keep http_client for n8n integration
   - Keep send_log, send_chat, send_file_event helpers
   - Keep extract_text_from_json, extract_file_events functions
   - Keep timeout handling and on_process_start/on_process_end callbacks

Note: The stream_pty_output function can remain inline since it handles WebSocket-specific logic, but should use the BidirectionalPTY's master_fd or stream_output method.
  </action>
  <verify>
```bash
cd /Users/gilberto/projetos/wxk/wxcode && python -c "from wxcode.services.gsd_invoker import GSDInvoker; print('Import OK')"
```
  </verify>
  <done>gsd_invoker.py uses BidirectionalPTY, no inline PTY classes</done>
</task>

<task type="auto">
  <name>Task 3: Add resize and signal methods to stream handling</name>
  <files>src/wxcode/services/gsd_invoker.py</files>
  <action>
Expose resize and signal capabilities through the GSDInvoker interface:

1. Modify invoke_with_streaming signature to accept optional resize_queue and signal_queue:
   ```python
   async def invoke_with_streaming(
       self,
       websocket: "WebSocket",
       conversion_id: str,
       timeout: int = 1800,
       on_process_start: Optional[Callable[[asyncio.subprocess.Process], None]] = None,
       on_process_end: Optional[Callable[[], None]] = None,
       resize_queue: Optional[asyncio.Queue] = None,  # NEW
       signal_queue: Optional[asyncio.Queue] = None,  # NEW
   ) -> int:
   ```

2. Create async task to handle resize events if resize_queue provided:
   ```python
   async def handle_resize():
       while not pty._closed:
           try:
               rows, cols = await asyncio.wait_for(resize_queue.get(), timeout=0.5)
               await pty.resize(rows, cols)
           except asyncio.TimeoutError:
               continue
   ```

3. Create async task to handle signal events if signal_queue provided:
   ```python
   async def handle_signals():
       while not pty._closed:
           try:
               sig = await asyncio.wait_for(signal_queue.get(), timeout=0.5)
               await pty.send_signal(sig)
           except asyncio.TimeoutError:
               continue
   ```

4. Run all tasks concurrently:
   ```python
   tasks = [asyncio.create_task(stream_pty_output())]
   if resize_queue:
       tasks.append(asyncio.create_task(handle_resize()))
   if signal_queue:
       tasks.append(asyncio.create_task(handle_signals()))

   done, pending = await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)
   for t in pending:
       t.cancel()
   ```

5. Apply same pattern to resume_with_streaming.

This prepares for Phase 25 (WebSocket Protocol Extension) which will create the queues and feed resize/signal events from WebSocket messages.
  </action>
  <verify>
```bash
cd /Users/gilberto/projetos/wxk/wxcode && python -c "
import asyncio
from wxcode.services.gsd_invoker import GSDInvoker
import inspect
sig = inspect.signature(GSDInvoker.invoke_with_streaming)
params = list(sig.parameters.keys())
assert 'resize_queue' in params, 'resize_queue param missing'
assert 'signal_queue' in params, 'signal_queue param missing'
print('Signature OK:', params)
"
```
  </verify>
  <done>invoke_with_streaming and resume_with_streaming accept resize_queue and signal_queue parameters</done>
</task>

</tasks>

<verification>
1. BidirectionalPTY imports successfully
2. GSDInvoker imports successfully with no inline PTY classes
3. resize_queue and signal_queue parameters exist in method signatures
4. Existing tests pass (if any): `pytest tests/ -v`
</verification>

<success_criteria>
- BidirectionalPTY class exists at src/wxcode/services/bidirectional_pty.py
- BidirectionalPTY has: start, write, read, stream_output, resize, send_signal, close methods
- gsd_invoker.py imports BidirectionalPTY instead of defining inline PTY classes
- invoke_with_streaming and resume_with_streaming accept resize_queue and signal_queue
- All imports work without errors
</success_criteria>

<output>
After completion, create `.planning/phases/24-backend-pty-refactoring/24-01-SUMMARY.md`
</output>
