---
phase: 24-backend-pty-refactoring
plan: 02
type: execute
wave: 2
depends_on: ["24-01"]
files_modified:
  - src/wxcode/services/pty_session_manager.py
autonomous: true

must_haves:
  truths:
    - "PTYSession stores output buffer for reconnection replay"
    - "PTYSessionManager creates sessions with unique IDs"
    - "PTYSessionManager can retrieve session by ID or milestone_id"
    - "Expired sessions are cleaned up automatically"
    - "Session closes PTY when removed"
  artifacts:
    - path: "src/wxcode/services/pty_session_manager.py"
      provides: "PTYSession dataclass and PTYSessionManager for session persistence"
      min_lines: 100
      exports: ["PTYSession", "PTYSessionManager", "get_session_manager"]
  key_links:
    - from: "src/wxcode/services/pty_session_manager.py"
      to: "src/wxcode/services/bidirectional_pty.py"
      via: "import BidirectionalPTY"
      pattern: "from.*bidirectional_pty.*import.*BidirectionalPTY"
---

<objective>
Create PTYSessionManager for session persistence across WebSocket reconnection.

Purpose: Enable users to reconnect to an active Claude Code session after temporary disconnection. The session manager stores output buffer for replay and tracks session lifecycle.

Output: pty_session_manager.py with PTYSession dataclass and PTYSessionManager singleton.
</objective>

<execution_context>
@/Users/gilberto/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gilberto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/24-backend-pty-refactoring/24-RESEARCH.md
@src/wxcode/services/bidirectional_pty.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PTYSession dataclass</name>
  <files>src/wxcode/services/pty_session_manager.py</files>
  <action>
Create new file with PTYSession dataclass:

```python
"""
PTY Session Manager - Session persistence for WebSocket reconnection.

This module provides session management for PTY processes, enabling:
- Reconnection to active Claude Code sessions after WebSocket disconnect
- Output buffer replay for session continuity
- Automatic cleanup of expired sessions
"""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional
import uuid

from wxcode.services.bidirectional_pty import BidirectionalPTY


@dataclass
class PTYSession:
    """PTY session state for reconnection support."""

    session_id: str
    milestone_id: str
    pty: BidirectionalPTY
    created_at: datetime
    last_activity: datetime
    output_buffer: list[bytes] = field(default_factory=list)
    max_buffer_size: int = 64 * 1024  # 64KB default

    def add_to_buffer(self, data: bytes) -> None:
        """Add output to replay buffer with size limit."""
        self.output_buffer.append(data)
        self.last_activity = datetime.utcnow()
        # Trim buffer if exceeds max size (FIFO)
        total_size = sum(len(d) for d in self.output_buffer)
        while total_size > self.max_buffer_size and self.output_buffer:
            removed = self.output_buffer.pop(0)
            total_size -= len(removed)

    def get_replay_buffer(self) -> bytes:
        """Get full replay buffer as single bytes object."""
        return b"".join(self.output_buffer)

    def clear_buffer(self) -> None:
        """Clear the output buffer."""
        self.output_buffer.clear()
```

Key details:
- Use dataclass with field(default_factory=list) for mutable default
- Buffer size limit of 64KB (configurable)
- FIFO eviction when buffer full
- Track last_activity for timeout detection
  </action>
  <verify>
```bash
python -c "from wxcode.services.pty_session_manager import PTYSession; print('PTYSession OK')"
```
  </verify>
  <done>PTYSession dataclass with add_to_buffer, get_replay_buffer, clear_buffer methods</done>
</task>

<task type="auto">
  <name>Task 2: Create PTYSessionManager class</name>
  <files>src/wxcode/services/pty_session_manager.py</files>
  <action>
Add PTYSessionManager class to the same file:

```python
class PTYSessionManager:
    """Manages PTY sessions for reconnection support."""

    def __init__(self, session_timeout: int = 300):  # 5 minutes default
        self._sessions: dict[str, PTYSession] = {}
        self._milestone_to_session: dict[str, str] = {}
        self._session_timeout = session_timeout

    def create_session(self, milestone_id: str, pty: BidirectionalPTY) -> str:
        """Create new session for a milestone.

        Args:
            milestone_id: The milestone this session belongs to
            pty: The BidirectionalPTY instance

        Returns:
            session_id: Unique identifier for the session
        """
        session_id = str(uuid.uuid4())
        session = PTYSession(
            session_id=session_id,
            milestone_id=milestone_id,
            pty=pty,
            created_at=datetime.utcnow(),
            last_activity=datetime.utcnow(),
        )
        self._sessions[session_id] = session
        self._milestone_to_session[milestone_id] = session_id
        return session_id

    def get_session(self, session_id: str) -> Optional[PTYSession]:
        """Get session by ID, returns None if expired or not found."""
        session = self._sessions.get(session_id)
        if session and self._is_session_alive(session):
            return session
        return None

    def get_session_by_milestone(self, milestone_id: str) -> Optional[PTYSession]:
        """Get session by milestone ID."""
        session_id = self._milestone_to_session.get(milestone_id)
        if session_id:
            return self.get_session(session_id)
        return None

    def update_activity(self, session_id: str) -> None:
        """Update session's last activity timestamp."""
        session = self._sessions.get(session_id)
        if session:
            session.last_activity = datetime.utcnow()

    def _is_session_alive(self, session: PTYSession) -> bool:
        """Check if session is still valid."""
        # Check timeout
        elapsed = (datetime.utcnow() - session.last_activity).total_seconds()
        if elapsed > self._session_timeout:
            return False
        # Check if PTY process is still running
        if session.pty.returncode is not None:
            return False
        return True

    async def cleanup_expired(self) -> int:
        """Clean up expired sessions.

        Returns:
            Number of sessions cleaned up
        """
        expired = []
        for session_id, session in self._sessions.items():
            if not self._is_session_alive(session):
                expired.append(session_id)

        for session_id in expired:
            await self.close_session(session_id)

        return len(expired)

    async def close_session(self, session_id: str) -> None:
        """Close and remove session."""
        session = self._sessions.pop(session_id, None)
        if session:
            self._milestone_to_session.pop(session.milestone_id, None)
            await session.pty.close()

    def list_sessions(self) -> list[dict]:
        """List all active sessions with metadata."""
        sessions = []
        for session_id, session in self._sessions.items():
            if self._is_session_alive(session):
                sessions.append({
                    "session_id": session_id,
                    "milestone_id": session.milestone_id,
                    "created_at": session.created_at.isoformat(),
                    "last_activity": session.last_activity.isoformat(),
                    "buffer_size": sum(len(d) for d in session.output_buffer),
                })
        return sessions
```

Key details:
- Bi-directional lookup: session_id -> session, milestone_id -> session_id
- Default 5-minute timeout (configurable)
- Async cleanup and close methods
- list_sessions for debugging/monitoring
  </action>
  <verify>
```bash
python -c "
from wxcode.services.pty_session_manager import PTYSessionManager
mgr = PTYSessionManager(session_timeout=60)
print('PTYSessionManager OK')
print('Methods:', [m for m in dir(mgr) if not m.startswith('_')])
"
```
  </verify>
  <done>PTYSessionManager with create_session, get_session, get_session_by_milestone, close_session, cleanup_expired, list_sessions</done>
</task>

<task type="auto">
  <name>Task 3: Add singleton accessor and module exports</name>
  <files>src/wxcode/services/pty_session_manager.py</files>
  <action>
Add global singleton accessor at the end of the file:

```python
# Global session manager instance (singleton)
_session_manager: Optional[PTYSessionManager] = None


def get_session_manager(session_timeout: int = 300) -> PTYSessionManager:
    """Get or create global session manager.

    Args:
        session_timeout: Timeout in seconds (only used on first call)

    Returns:
        The global PTYSessionManager instance
    """
    global _session_manager
    if _session_manager is None:
        _session_manager = PTYSessionManager(session_timeout=session_timeout)
    return _session_manager


def reset_session_manager() -> None:
    """Reset global session manager (for testing)."""
    global _session_manager
    _session_manager = None
```

Also add __all__ at the top of the file after imports:

```python
__all__ = [
    "PTYSession",
    "PTYSessionManager",
    "get_session_manager",
    "reset_session_manager",
]
```

This singleton pattern allows:
- Global access from WebSocket handlers
- Consistent session state across requests
- Easy testing with reset_session_manager
  </action>
  <verify>
```bash
python -c "
from wxcode.services.pty_session_manager import (
    PTYSession,
    PTYSessionManager,
    get_session_manager,
    reset_session_manager,
)
mgr1 = get_session_manager()
mgr2 = get_session_manager()
assert mgr1 is mgr2, 'Singleton broken'
reset_session_manager()
mgr3 = get_session_manager()
assert mgr3 is not mgr1, 'Reset broken'
print('Singleton OK')
"
```
  </verify>
  <done>Global get_session_manager singleton with reset_session_manager for testing</done>
</task>

</tasks>

<verification>
1. PTYSession dataclass with buffer management
2. PTYSessionManager with full session lifecycle
3. Singleton accessor working correctly
4. All exports available: PTYSession, PTYSessionManager, get_session_manager, reset_session_manager
</verification>

<success_criteria>
- src/wxcode/services/pty_session_manager.py exists with ~150+ lines
- PTYSession has: add_to_buffer, get_replay_buffer, clear_buffer
- PTYSessionManager has: create_session, get_session, get_session_by_milestone, close_session, cleanup_expired, list_sessions
- get_session_manager returns singleton instance
- reset_session_manager resets singleton (for testing)
</success_criteria>

<output>
After completion, create `.planning/phases/24-backend-pty-refactoring/24-02-SUMMARY.md`
</output>
