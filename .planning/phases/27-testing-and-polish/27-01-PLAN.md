---
phase: 27-testing-and-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/test_terminal_handler.py
  - tests/test_pty_session_manager.py
autonomous: true

must_haves:
  truths:
    - "TerminalHandler routes input messages to PTY"
    - "TerminalHandler validates input before writing"
    - "TerminalHandler handles resize and signal messages"
    - "PTYSessionManager creates and retrieves sessions"
    - "PTYSession buffer enforces size limit"
    - "Session expiration works correctly"
  artifacts:
    - path: "tests/test_terminal_handler.py"
      provides: "Unit tests for TerminalHandler orchestration"
      min_lines: 150
    - path: "tests/test_pty_session_manager.py"
      provides: "Unit tests for session management"
      min_lines: 150
  key_links:
    - from: "tests/test_terminal_handler.py"
      to: "wxcode.services.terminal_handler"
      via: "imports TerminalHandler"
      pattern: "from wxcode.services.terminal_handler import"
    - from: "tests/test_pty_session_manager.py"
      to: "wxcode.services.pty_session_manager"
      via: "imports PTYSessionManager"
      pattern: "from wxcode.services.pty_session_manager import"
---

<objective>
Create unit tests for TerminalHandler and PTYSessionManager classes.

Purpose: Verify the WebSocket message routing and session persistence components work correctly in isolation before integration testing.

Output: Two test files covering handler orchestration and session management with 80%+ coverage on target modules.
</objective>

<execution_context>
@/Users/gilberto/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gilberto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-testing-and-polish/27-RESEARCH.md
@src/wxcode/services/terminal_handler.py
@src/wxcode/services/pty_session_manager.py
@tests/test_bidirectional_pty.py
@tests/test_input_validator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test_terminal_handler.py</name>
  <files>tests/test_terminal_handler.py</files>
  <action>
Create unit tests for TerminalHandler class following patterns from test_bidirectional_pty.py.

Test coverage must include:

1. **Message routing tests:**
   - Input message writes to PTY (valid input)
   - Input message with dangerous sequence sends error, not writes
   - Resize message calls PTY resize
   - Signal message (SIGINT) sends signal to PTY
   - Signal message (EOF) writes b'\x04' to PTY
   - Unknown message type is handled gracefully

2. **Output streaming tests:**
   - Output from PTY is sent via WebSocket
   - Output is added to session buffer
   - Multiple output chunks are sent sequentially

3. **Validation error handling:**
   - Invalid JSON sends error message
   - Validation error does not close WebSocket
   - Error message includes code "VALIDATION"

4. **Disconnect handling:**
   - WebSocketDisconnect does not raise
   - Session persists after disconnect

Use AsyncMock for PTY operations and MagicMock for WebSocket. Follow existing test patterns:
- Use @pytest.mark.asyncio for async tests
- Group tests in class TestTerminalHandler
- Use fixtures for mock objects
- Include docstrings explaining each test case
  </action>
  <verify>
Run: `pytest tests/test_terminal_handler.py -v`
All tests pass.
  </verify>
  <done>
At least 12 test cases covering input, resize, signal, output streaming, and disconnect handling.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create test_pty_session_manager.py</name>
  <files>tests/test_pty_session_manager.py</files>
  <action>
Create unit tests for PTYSessionManager and PTYSession classes.

Test coverage must include:

1. **PTYSession tests:**
   - add_to_buffer appends data correctly
   - get_replay_buffer returns all buffered data
   - Buffer enforces max_buffer_size limit (FIFO eviction)
   - clear_buffer empties the buffer
   - last_activity is updated on add_to_buffer

2. **PTYSessionManager tests:**
   - create_session returns unique session_id
   - create_session registers milestone_id mapping
   - get_session returns session by ID
   - get_session returns None for invalid ID
   - get_session_by_milestone returns correct session
   - get_session_by_milestone returns None for invalid milestone
   - update_activity updates last_activity timestamp
   - close_session removes session and closes PTY
   - list_sessions returns only alive sessions

3. **Session expiration tests:**
   - _is_session_alive returns False for timed out session
   - _is_session_alive returns False when PTY process exited
   - cleanup_expired removes expired sessions
   - get_session returns None for expired session

4. **Singleton tests:**
   - get_session_manager returns same instance
   - reset_session_manager creates new instance

Use mock BidirectionalPTY with configurable returncode. Use datetime mocking for timeout tests.
  </action>
  <verify>
Run: `pytest tests/test_pty_session_manager.py -v`
All tests pass.
  </verify>
  <done>
At least 15 test cases covering session creation, retrieval, expiration, and singleton behavior.
  </done>
</task>

</tasks>

<verification>
Run full test suite to ensure no regressions:
```bash
pytest tests/test_terminal_handler.py tests/test_pty_session_manager.py -v
pytest tests/ -k "terminal or pty or input_validator" --tb=short
```

All tests pass, no import errors.
</verification>

<success_criteria>
- test_terminal_handler.py has 12+ test cases
- test_pty_session_manager.py has 15+ test cases
- All tests pass
- Tests follow existing project patterns (pytest, pytest-asyncio)
- No new dependencies added
</success_criteria>

<output>
After completion, create `.planning/phases/27-testing-and-polish/27-01-SUMMARY.md`
</output>
