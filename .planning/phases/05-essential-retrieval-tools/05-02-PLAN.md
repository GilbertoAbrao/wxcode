---
phase: 05-essential-retrieval-tools
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/wxcode/mcp/tools/controls.py
  - src/wxcode/mcp/tools/__init__.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can get control hierarchy with properties and events for any page"
    - "User can extract data bindings showing control-to-table mappings"
  artifacts:
    - path: "src/wxcode/mcp/tools/controls.py"
      provides: "get_controls, get_data_bindings tools"
      exports: ["get_controls", "get_data_bindings"]
      min_lines: 100
  key_links:
    - from: "src/wxcode/mcp/tools/__init__.py"
      to: "src/wxcode/mcp/tools/controls.py"
      via: "import statement"
      pattern: "from wxcode.mcp.tools import controls"
    - from: "src/wxcode/mcp/tools/controls.py"
      to: "Control model"
      via: "Beanie query"
      pattern: "Control\\.find"
---

<objective>
Implement UI/control query tools for MCP server.

Purpose: Enable users to understand page structure and data bindings. This is critical for conversion because WinDev pages have complex control hierarchies with events, properties, and database bindings that must be mapped to modern UI frameworks.

Output:
- `src/wxcode/mcp/tools/controls.py` with `get_controls` and `get_data_bindings` tools
- Updated `__init__.py` to register controls module
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Research patterns for control queries
@.planning/phases/05-essential-retrieval-tools/05-RESEARCH.md

# Control model structure
@src/wxcode/models/control.py
@src/wxcode/models/control_type.py

# Existing query patterns
@src/wxcode/services/gsd_context_collector.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement control tools</name>
  <files>src/wxcode/mcp/tools/controls.py</files>
  <action>
Create `src/wxcode/mcp/tools/controls.py` with two tools.

**Tool 1: `get_controls`** (UI-01)

```python
@mcp.tool
async def get_controls(
    ctx: Context,
    element_name: str,
    project_name: str | None = None,
    include_events: bool = True,
    include_properties: bool = True
) -> dict:
    """
    Get control hierarchy for a WinDev page element.

    Returns all controls (buttons, inputs, cells, etc.) with their
    properties, events, and parent-child relationships.

    Args:
        element_name: Name of the page element (e.g., PAGE_Login)
        project_name: Optional project name to scope the search
        include_events: Include event handlers (OnClick, etc.) - default True
        include_properties: Include control properties (width, height, etc.) - default True

    Returns:
        Control hierarchy sorted by full_path (depth-first tree order)
    """
```

**Query pattern from gsd_context_collector.py line 251:**
```python
# First find the element
element = await _find_element(ctx, element_name, project_name)

# Query controls sorted by full_path (encodes hierarchy)
controls = await Control.find({"element_id": element.id}).sort("+full_path").to_list()

# Get type definitions for readable type names
type_codes = list(set(c.type_code for c in controls if c.type_code))
if type_codes:
    type_defs = await ControlTypeDefinition.find({"type_code": {"$in": type_codes}}).to_list()
    type_map = {td.type_code: td.type_name or td.inferred_name for td in type_defs}
else:
    type_map = {}
```

**Return structure:**
```python
{
    "error": False,
    "element": element_name,
    "total_controls": len(controls),
    "controls": [
        {
            "name": ctrl.name,
            "type_code": ctrl.type_code,
            "type_name": type_map.get(ctrl.type_code, "Unknown"),
            "full_path": ctrl.full_path,
            "depth": ctrl.depth,
            "has_code": ctrl.has_code,
            "is_container": ctrl.is_container,
            "is_bound": bool(ctrl.data_binding),
            "properties": ctrl.properties if include_properties else None,
            "events": [
                {"event_name": e.event_name, "type_code": e.type_code, "has_code": bool(e.code)}
                for e in (ctrl.events or [])
            ] if include_events else None
        }
        for ctrl in controls
    ]
}
```

**Tool 2: `get_data_bindings`** (UI-02)

```python
@mcp.tool
async def get_data_bindings(
    ctx: Context,
    element_name: str,
    project_name: str | None = None
) -> dict:
    """
    Get data bindings for a WinDev page element.

    Returns the mapping between UI controls and database table fields.
    Essential for understanding how the page reads/writes data.

    Args:
        element_name: Name of the page element (e.g., PAGE_Login)
        project_name: Optional project name to scope the search

    Returns:
        List of bindings showing control -> table.field mappings
    """
```

**Query pattern:**
```python
# Find controls with data bindings
controls = await Control.find({
    "element_id": element.id,
    "data_binding": {"$ne": None}
}).to_list()

# Extract bindings and collect referenced tables
bindings = []
tables = set()
for ctrl in controls:
    if ctrl.data_binding:
        binding = {
            "control_name": ctrl.name,
            "control_path": ctrl.full_path,
            "binding_type": ctrl.data_binding.binding_type.value if hasattr(ctrl.data_binding, 'binding_type') else "simple",
            "table_name": ctrl.data_binding.table_name,
            "field_name": ctrl.data_binding.field_name,
        }
        bindings.append(binding)
        if ctrl.data_binding.table_name:
            tables.add(ctrl.data_binding.table_name)
```

**Return structure:**
```python
{
    "error": False,
    "element": element_name,
    "total_bindings": len(bindings),
    "bindings": bindings,
    "tables_referenced": sorted(list(tables))
}
```

**Important implementation notes:**
- Import `_find_element` from elements.py or duplicate the helper
- Use same error handling pattern (return error dicts)
- Handle case where element has no controls gracefully
- Handle case where control.data_binding is None (check before accessing)
  </action>
  <verify>
```bash
cd /Users/gilberto/projetos/wxk/wxcode
python -c "from wxcode.mcp.tools.controls import get_controls, get_data_bindings; print('Control tools OK')"
python -m py_compile src/wxcode/mcp/tools/controls.py && echo "Syntax OK"
```
  </verify>
  <done>
- controls.py defines get_controls and get_data_bindings tools
- Both tools have @mcp.tool decorator
- Type hints and docstrings complete
- Error handling returns dicts
- Control hierarchy sorted by full_path
  </done>
</task>

<task type="auto">
  <name>Task 2: Register controls module in tools package</name>
  <files>src/wxcode/mcp/tools/__init__.py</files>
  <action>
Update `src/wxcode/mcp/tools/__init__.py` to import the controls module.

**Add after existing imports:**
```python
from wxcode.mcp.tools import controls  # noqa: F401
```

**Update __all__:**
```python
__all__ = ["elements", "controls"]
```

Note: Plan 05-01 runs in parallel and creates __init__.py. If it doesn't exist yet when this task runs, create it with both imports.
  </action>
  <verify>
```bash
cd /Users/gilberto/projetos/wxk/wxcode
python -c "from wxcode.mcp.tools import controls; print('Controls module registered')"
python -c "from wxcode.mcp import tools; print('Tools package OK')"
```
  </verify>
  <done>
- __init__.py imports controls module
- __all__ includes "controls"
- No import errors when loading tools package
  </done>
</task>

</tasks>

<verification>
Both control tools are implemented and registered:

1. **get_controls** - Returns control hierarchy with properties and events
2. **get_data_bindings** - Returns control-to-table data mappings

Run verification:
```bash
cd /Users/gilberto/projetos/wxk/wxcode

# 1. Tools import correctly
python -c "
from wxcode.mcp.tools.controls import get_controls, get_data_bindings
print('get_controls:', get_controls.__doc__[:50] + '...')
print('get_data_bindings:', get_data_bindings.__doc__[:50] + '...')
"

# 2. No syntax errors
python -m py_compile src/wxcode/mcp/tools/controls.py

# 3. Server still starts with new tools
timeout 3 python -m wxcode.mcp.server 2>&1 | grep -E "(Starting|Error)" || echo "OK"
```
</verification>

<success_criteria>
- [ ] `src/wxcode/mcp/tools/controls.py` exists with 2 tools
- [ ] get_controls returns hierarchy sorted by full_path
- [ ] get_controls includes type_name from ControlTypeDefinition
- [ ] get_data_bindings extracts table references
- [ ] Both tools follow error handling pattern
- [ ] Tools registered in __init__.py
- [ ] Server starts without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-essential-retrieval-tools/05-02-SUMMARY.md`
</output>
