---
phase: 05-essential-retrieval-tools
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/wxcode/mcp/tools/procedures.py
  - src/wxcode/mcp/tools/schema.py
  - src/wxcode/mcp/tools/__init__.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can list procedures for any element with optional code"
    - "User can retrieve a specific procedure by name with full details"
    - "User can get complete database schema for a project"
    - "User can get detailed table definition with columns and indexes"
  artifacts:
    - path: "src/wxcode/mcp/tools/procedures.py"
      provides: "get_procedures, get_procedure tools"
      exports: ["get_procedures", "get_procedure"]
      min_lines: 80
    - path: "src/wxcode/mcp/tools/schema.py"
      provides: "get_schema, get_table tools"
      exports: ["get_schema", "get_table"]
      min_lines: 80
  key_links:
    - from: "src/wxcode/mcp/tools/__init__.py"
      to: "procedures.py and schema.py"
      via: "import statements"
      pattern: "from wxcode.mcp.tools import (procedures|schema)"
    - from: "procedures.py"
      to: "Procedure model"
      via: "Beanie query"
      pattern: "Procedure\\.find"
    - from: "schema.py"
      to: "DatabaseSchema model"
      via: "Beanie query"
      pattern: "DatabaseSchema\\.find"
---

<objective>
Implement procedure and schema query tools for MCP server.

Purpose: Complete the read-only tool suite by adding procedure inspection (for understanding business logic) and schema access (for understanding data structures). These are essential for planning conversions.

Output:
- `src/wxcode/mcp/tools/procedures.py` with `get_procedures` and `get_procedure` tools
- `src/wxcode/mcp/tools/schema.py` with `get_schema` and `get_table` tools
- Updated `__init__.py` to register all modules
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Research patterns
@.planning/phases/05-essential-retrieval-tools/05-RESEARCH.md

# Prior plan created tools foundation
@.planning/phases/05-essential-retrieval-tools/05-01-PLAN.md

# Models for procedures and schema
@src/wxcode/models/procedure.py
@src/wxcode/models/schema.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement procedure tools</name>
  <files>src/wxcode/mcp/tools/procedures.py</files>
  <action>
Create `src/wxcode/mcp/tools/procedures.py` with two tools.

**Tool 1: `get_procedures`** (PROC-01)

```python
@mcp.tool
async def get_procedures(
    ctx: Context,
    element_name: str,
    project_name: str | None = None,
    include_code: bool = False
) -> dict:
    """
    List all procedures defined in a WinDev element.

    Returns procedure names, signatures, and optionally full code.
    Use this to understand what functions/methods an element provides.

    Args:
        element_name: Name of the element (e.g., ServerProcedures, PAGE_Login)
        project_name: Optional project name to scope the search
        include_code: Include full procedure code (default: False for performance)

    Returns:
        List of procedures with signatures and metadata
    """
```

**Query pattern:**
```python
# Find element first (reuse helper from elements.py)
element, error = await _find_element(ctx, element_name, project_name)
if error:
    return {"error": True, "code": "NOT_FOUND", "message": error}

# Query procedures for this element
procedures = await Procedure.find({"element_id": element.id}).sort("+name").to_list()
```

**Return structure:**
```python
{
    "error": False,
    "element": element_name,
    "total_procedures": len(procedures),
    "procedures": [
        {
            "name": proc.name,
            "signature": proc.signature,
            "is_public": proc.is_public,
            "is_local": proc.is_local,
            "code_lines": len(proc.code.split('\n')) if proc.code else 0,
            "code": proc.code if include_code else None,
            "parameters": [
                {"name": p.name, "type": p.type, "is_optional": p.is_optional}
                for p in (proc.parameters or [])
            ],
            "return_type": proc.return_type
        }
        for proc in procedures
    ]
}
```

**Tool 2: `get_procedure`** (PROC-02)

```python
@mcp.tool
async def get_procedure(
    ctx: Context,
    procedure_name: str,
    element_name: str | None = None,
    project_name: str | None = None
) -> dict:
    """
    Get a specific procedure by name with full details.

    Returns the complete procedure definition including code and dependencies.
    If procedure exists in multiple elements, use element_name to specify.

    Args:
        procedure_name: Name of the procedure (e.g., ValidaCPF)
        element_name: Optional element to scope the search
        project_name: Optional project name

    Returns:
        Complete procedure definition with code and dependencies
    """
```

**Query pattern:**
```python
query = {"name": procedure_name}

# If element_name provided, scope to that element
if element_name:
    element, error = await _find_element(ctx, element_name, project_name)
    if error:
        return {"error": True, "code": "NOT_FOUND", "message": error}
    query["element_id"] = element.id

procedures = await Procedure.find(query).to_list()

if not procedures:
    return {"error": True, "code": "NOT_FOUND", "message": f"Procedure '{procedure_name}' not found"}

if len(procedures) > 1 and not element_name:
    # Found in multiple elements
    elements_with_proc = [p.element_name for p in procedures]  # Need to fetch element names
    return {
        "error": True,
        "code": "AMBIGUOUS",
        "message": f"Procedure '{procedure_name}' found in multiple elements",
        "suggestion": f"Use element_name to specify. Found in: {elements_with_proc}"
    }

proc = procedures[0]
```

**Return structure:**
```python
{
    "error": False,
    "data": {
        "name": proc.name,
        "element": element_name or "unknown",  # May need to fetch
        "signature": proc.signature,
        "parameters": [...],
        "return_type": proc.return_type,
        "code": proc.code,
        "code_lines": len(proc.code.split('\n')) if proc.code else 0,
        "is_public": proc.is_public,
        "is_local": proc.is_local,
        "dependencies": {
            "calls_procedures": proc.dependencies.calls_procedures if proc.dependencies else [],
            "uses_files": proc.dependencies.uses_files if proc.dependencies else [],
            "uses_apis": proc.dependencies.uses_apis if proc.dependencies else [],
            "uses_queries": proc.dependencies.uses_queries if proc.dependencies else []
        } if hasattr(proc, 'dependencies') and proc.dependencies else None
    }
}
```

**Implementation notes:**
- Import helper functions from elements.py: `from wxcode.mcp.tools.elements import _find_element`
- If Procedure model doesn't have element_name, need to fetch Element to get name
- Handle case where proc.dependencies may not exist
  </action>
  <verify>
```bash
cd /Users/gilberto/projetos/wxk/wxcode
python -c "from wxcode.mcp.tools.procedures import get_procedures, get_procedure; print('Procedure tools OK')"
python -m py_compile src/wxcode/mcp/tools/procedures.py && echo "Syntax OK"
```
  </verify>
  <done>
- procedures.py defines get_procedures and get_procedure tools
- Both tools have @mcp.tool decorator
- get_procedures supports include_code flag
- get_procedure handles ambiguous results
- Error handling returns dicts
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement schema tools</name>
  <files>src/wxcode/mcp/tools/schema.py</files>
  <action>
Create `src/wxcode/mcp/tools/schema.py` with two tools.

**Tool 1: `get_schema`** (SCHEMA-01)

```python
@mcp.tool
async def get_schema(
    ctx: Context,
    project_name: str
) -> dict:
    """
    Get the complete database schema for a WinDev project.

    Returns all tables, connections, and schema metadata.
    Use this to understand the data model before conversion.

    Args:
        project_name: Name of the project (required)

    Returns:
        Complete schema including tables and connections
    """
```

**Query pattern:**
```python
# Find project
project = await Project.find_one(Project.name == project_name)
if not project:
    return {"error": True, "code": "NOT_FOUND", "message": f"Project '{project_name}' not found"}

# Find schema for project
schema = await DatabaseSchema.find_one({"project_id": project.id})
if not schema:
    return {
        "error": True,
        "code": "NOT_FOUND",
        "message": f"No schema found for project '{project_name}'",
        "suggestion": "Run 'wxcode parse-schema' to import the database schema"
    }
```

**Return structure:**
```python
{
    "error": False,
    "project": project_name,
    "version": schema.version,
    "connections": [
        {
            "name": conn.name,
            "database_type": conn.database_type,
            "source": conn.source,
            "database": conn.database
        }
        for conn in (schema.connections or [])
    ],
    "total_tables": len(schema.tables) if schema.tables else 0,
    "tables": [
        {
            "name": table.name,
            "physical_name": table.physical_name,
            "column_count": len(table.columns) if table.columns else 0,
            "primary_key": table.primary_key or []
        }
        for table in (schema.tables or [])
    ]
}
```

**Tool 2: `get_table`** (SCHEMA-02)

```python
@mcp.tool
async def get_table(
    ctx: Context,
    table_name: str,
    project_name: str
) -> dict:
    """
    Get detailed definition for a specific database table.

    Returns all columns, types, constraints, and indexes.
    Use this when you need full table structure for conversion.

    Args:
        table_name: Name of the table (e.g., USUARIO, CLIENTE)
        project_name: Name of the project (required)

    Returns:
        Complete table definition with columns and indexes
    """
```

**Query pattern:**
```python
# Find project and schema
project = await Project.find_one(Project.name == project_name)
if not project:
    return {"error": True, "code": "NOT_FOUND", "message": f"Project '{project_name}' not found"}

schema = await DatabaseSchema.find_one({"project_id": project.id})
if not schema:
    return {"error": True, "code": "NOT_FOUND", "message": f"No schema found for project '{project_name}'"}

# Find table in schema
table = next((t for t in (schema.tables or []) if t.name.upper() == table_name.upper()), None)
if not table:
    available = [t.name for t in (schema.tables or [])[:10]]
    return {
        "error": True,
        "code": "NOT_FOUND",
        "message": f"Table '{table_name}' not found in schema",
        "suggestion": f"Available tables: {available}"
    }
```

**Return structure:**
```python
{
    "error": False,
    "table": {
        "name": table.name,
        "physical_name": table.physical_name,
        "connection_name": table.connection_name,
        "columns": [
            {
                "name": col.name,
                "windev_type": col.windev_type,
                "python_type": col.python_type,
                "size": col.size,
                "is_primary_key": col.is_primary_key,
                "is_auto_increment": col.is_auto_increment,
                "nullable": col.nullable,
                "default_value": col.default_value
            }
            for col in (table.columns or [])
        ],
        "indexes": [
            {
                "name": idx.name,
                "columns": idx.columns,
                "is_unique": idx.is_unique,
                "is_primary": idx.is_primary
            }
            for idx in (table.indexes or [])
        ] if hasattr(table, 'indexes') and table.indexes else []
    }
}
```

**Implementation notes:**
- DatabaseSchema stores tables as embedded documents, not separate collection
- Table lookup is case-insensitive (use .upper())
- May need to check actual model structure for exact field names
  </action>
  <verify>
```bash
cd /Users/gilberto/projetos/wxk/wxcode
python -c "from wxcode.mcp.tools.schema import get_schema, get_table; print('Schema tools OK')"
python -m py_compile src/wxcode/mcp/tools/schema.py && echo "Syntax OK"
```
  </verify>
  <done>
- schema.py defines get_schema and get_table tools
- Both tools have @mcp.tool decorator
- get_schema returns overview with table summaries
- get_table returns detailed column/index info
- Case-insensitive table lookup
- Error handling returns dicts with suggestions
  </done>
</task>

<task type="auto">
  <name>Task 3: Finalize tools registration and verify all 9 tools</name>
  <files>src/wxcode/mcp/tools/__init__.py</files>
  <action>
Update `src/wxcode/mcp/tools/__init__.py` to import all four modules.

**Final __init__.py:**
```python
"""MCP Tools for wxcode Knowledge Base.

All tools are registered on import by using the @mcp.tool decorator.
Import this module to register all tools with the MCP server.

Tools available:
- elements: get_element, list_elements, search_code
- controls: get_controls, get_data_bindings
- procedures: get_procedures, get_procedure
- schema: get_schema, get_table
"""

# Import all tool modules to register them with @mcp.tool
from wxcode.mcp.tools import elements  # noqa: F401
from wxcode.mcp.tools import controls  # noqa: F401
from wxcode.mcp.tools import procedures  # noqa: F401
from wxcode.mcp.tools import schema  # noqa: F401

__all__ = ["elements", "controls", "procedures", "schema"]
```

**Verify all 9 tools are registered:**
1. get_element
2. list_elements
3. search_code
4. get_controls
5. get_data_bindings
6. get_procedures
7. get_procedure
8. get_schema
9. get_table
  </action>
  <verify>
```bash
cd /Users/gilberto/projetos/wxk/wxcode

# Verify all modules import
python -c "
from wxcode.mcp.tools import elements, controls, procedures, schema
print('All modules imported')
"

# Verify all 9 tools exist
python -c "
from wxcode.mcp.tools.elements import get_element, list_elements, search_code
from wxcode.mcp.tools.controls import get_controls, get_data_bindings
from wxcode.mcp.tools.procedures import get_procedures, get_procedure
from wxcode.mcp.tools.schema import get_schema, get_table

tools = [
    get_element, list_elements, search_code,
    get_controls, get_data_bindings,
    get_procedures, get_procedure,
    get_schema, get_table
]
print(f'All {len(tools)} tools defined')
for t in tools:
    print(f'  - {t.__name__}')
"

# Verify server starts
timeout 3 python -m wxcode.mcp.server 2>&1 | grep -E "(Starting|Error)" || echo "Server OK"
```
  </verify>
  <done>
- __init__.py imports all 4 tool modules
- All 9 tools are accessible
- Server starts without import errors
- Tools are registered with FastMCP
  </done>
</task>

</tasks>

<verification>
All 9 tools are implemented and registered:

**Elements (3):** get_element, list_elements, search_code
**Controls (2):** get_controls, get_data_bindings
**Procedures (2):** get_procedures, get_procedure
**Schema (2):** get_schema, get_table

Run full Phase 5 verification:
```bash
cd /Users/gilberto/projetos/wxk/wxcode

# 1. All tools import
python -c "
from wxcode.mcp.tools.elements import get_element, list_elements, search_code
from wxcode.mcp.tools.controls import get_controls, get_data_bindings
from wxcode.mcp.tools.procedures import get_procedures, get_procedure
from wxcode.mcp.tools.schema import get_schema, get_table
print('All 9 tools imported successfully')
"

# 2. Server starts with all tools
timeout 5 python -m wxcode.mcp.server 2>&1 | grep -v "^$" | head -10

# 3. No syntax errors
python -m py_compile src/wxcode/mcp/tools/*.py && echo "All tools syntax OK"

# 4. Check tool count (should be 9)
python -c "
import inspect
from wxcode.mcp import tools
from wxcode.mcp.tools import elements, controls, procedures, schema

count = 0
for mod in [elements, controls, procedures, schema]:
    for name, obj in inspect.getmembers(mod):
        if hasattr(obj, '__wrapped__'):  # FastMCP decorated
            count += 1
            print(f'{name}')
print(f'Total: {count} tools')
"
```
</verification>

<success_criteria>
- [ ] `src/wxcode/mcp/tools/procedures.py` exists with 2 tools
- [ ] `src/wxcode/mcp/tools/schema.py` exists with 2 tools
- [ ] `__init__.py` imports all 4 modules
- [ ] All 9 tools have @mcp.tool decorator
- [ ] All tools have proper docstrings (used by Claude for selection)
- [ ] Server starts without errors
- [ ] Tools follow consistent error handling pattern
</success_criteria>

<output>
After completion, create `.planning/phases/05-essential-retrieval-tools/05-03-SUMMARY.md`
</output>
