---
phase: 17-gsd-project-integration
plan: 03
type: execute
wave: 3
depends_on: ["17-02"]
files_modified:
  - frontend/src/hooks/useOutputProjects.ts
  - frontend/src/components/output-project/InitializeButton.tsx
  - frontend/src/components/output-project/InitializeProgress.tsx
  - frontend/src/components/output-project/index.ts
  - frontend/src/app/kb/[id]/projects/[projectId]/page.tsx
autonomous: false

must_haves:
  truths:
    - "User can click Initialize button on created output project"
    - "Initialize button shows loading state during initialization"
    - "Streaming output visible in real-time during GSD execution"
    - "Success message shown when initialization completes"
    - "Error message shown if initialization fails"
    - "Project page reflects new status after initialization"
  artifacts:
    - path: "frontend/src/hooks/useOutputProjects.ts"
      provides: "useInitializeProject hook"
      contains: "useInitializeProject"
    - path: "frontend/src/components/output-project/InitializeButton.tsx"
      provides: "Button component for triggering initialization"
      exports: ["InitializeButton"]
    - path: "frontend/src/components/output-project/InitializeProgress.tsx"
      provides: "Streaming output display component"
      exports: ["InitializeProgress"]
  key_links:
    - from: "InitializeButton.tsx"
      to: "useInitializeProject hook"
      via: "hook import and usage"
      pattern: "useInitializeProject"
    - from: "useInitializeProject"
      to: "WebSocket API"
      via: "WebSocket connection"
      pattern: "new WebSocket.*initialize"
---

<objective>
Add frontend components for initializing output projects with streaming GSD output.

Purpose: Enable users to trigger and monitor the GSD workflow initialization with real-time feedback.

Output: React hook for WebSocket connection, InitializeButton component, and InitializeProgress component for streaming output.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/17-gsd-project-integration/17-RESEARCH.md
@.planning/phases/17-gsd-project-integration/17-02-SUMMARY.md

# Relevant source files
@frontend/src/hooks/useOutputProjects.ts
@frontend/src/app/kb/[id]/projects/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useInitializeProject hook</name>
  <files>frontend/src/hooks/useOutputProjects.ts</files>
  <action>
Add `useInitializeProject` hook to useOutputProjects.ts:

1. Define StreamMessage interface:
   ```typescript
   interface StreamMessage {
     type: "info" | "log" | "error" | "complete";
     message?: string;
     content?: string;
     level?: string;
     timestamp?: string;
   }
   ```

2. Create hook with state:
   ```typescript
   export function useInitializeProject(projectId: string) {
     const [isInitializing, setIsInitializing] = useState(false);
     const [messages, setMessages] = useState<StreamMessage[]>([]);
     const [error, setError] = useState<string | null>(null);
     const [isComplete, setIsComplete] = useState(false);
     const wsRef = useRef<WebSocket | null>(null);
     const queryClient = useQueryClient();
   ```

3. Implement `initialize` function:
   - Create WebSocket to `/api/output-projects/${projectId}/initialize`
   - Use proper protocol detection: `ws://` or `wss://` based on location.protocol
   - On message: parse JSON, append to messages, check for complete/error
   - On complete: set isComplete, invalidate output-projects query
   - On error: set error state
   - On close: cleanup ref

4. Implement `cancel` function:
   - Close WebSocket if open
   - Set isInitializing to false

5. Cleanup effect:
   - Close WebSocket on unmount

6. Return:
   ```typescript
   return {
     initialize,
     cancel,
     isInitializing,
     messages,
     error,
     isComplete,
   };
   ```

WebSocket URL construction:
```typescript
const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
const ws = new WebSocket(
  `${protocol}//${window.location.host}/api/output-projects/${projectId}/initialize`
);
```
  </action>
  <verify>
Build frontend:
```bash
cd /Users/gilberto/projetos/wxk/wxcode/frontend && npm run build
```
  </verify>
  <done>
useInitializeProject hook added to useOutputProjects.ts with WebSocket state management.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create InitializeButton and InitializeProgress components</name>
  <files>
frontend/src/components/output-project/InitializeButton.tsx
frontend/src/components/output-project/InitializeProgress.tsx
frontend/src/components/output-project/index.ts
  </files>
  <action>
Create output-project components directory and files:

**InitializeButton.tsx:**
```typescript
"use client";

import { Button } from "@/components/ui/button";
import { Play, Loader2, CheckCircle, XCircle, RotateCcw } from "lucide-react";
import { cn } from "@/lib/utils";

interface InitializeButtonProps {
  status: string;
  isInitializing: boolean;
  isComplete: boolean;
  error: string | null;
  onInitialize: () => void;
  className?: string;
}

export function InitializeButton({
  status,
  isInitializing,
  isComplete,
  error,
  onInitialize,
  className,
}: InitializeButtonProps) {
  // Already active
  if (status === "active") {
    return (
      <Button variant="ghost" disabled className={cn("gap-2", className)}>
        <CheckCircle className="h-4 w-4 text-green-500" />
        Initialized
      </Button>
    );
  }

  // Error state - allow retry
  if (error) {
    return (
      <Button
        variant="outline"
        onClick={onInitialize}
        className={cn("gap-2", className)}
      >
        <RotateCcw className="h-4 w-4" />
        Retry
      </Button>
    );
  }

  // Initializing
  if (isInitializing) {
    return (
      <Button disabled className={cn("gap-2", className)}>
        <Loader2 className="h-4 w-4 animate-spin" />
        Initializing...
      </Button>
    );
  }

  // Ready to initialize (status === "created" or "initialized")
  return (
    <Button onClick={onInitialize} className={cn("gap-2", className)}>
      <Play className="h-4 w-4" />
      Initialize Project
    </Button>
  );
}
```

**InitializeProgress.tsx:**
```typescript
"use client";

import { useRef, useEffect } from "react";
import { CheckCircle, AlertCircle, Terminal } from "lucide-react";
import { cn } from "@/lib/utils";

interface StreamMessage {
  type: string;
  message?: string;
  content?: string;
  level?: string;
}

interface InitializeProgressProps {
  messages: StreamMessage[];
  isComplete: boolean;
  error: string | null;
  className?: string;
}

export function InitializeProgress({
  messages,
  isComplete,
  error,
  className,
}: InitializeProgressProps) {
  const scrollRef = useRef<HTMLDivElement>(null);

  // Auto-scroll to bottom
  useEffect(() => {
    if (scrollRef.current) {
      scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
    }
  }, [messages]);

  if (messages.length === 0 && !isComplete && !error) {
    return null;
  }

  return (
    <div className={cn("rounded-lg border bg-muted/50", className)}>
      {/* Header */}
      <div className="flex items-center gap-2 border-b px-4 py-2">
        <Terminal className="h-4 w-4" />
        <span className="text-sm font-medium">Initialization Output</span>
        {isComplete && (
          <CheckCircle className="ml-auto h-4 w-4 text-green-500" />
        )}
        {error && <AlertCircle className="ml-auto h-4 w-4 text-red-500" />}
      </div>

      {/* Output */}
      <div
        ref={scrollRef}
        className="h-64 overflow-y-auto p-4 font-mono text-xs"
      >
        {messages.map((msg, i) => (
          <div
            key={i}
            className={cn(
              "py-0.5",
              msg.type === "error" && "text-red-500",
              msg.type === "complete" && "text-green-500",
              msg.level === "error" && "text-red-400"
            )}
          >
            {msg.message || msg.content || JSON.stringify(msg)}
          </div>
        ))}
        {error && <div className="py-1 text-red-500">Error: {error}</div>}
        {isComplete && (
          <div className="py-1 text-green-500">
            Project initialized successfully!
          </div>
        )}
      </div>
    </div>
  );
}
```

**index.ts:**
```typescript
export { InitializeButton } from "./InitializeButton";
export { InitializeProgress } from "./InitializeProgress";
```
  </action>
  <verify>
Build frontend:
```bash
cd /Users/gilberto/projetos/wxk/wxcode/frontend && npm run build
```
  </verify>
  <done>
InitializeButton and InitializeProgress components created with proper TypeScript types.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate into project page</name>
  <files>frontend/src/app/kb/[id]/projects/[projectId]/page.tsx</files>
  <action>
Create or update the individual project page to use initialization components:

1. If page doesn't exist, create it at `frontend/src/app/kb/[id]/projects/[projectId]/page.tsx`

2. Structure:
   ```typescript
   "use client";

   import { useParams, useRouter } from "next/navigation";
   import { useOutputProject, useInitializeProject } from "@/hooks/useOutputProjects";
   import { InitializeButton, InitializeProgress } from "@/components/output-project";
   import { Loader2, ArrowLeft } from "lucide-react";
   import { Button } from "@/components/ui/button";
   import Link from "next/link";

   export default function OutputProjectPage() {
     const params = useParams();
     const kbId = params.id as string;
     const projectId = params.projectId as string;

     const { data: project, isLoading } = useOutputProject(projectId);
     const {
       initialize,
       isInitializing,
       messages,
       error,
       isComplete,
     } = useInitializeProject(projectId);

     if (isLoading) {
       return <div className="flex justify-center p-8"><Loader2 className="animate-spin" /></div>;
     }

     if (!project) {
       return <div className="p-8">Project not found</div>;
     }

     return (
       <div className="container mx-auto py-8">
         {/* Back link */}
         <Link href={`/kb/${kbId}/projects`}>
           <Button variant="ghost" size="sm" className="mb-4 gap-2">
             <ArrowLeft className="h-4 w-4" />
             Back to Projects
           </Button>
         </Link>

         {/* Header */}
         <div className="mb-6 flex items-center justify-between">
           <div>
             <h1 className="text-2xl font-bold">{project.name}</h1>
             <p className="text-muted-foreground">
               Stack: {project.stack_id} | Status: {project.status}
             </p>
           </div>
           <InitializeButton
             status={project.status}
             isInitializing={isInitializing}
             isComplete={isComplete}
             error={error}
             onInitialize={initialize}
           />
         </div>

         {/* Progress (only shown during/after initialization) */}
         {(isInitializing || messages.length > 0) && (
           <InitializeProgress
             messages={messages}
             isComplete={isComplete}
             error={error}
             className="mb-6"
           />
         )}

         {/* Project info */}
         <div className="rounded-lg border p-6">
           <h2 className="mb-4 text-lg font-semibold">Project Details</h2>
           <dl className="grid grid-cols-2 gap-4">
             <div>
               <dt className="text-sm text-muted-foreground">Knowledge Base</dt>
               <dd>{project.kb_name}</dd>
             </div>
             <div>
               <dt className="text-sm text-muted-foreground">Stack</dt>
               <dd>{project.stack_id}</dd>
             </div>
             <div>
               <dt className="text-sm text-muted-foreground">Workspace</dt>
               <dd className="font-mono text-sm">{project.workspace_path}</dd>
             </div>
             <div>
               <dt className="text-sm text-muted-foreground">Created</dt>
               <dd>{new Date(project.created_at).toLocaleString()}</dd>
             </div>
           </dl>
         </div>
       </div>
     );
   }
   ```

3. Ensure useOutputProject hook exists in useOutputProjects.ts (single project fetch)

4. If useOutputProject doesn't exist, add it:
   ```typescript
   export function useOutputProject(id: string) {
     return useQuery({
       queryKey: ["output-project", id],
       queryFn: () => api.get<OutputProjectResponse>(`/output-projects/${id}`).then(r => r.data),
       enabled: !!id,
     });
   }
   ```
  </action>
  <verify>
Build and check for TypeScript errors:
```bash
cd /Users/gilberto/projetos/wxk/wxcode/frontend && npm run build
```
  </verify>
  <done>
Project detail page created with InitializeButton and InitializeProgress integration.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete GSD project integration flow:
1. Backend services (schema_extractor, prompt_builder)
2. WebSocket endpoint for /initialize
3. Frontend hook and components
4. Project detail page with initialization UI
  </what-built>
  <how-to-verify>
1. Start backend: `cd /Users/gilberto/projetos/wxk/wxcode && python -m uvicorn wxcode.main:app --reload`
2. Start frontend: `cd /Users/gilberto/projetos/wxk/wxcode/frontend && npm run dev`
3. Navigate to a Knowledge Base page
4. Create a new Output Project (should already work from Phase 16)
5. Click on the created project to go to detail page
6. Click "Initialize Project" button
7. Observe:
   - Button shows "Initializing..." with spinner
   - Progress panel appears with streaming output
   - CONTEXT.md created in workspace (check ~/.wxcode/workspaces/)
   - Claude Code runs /gsd:new-project (if Claude CLI installed)
   - Status changes to "active" on success
  </how-to-verify>
  <resume-signal>Type "approved" if flow works, or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. Frontend builds without TypeScript errors
2. useInitializeProject hook manages WebSocket state
3. InitializeButton shows correct state for each status
4. InitializeProgress displays streaming messages
5. Project detail page integrates all components
6. End-to-end flow works: create project -> initialize -> see streaming output
</verification>

<success_criteria>
- [ ] useInitializeProject hook added with WebSocket logic
- [ ] InitializeButton component created
- [ ] InitializeProgress component created
- [ ] Project detail page created at /kb/[id]/projects/[projectId]
- [ ] Frontend builds without errors
- [ ] Human verification: end-to-end flow works
</success_criteria>

<output>
After completion, create `.planning/phases/17-gsd-project-integration/17-03-SUMMARY.md`
</output>
