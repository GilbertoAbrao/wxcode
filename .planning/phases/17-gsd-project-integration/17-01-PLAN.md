---
phase: 17-gsd-project-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/wxcode/services/schema_extractor.py
  - src/wxcode/services/prompt_builder.py
autonomous: true

must_haves:
  truths:
    - "Schema extractor returns tables linked to Configuration elements"
    - "Prompt builder creates CONTEXT.md with stack metadata and schema"
    - "Empty Configuration scope returns empty tables (graceful handling)"
  artifacts:
    - path: "src/wxcode/services/schema_extractor.py"
      provides: "extract_schema_for_configuration function"
      exports: ["extract_schema_for_configuration"]
    - path: "src/wxcode/services/prompt_builder.py"
      provides: "PromptBuilder class with build_context and write_context_file"
      exports: ["PromptBuilder"]
  key_links:
    - from: "schema_extractor.py"
      to: "DatabaseSchema model"
      via: "Beanie find_one query"
      pattern: "DatabaseSchema\\.find_one"
    - from: "schema_extractor.py"
      to: "Element model"
      via: "Beanie find query with excluded_from filter"
      pattern: "Element\\.find.*excluded_from"
    - from: "prompt_builder.py"
      to: "schema_extractor"
      via: "function import"
      pattern: "from.*schema_extractor import"
---

<objective>
Create backend services for extracting schema data and building GSD prompts.

Purpose: These services assemble the context that Claude Code needs to generate a starter project with correct models and structure for the target stack.

Output: Two Python modules - schema_extractor.py for querying Configuration-scoped tables, and prompt_builder.py for assembling CONTEXT.md with stack metadata.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/17-gsd-project-integration/17-RESEARCH.md

# Relevant source files
@src/wxcode/models/schema.py
@src/wxcode/models/element.py
@src/wxcode/models/stack.py
@src/wxcode/models/output_project.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create schema extractor service</name>
  <files>src/wxcode/services/schema_extractor.py</files>
  <action>
Create `schema_extractor.py` with function `extract_schema_for_configuration`:

1. Accept `project_id: PydanticObjectId` and `configuration_id: Optional[str]`
2. Query `DatabaseSchema.find_one(DatabaseSchema.project_id == project_id)` to get schema
3. If no schema found, return empty list
4. Query elements in Configuration scope:
   - If configuration_id provided: `{"excluded_from": {"$nin": [configuration_id]}}`
   - If None: all elements for project
5. Collect table names from element dependencies:
   - `elem.dependencies.data_files` - tables accessed
   - `elem.dependencies.bound_tables` - tables via UI bindings
6. Filter schema.tables to those in collected table_names (match by name OR physical_name)
7. Return list of dicts with structure:
   ```python
   {
       "name": table.name,
       "physical_name": table.physical_name,
       "columns": [
           {
               "name": col.name,
               "hyperfile_type": col.hyperfile_type,
               "python_type": col.python_type,
               "size": col.size,
               "nullable": col.nullable,
               "is_primary_key": col.is_primary_key,
               "is_indexed": col.is_indexed,
               "is_auto_increment": col.is_auto_increment,
           }
           for col in table.columns
       ],
       "indexes": [
           {
               "name": idx.name,
               "columns": idx.columns,
               "is_unique": idx.is_unique,
               "is_primary": idx.is_primary,
           }
           for idx in table.indexes
       ],
   }
   ```

Use async/await for all Beanie operations. Include docstrings in Portuguese (project convention).
  </action>
  <verify>
Run: `python -c "from wxcode.services.schema_extractor import extract_schema_for_configuration; print('Import OK')"`
  </verify>
  <done>
Module imports without error. Function signature accepts project_id and optional configuration_id. Returns list of table dicts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create prompt builder service</name>
  <files>src/wxcode/services/prompt_builder.py</files>
  <action>
Create `prompt_builder.py` with `PromptBuilder` class:

1. Define PROMPT_TEMPLATE as module constant with sections:
   - Project Information (name, stack, language, framework)
   - Target Stack Characteristics (file_structure, naming_conventions, type_mappings)
   - Model Template (from stack.model_template)
   - Common Imports (from stack.imports_template)
   - Database Schema (formatted tables with columns)
   - Instructions for Claude Code

2. Implement static methods:
   - `format_dict_as_yaml(d: dict, indent: int = 0) -> str`: Format dict as YAML-like indented string
   - `format_tables(tables: list[dict]) -> str`: Format tables as markdown with column tables

3. Implement class methods:
   - `build_context(output_project, stack, tables) -> str`: Fill template with data
   - `write_context_file(output_project, stack, tables, workspace_path) -> Path`: Write CONTEXT.md to workspace

Template should include:
```markdown
# Project Context for GSD

## Project Information
- **Name:** {project_name}
- **Stack:** {stack_name}
- **Language:** {language}
- **Framework:** {framework}

## Target Stack Characteristics
### File Structure
{file_structure}

### Naming Conventions
{naming_conventions}

### Type Mappings (HyperFile -> {language})
{type_mappings}

### Model Template
```{language}
{model_template}
```

### Common Imports
```{language}
{imports_template}
```

## Database Schema
{schema_tables}

## Instructions
Generate a starter project for the {stack_name} stack with:
1. Database models for all tables listed above
2. Project structure following the file structure above
3. Configuration files (package.json, pyproject.toml, etc.)
4. Basic CRUD routes for main entities
5. README with setup instructions

Use the type mappings and naming conventions specified above.
```

Handle empty tables gracefully: show "*No tables found for this Configuration.*"
  </action>
  <verify>
Run: `python -c "from wxcode.services.prompt_builder import PromptBuilder; print('Import OK')"`
  </verify>
  <done>
Module imports without error. PromptBuilder class has build_context and write_context_file methods.
  </done>
</task>

</tasks>

<verification>
1. Both modules import without errors
2. schema_extractor has async function extract_schema_for_configuration
3. prompt_builder has PromptBuilder class with required methods
4. Run: `python -c "from wxcode.services import schema_extractor, prompt_builder; print('Both services OK')"`
</verification>

<success_criteria>
- [ ] schema_extractor.py created with extract_schema_for_configuration function
- [ ] prompt_builder.py created with PromptBuilder class
- [ ] Both modules import without errors
- [ ] Docstrings in Portuguese following project convention
- [ ] Uses existing Beanie models (DatabaseSchema, Element, Stack, OutputProject)
</success_criteria>

<output>
After completion, create `.planning/phases/17-gsd-project-integration/17-01-SUMMARY.md`
</output>
