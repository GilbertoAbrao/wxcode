---
phase: 25-websocket-protocol-extension
plan: 02
type: execute
wave: 2
depends_on: ["25-01"]
files_modified:
  - src/wxcode/services/terminal_handler.py
autonomous: true

must_haves:
  truths:
    - "Handler can stream PTY output to WebSocket concurrently with receiving input"
    - "User input is validated before being written to PTY"
    - "Resize events are forwarded to PTY via resize method"
    - "Signal events (SIGINT, SIGTERM, EOF) are forwarded to PTY"
    - "Session persists after WebSocket disconnect for reconnection"
  artifacts:
    - path: "src/wxcode/services/terminal_handler.py"
      provides: "TerminalWebSocketHandler class for bidirectional terminal orchestration"
      exports: ["TerminalHandler", "SIGNAL_MAP"]
  key_links:
    - from: "src/wxcode/services/terminal_handler.py"
      to: "src/wxcode/services/pty_session_manager.py"
      via: "PTYSession usage"
      pattern: "PTYSession"
    - from: "src/wxcode/services/terminal_handler.py"
      to: "src/wxcode/services/input_validator.py"
      via: "validate_input call"
      pattern: "validate_input"
    - from: "src/wxcode/services/terminal_handler.py"
      to: "src/wxcode/models/terminal_messages.py"
      via: "message model imports"
      pattern: "Terminal.*Message"
---

<objective>
Create TerminalHandler service for WebSocket bidirectional terminal orchestration.

Purpose: Orchestrate BidirectionalPTY, PTYSessionManager, and InputValidator with WebSocket message handling using asyncio.gather() for concurrent read/write.

Output: `terminal_handler.py` with TerminalHandler class that manages terminal session lifecycle.
</objective>

<execution_context>
@/Users/gilberto/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gilberto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-websocket-protocol-extension/25-RESEARCH.md
@.planning/phases/25-websocket-protocol-extension/25-01-SUMMARY.md

# Phase 24 services for integration
@src/wxcode/services/bidirectional_pty.py
@src/wxcode/services/pty_session_manager.py
@src/wxcode/services/input_validator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SIGNAL_MAP constant</name>
  <files>src/wxcode/services/terminal_handler.py</files>
  <action>
Create terminal_handler.py with initial setup:

1. **Module docstring** explaining the handler's role as WebSocket message orchestrator

2. **Imports:**
   - `import asyncio`
   - `import signal`
   - `import logging`
   - `from typing import Optional`
   - `from fastapi import WebSocket, WebSocketDisconnect`
   - `from pydantic import ValidationError`
   - Message models from terminal_messages
   - PTYSession from pty_session_manager
   - validate_input from input_validator

3. **SIGNAL_MAP constant:**
```python
SIGNAL_MAP = {
    "SIGINT": signal.SIGINT,    # Ctrl+C
    "SIGTERM": signal.SIGTERM,  # Graceful termination
    "EOF": None,                # Ctrl+D - handled as input b'\x04'
}
```

4. **__all__ export list** with SIGNAL_MAP and TerminalHandler (placeholder)
  </action>
  <verify>
```bash
python -c "
from wxcode.services.terminal_handler import SIGNAL_MAP
import signal
assert SIGNAL_MAP['SIGINT'] == signal.SIGINT
assert SIGNAL_MAP['SIGTERM'] == signal.SIGTERM
assert SIGNAL_MAP['EOF'] is None
print('SIGNAL_MAP defined correctly')
"
```
  </verify>
  <done>SIGNAL_MAP constant created with SIGINT, SIGTERM, EOF mappings</done>
</task>

<task type="auto">
  <name>Task 2: Create TerminalHandler class with handle_session method</name>
  <files>src/wxcode/services/terminal_handler.py</files>
  <action>
Add TerminalHandler class with concurrent read/write pattern:

```python
class TerminalHandler:
    """
    Orquestra comunicacao bidirectional entre WebSocket e PTY.

    Usa asyncio.gather() para streaming concorrente de output e input,
    valida entrada do usuario, e encaminha resize/signal ao PTY.
    """

    def __init__(self, session: PTYSession):
        """
        Inicializa handler com sessao PTY.

        Args:
            session: Sessao PTY existente do PTYSessionManager
        """
        self._session = session
        self._logger = logging.getLogger(__name__)

    async def handle_session(self, websocket: WebSocket) -> None:
        """
        Gerencia comunicacao bidirectional para sessao terminal.

        Inicia duas tasks concorrentes:
        1. stream_output: PTY stdout -> WebSocket
        2. handle_input: WebSocket messages -> PTY stdin/resize/signal

        Quando uma task termina (disconnect ou processo finalizado),
        cancela a outra e retorna. Sessao permanece ativa para reconexao.
        """
        output_task = asyncio.create_task(self._stream_output(websocket))
        input_task = asyncio.create_task(self._handle_input(websocket))

        done, pending = await asyncio.wait(
            [output_task, input_task],
            return_when=asyncio.FIRST_COMPLETED,
        )

        for task in pending:
            task.cancel()
            try:
                await task
            except asyncio.CancelledError:
                pass
```

The method uses asyncio.wait with FIRST_COMPLETED to handle either:
- PTY process exits (stream_output ends)
- WebSocket disconnects (handle_input ends)
  </action>
  <verify>
```bash
python -c "
from wxcode.services.terminal_handler import TerminalHandler
import inspect
assert 'handle_session' in dir(TerminalHandler)
sig = inspect.signature(TerminalHandler.handle_session)
params = list(sig.parameters.keys())
assert 'websocket' in params
print('TerminalHandler.handle_session method exists with websocket param')
"
```
  </verify>
  <done>TerminalHandler class created with handle_session method using asyncio.wait pattern</done>
</task>

<task type="auto">
  <name>Task 3: Implement _stream_output and _handle_input coroutines</name>
  <files>src/wxcode/services/terminal_handler.py</files>
  <action>
Add private coroutines for concurrent handling:

```python
async def _stream_output(self, websocket: WebSocket) -> None:
    """Stream PTY output to WebSocket, add to replay buffer."""
    try:
        async for data in self._session.pty.stream_output():
            # Add to session buffer for reconnection replay
            self._session.add_to_buffer(data)
            # Decode and send to WebSocket
            text = data.decode("utf-8", errors="replace")
            msg = TerminalOutputMessage(data=text)
            await websocket.send_json(msg.model_dump())
    except Exception as e:
        self._logger.debug(f"Stream output ended: {e}")

async def _handle_input(self, websocket: WebSocket) -> None:
    """Handle WebSocket messages and route to PTY."""
    try:
        while True:
            raw = await websocket.receive_json()
            try:
                msg = parse_incoming_message(raw)
            except ValidationError as e:
                error_msg = TerminalErrorMessage(
                    message=str(e),
                    code="VALIDATION"
                )
                await websocket.send_json(error_msg.model_dump())
                continue

            await self._process_message(msg, websocket)
    except WebSocketDisconnect:
        self._logger.debug("WebSocket disconnected")
    except Exception as e:
        self._logger.debug(f"Input handler ended: {e}")

async def _process_message(
    self,
    msg: IncomingMessage,
    websocket: WebSocket
) -> None:
    """Route parsed message to appropriate PTY operation."""
    if isinstance(msg, TerminalInputMessage):
        # Validate input before writing
        data = msg.data.encode("utf-8")
        is_valid, error = validate_input(data)
        if is_valid:
            await self._session.pty.write(data)
        else:
            error_msg = TerminalErrorMessage(message=error, code="VALIDATION")
            await websocket.send_json(error_msg.model_dump())

    elif isinstance(msg, TerminalResizeMessage):
        await self._session.pty.resize(msg.rows, msg.cols)

    elif isinstance(msg, TerminalSignalMessage):
        if msg.signal == "EOF":
            # EOF is Ctrl+D - send as character
            await self._session.pty.write(b'\x04')
        else:
            sig = SIGNAL_MAP.get(msg.signal)
            if sig:
                await self._session.pty.send_signal(sig)
```

Key patterns:
- Validation error returns error message to client, does NOT close connection
- Input validation uses validate_input from input_validator
- EOF is special-cased as b'\x04' write (Ctrl+D)
- stream_output adds to session buffer for reconnection replay
  </action>
  <verify>
```bash
python -c "
from wxcode.services.terminal_handler import TerminalHandler
import inspect

# Check private methods exist
handler_methods = dir(TerminalHandler)
assert '_stream_output' in handler_methods
assert '_handle_input' in handler_methods
assert '_process_message' in handler_methods

# Check they are async
assert inspect.iscoroutinefunction(TerminalHandler._stream_output)
assert inspect.iscoroutinefunction(TerminalHandler._handle_input)
assert inspect.iscoroutinefunction(TerminalHandler._process_message)

print('All TerminalHandler coroutines implemented correctly')
"
```
  </verify>
  <done>_stream_output, _handle_input, _process_message coroutines implemented with validation, signal handling, and buffer management</done>
</task>

</tasks>

<verification>
- `python -c "from wxcode.services.terminal_handler import TerminalHandler, SIGNAL_MAP"` imports without error
- TerminalHandler has handle_session, _stream_output, _handle_input, _process_message methods
- All methods are async coroutines
- SIGNAL_MAP maps SIGINT, SIGTERM, EOF correctly
</verification>

<success_criteria>
- terminal_handler.py exists with TerminalHandler class
- Concurrent read/write pattern using asyncio.wait
- Input validation integrated with error messages to client
- Resize and signal forwarding implemented
- Session buffer updated on output for reconnection replay
</success_criteria>

<output>
After completion, create `.planning/phases/25-websocket-protocol-extension/25-02-SUMMARY.md`
</output>
