---
phase: 25-websocket-protocol-extension
plan: 03
type: execute
wave: 2
depends_on: ["25-01"]
files_modified:
  - src/wxcode/api/milestones.py
autonomous: true

must_haves:
  truths:
    - "WebSocket endpoint /milestones/{id}/terminal accepts connections"
    - "Connection sends status message immediately on connect"
    - "Existing session is found and replay buffer is sent on reconnect"
    - "No session returns error and closes with code 4004"
    - "Disconnect does not close session (persists for reconnection)"
  artifacts:
    - path: "src/wxcode/api/milestones.py"
      provides: "terminal_websocket endpoint for interactive terminal"
      contains: "@router.websocket"
  key_links:
    - from: "src/wxcode/api/milestones.py"
      to: "src/wxcode/services/pty_session_manager.py"
      via: "get_session_manager() call"
      pattern: "get_session_manager"
    - from: "src/wxcode/api/milestones.py"
      to: "src/wxcode/services/terminal_handler.py"
      via: "TerminalHandler usage"
      pattern: "TerminalHandler"
---

<objective>
Add WebSocket endpoint for interactive terminal sessions to milestones API.

Purpose: Create `/milestones/{id}/terminal` endpoint that enables bidirectional terminal communication with existing PTY sessions created by /initialize.

Output: New WebSocket endpoint in milestones.py with status messages, session lookup, and reconnection support.
</objective>

<execution_context>
@/Users/gilberto/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gilberto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-websocket-protocol-extension/25-RESEARCH.md
@.planning/phases/25-websocket-protocol-extension/25-01-SUMMARY.md

# Existing endpoint structure
@src/wxcode/api/milestones.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add imports for terminal WebSocket</name>
  <files>src/wxcode/api/milestones.py</files>
  <action>
Add new imports at the top of milestones.py for terminal WebSocket support:

```python
# After existing imports, add:
from wxcode.services.pty_session_manager import get_session_manager
from wxcode.services.terminal_handler import TerminalHandler
from wxcode.models.terminal_messages import (
    TerminalStatusMessage,
    TerminalOutputMessage,
    TerminalErrorMessage,
    TerminalClosedMessage,
)
```

These imports enable:
- Session lookup via get_session_manager()
- Bidirectional handling via TerminalHandler
- Response messages for status, output, error, closed
  </action>
  <verify>
```bash
python -c "
# Just verify the module imports without error
from wxcode.api import milestones
print('milestones.py imports successfully with new dependencies')
"
```
  </verify>
  <done>New imports added for terminal handler and message models</done>
</task>

<task type="auto">
  <name>Task 2: Create terminal WebSocket endpoint</name>
  <files>src/wxcode/api/milestones.py</files>
  <action>
Add new WebSocket endpoint after the existing `/initialize` endpoint:

```python
@router.websocket("/{id}/terminal")
async def terminal_websocket(websocket: WebSocket, id: str):
    """
    Terminal interativo via WebSocket para sessao Claude Code existente.

    Este endpoint conecta a uma sessao PTY ja criada pelo /initialize.
    Permite enviar input, resize, e sinais ao processo.

    Flow:
    1. Aceita conexao WebSocket
    2. Envia TerminalStatusMessage(connected=True)
    3. Busca sessao existente no PTYSessionManager
    4. Se nao existe, envia erro e fecha com codigo 4004
    5. Se existe, envia replay buffer e inicia handler bidirecional
    6. WebSocket disconnect nao fecha sessao (permite reconexao)

    Messages aceitas (client -> server):
    - {"type": "input", "data": "..."} - input do usuario
    - {"type": "resize", "rows": N, "cols": N} - resize terminal
    - {"type": "signal", "signal": "SIGINT|SIGTERM|EOF"} - sinais

    Messages enviadas (server -> client):
    - {"type": "status", "connected": true, "session_id": "..."} - status
    - {"type": "output", "data": "..."} - output do processo
    - {"type": "error", "message": "...", "code": "..."} - erros
    - {"type": "closed", "exit_code": N} - processo finalizado
    """
    await websocket.accept()

    # Send connection status immediately
    await websocket.send_json(
        TerminalStatusMessage(connected=True, session_id=None).model_dump()
    )

    # Validate milestone ID format
    try:
        milestone_oid = PydanticObjectId(id)
    except Exception:
        await websocket.send_json(
            TerminalErrorMessage(message="ID de milestone invalido", code="INVALID_ID").model_dump()
        )
        await websocket.close(code=4000)
        return

    # Lookup existing session
    session_manager = get_session_manager()
    session = session_manager.get_session_by_milestone(str(milestone_oid))

    if not session:
        await websocket.send_json(
            TerminalErrorMessage(
                message="Nenhuma sessao ativa para este milestone. Inicie via /initialize primeiro.",
                code="NO_SESSION"
            ).model_dump()
        )
        await websocket.close(code=4004)
        return

    # Update status with session_id
    await websocket.send_json(
        TerminalStatusMessage(connected=True, session_id=session.session_id).model_dump()
    )

    # Send replay buffer for reconnection continuity
    replay = session.get_replay_buffer()
    if replay:
        text = replay.decode("utf-8", errors="replace")
        await websocket.send_json(
            TerminalOutputMessage(data=text).model_dump()
        )

    # Handle bidirectional communication
    handler = TerminalHandler(session)
    try:
        await handler.handle_session(websocket)
    except WebSocketDisconnect:
        pass  # Normal disconnect - session persists for reconnection
    finally:
        # Update session activity for timeout tracking
        session_manager.update_activity(session.session_id)
```

Key behaviors:
- Status message sent immediately on connect (COMM-02 requirement)
- Session lookup uses milestone ID, not session ID
- Replay buffer sent on reconnection for continuity
- Disconnect does NOT close session (PTY-05 requirement)
- update_activity extends session timeout on disconnect
  </action>
  <verify>
```bash
python -c "
import ast
with open('src/wxcode/api/milestones.py', 'r') as f:
    content = f.read()

# Check endpoint decorator exists
assert '@router.websocket(\"{id}/terminal\")' in content or '@router.websocket(\"/{id}/terminal\")' in content

# Check key patterns
assert 'terminal_websocket' in content
assert 'TerminalStatusMessage' in content
assert 'get_session_manager' in content
assert 'TerminalHandler' in content
assert 'get_replay_buffer' in content
assert 'code=4004' in content

print('Terminal WebSocket endpoint added with all required patterns')
"
```
  </verify>
  <done>Terminal WebSocket endpoint created with status messages, session lookup, replay buffer, and proper disconnect handling</done>
</task>

<task type="auto">
  <name>Task 3: Add update_activity method to PTYSessionManager if missing</name>
  <files>src/wxcode/services/pty_session_manager.py</files>
  <action>
Check if PTYSessionManager has update_activity method. If not, add it:

```python
def update_activity(self, session_id: str) -> bool:
    """
    Atualiza timestamp de ultima atividade da sessao.

    Chamado quando WebSocket reconecta ou desconecta para
    estender o timeout da sessao.

    Args:
        session_id: ID da sessao

    Returns:
        True se sessao encontrada, False caso contrario
    """
    session = self._sessions.get(session_id)
    if session:
        session.last_activity = datetime.utcnow()
        return True
    return False
```

Also verify get_session_by_milestone exists. If not, add it:

```python
def get_session_by_milestone(self, milestone_id: str) -> Optional[PTYSession]:
    """
    Busca sessao por milestone ID.

    Args:
        milestone_id: ID do milestone

    Returns:
        PTYSession se encontrada, None caso contrario
    """
    session_id = self._milestone_to_session.get(milestone_id)
    if session_id:
        return self._sessions.get(session_id)
    return None
```

Update __all__ to include these methods if added.
  </action>
  <verify>
```bash
python -c "
from wxcode.services.pty_session_manager import PTYSessionManager

manager = PTYSessionManager()

# Check update_activity exists
assert hasattr(manager, 'update_activity')

# Check get_session_by_milestone exists
assert hasattr(manager, 'get_session_by_milestone')

print('PTYSessionManager has required methods for terminal endpoint')
"
```
  </verify>
  <done>PTYSessionManager has update_activity and get_session_by_milestone methods</done>
</task>

</tasks>

<verification>
- `python -c "from wxcode.api.milestones import router"` imports without error
- Terminal WebSocket endpoint exists at `/{id}/terminal`
- Endpoint sends status message on connect
- Endpoint handles missing session with 4004 close code
- PTYSessionManager has update_activity method
</verification>

<success_criteria>
- milestones.py has new /terminal WebSocket endpoint
- Status indicator sent immediately on connection (COMM-02)
- Session lookup by milestone ID works
- Replay buffer sent on reconnection
- Disconnect preserves session for reconnection window
- 4004 error code for "no session" case
</success_criteria>

<output>
After completion, create `.planning/phases/25-websocket-protocol-extension/25-03-SUMMARY.md`
</output>
