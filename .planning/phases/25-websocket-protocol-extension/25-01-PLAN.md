---
phase: 25-websocket-protocol-extension
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/wxcode/models/terminal_messages.py
autonomous: true

must_haves:
  truths:
    - "WebSocket messages can be parsed to typed Pydantic models"
    - "Invalid messages raise ValidationError with clear error message"
    - "Message types cover: input, output, resize, signal, status, error, closed"
  artifacts:
    - path: "src/wxcode/models/terminal_messages.py"
      provides: "Pydantic message models for bidirectional terminal communication"
      exports: ["TerminalInputMessage", "TerminalResizeMessage", "TerminalSignalMessage", "TerminalOutputMessage", "TerminalStatusMessage", "TerminalErrorMessage", "TerminalClosedMessage", "IncomingMessage", "OutgoingMessage", "parse_incoming_message"]
  key_links: []
---

<objective>
Create Pydantic message models for WebSocket bidirectional terminal protocol.

Purpose: Enable type-safe message validation for stdin/stdout/resize/signal WebSocket communication with discriminated union pattern.

Output: `terminal_messages.py` with Pydantic models for all 7 message types plus parser function.
</objective>

<execution_context>
@/Users/gilberto/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gilberto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-websocket-protocol-extension/25-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pydantic message models</name>
  <files>src/wxcode/models/terminal_messages.py</files>
  <action>
Create terminal_messages.py with 7 Pydantic message models using discriminated union pattern:

1. **Incoming messages (client -> server):**
   - `TerminalInputMessage`: type="input", data: str (max_length=2048 to match MAX_MESSAGE_SIZE)
   - `TerminalResizeMessage`: type="resize", rows: int (ge=1, le=500), cols: int (ge=1, le=500)
   - `TerminalSignalMessage`: type="signal", signal: Literal["SIGINT", "SIGTERM", "EOF"]

2. **Outgoing messages (server -> client):**
   - `TerminalOutputMessage`: type="output", data: str
   - `TerminalStatusMessage`: type="status", connected: bool, session_id: str | None = None
   - `TerminalErrorMessage`: type="error", message: str, code: str | None = None
   - `TerminalClosedMessage`: type="closed", exit_code: int | None = None

3. **Discriminated unions:**
   - `IncomingMessage = Union[TerminalInputMessage, TerminalResizeMessage, TerminalSignalMessage]`
   - `OutgoingMessage = Union[TerminalOutputMessage, TerminalStatusMessage, TerminalErrorMessage, TerminalClosedMessage]`

4. **Parser function:**
   - `parse_incoming_message(raw: dict) -> IncomingMessage`: Uses TypeAdapter for validation

Use Pydantic v2 patterns:
- `from typing import Literal, Union`
- `from pydantic import BaseModel, Field, TypeAdapter`
- Each model has `type: Literal["typename"]` as discriminator
- All models have docstrings in Portuguese

Include __all__ export list.
  </action>
  <verify>
```bash
python -c "
from wxcode.models.terminal_messages import (
    TerminalInputMessage, TerminalResizeMessage, TerminalSignalMessage,
    TerminalOutputMessage, TerminalStatusMessage, TerminalErrorMessage,
    TerminalClosedMessage, IncomingMessage, OutgoingMessage, parse_incoming_message
)

# Test input message
msg = parse_incoming_message({'type': 'input', 'data': 'hello'})
assert isinstance(msg, TerminalInputMessage)
assert msg.data == 'hello'

# Test resize message
msg = parse_incoming_message({'type': 'resize', 'rows': 40, 'cols': 120})
assert isinstance(msg, TerminalResizeMessage)
assert msg.rows == 40

# Test signal message
msg = parse_incoming_message({'type': 'signal', 'signal': 'SIGINT'})
assert isinstance(msg, TerminalSignalMessage)

# Test validation error on invalid type
try:
    parse_incoming_message({'type': 'invalid', 'data': 'x'})
    assert False, 'Should have raised'
except Exception:
    pass

# Test output messages
out = TerminalStatusMessage(connected=True, session_id='abc')
assert out.model_dump()['type'] == 'status'

print('All message validation tests pass')
"
```
  </verify>
  <done>All 7 message models created with proper field constraints, discriminated unions typed, parse_incoming_message function works</done>
</task>

</tasks>

<verification>
- `python -c "from wxcode.models.terminal_messages import *"` imports without error
- All model classes have proper `type` discriminator field
- IncomingMessage and OutgoingMessage unions defined
- parse_incoming_message validates and returns typed message
</verification>

<success_criteria>
- terminal_messages.py exists with all 7 message models
- Pydantic v2 discriminated union pattern correctly implemented
- Field constraints match research spec (2048 chars input, 1-500 rows/cols)
- Parser function handles validation errors gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/25-websocket-protocol-extension/25-01-SUMMARY.md`
</output>
