---
phase: 26-frontend-integration
plan: 02
type: execute
wave: 2
depends_on: ["26-01"]
files_modified:
  - frontend/src/components/terminal/InteractiveTerminal.tsx
  - frontend/src/components/terminal/index.ts
autonomous: false

must_haves:
  truths:
    - "User can type in xterm.js terminal and keystrokes are captured"
    - "Enter key sends current line to backend via WebSocket"
    - "Ctrl+C sends SIGINT to running process"
    - "Backspace works correctly"
    - "Typed characters echo visually in terminal"
    - "User can paste text into terminal"
  artifacts:
    - path: "frontend/src/components/terminal/InteractiveTerminal.tsx"
      provides: "Bidirectional xterm.js terminal component"
      exports: ["InteractiveTerminal", "InteractiveTerminalProps"]
    - path: "frontend/src/components/terminal/index.ts"
      provides: "Terminal component exports"
      exports: ["Terminal", "InteractiveTerminal"]
  key_links:
    - from: "frontend/src/components/terminal/InteractiveTerminal.tsx"
      to: "frontend/src/hooks/useTerminalWebSocket.ts"
      via: "Hook integration for WebSocket"
      pattern: "useTerminalWebSocket"
    - from: "frontend/src/components/terminal/InteractiveTerminal.tsx"
      to: "@xterm/xterm"
      via: "xterm.js terminal.onData for input capture"
      pattern: "terminal\\.onData"
---

<objective>
Create the InteractiveTerminal component that enables bidirectional communication with the backend terminal.

Purpose: Connect xterm.js input events to the WebSocket hook, allowing users to type, paste, and send control signals to the Claude Code process running in the PTY backend.

Output: A drop-in component that can be used anywhere a bidirectional terminal is needed.
</objective>

<execution_context>
@/Users/gilberto/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gilberto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-frontend-integration/26-RESEARCH.md
@.planning/phases/26-frontend-integration/26-01-SUMMARY.md
@frontend/src/components/terminal/Terminal.tsx
@frontend/src/components/terminal/index.ts
@frontend/src/hooks/useTerminalWebSocket.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create InteractiveTerminal component</name>
  <files>frontend/src/components/terminal/InteractiveTerminal.tsx</files>
  <action>
Create `frontend/src/components/terminal/InteractiveTerminal.tsx` following the patterns from existing Terminal.tsx and research recommendations.

**Component signature:**
```typescript
export interface InteractiveTerminalProps {
  milestoneId: string;
  onConnected?: () => void;
  onDisconnected?: () => void;
  onError?: (message: string) => void;
  onProcessClosed?: (exitCode: number | null) => void;
  className?: string;
}

export function InteractiveTerminal(props: InteractiveTerminalProps): JSX.Element
```

**Implementation structure:**

1. **Refs:**
   ```typescript
   const containerRef = useRef<HTMLDivElement>(null);
   const terminalRef = useRef<XTerm | null>(null);
   const fitAddonRef = useRef<FitAddon | null>(null);
   const resizeTimeoutRef = useRef<NodeJS.Timeout | null>(null);
   ```

2. **Hook integration:**
   ```typescript
   const {
     isConnected,
     sessionId,
     connect,
     disconnect,
     sendInput,
     sendResize,
   } = useTerminalWebSocket(milestoneId, {
     onOutput: (data) => terminalRef.current?.write(data),
     onStatus: (connected, sid) => {
       if (connected) onConnected?.();
     },
     onError: (message) => onError?.(message),
     onClosed: (exitCode) => onProcessClosed?.(exitCode),
     autoConnect: false,  // Connect AFTER terminal mount
   });
   ```

3. **Debounced resize sender:**
   ```typescript
   const sendResizeDebounced = useCallback((rows: number, cols: number) => {
     if (resizeTimeoutRef.current) {
       clearTimeout(resizeTimeoutRef.current);
     }
     resizeTimeoutRef.current = setTimeout(() => {
       sendResize(rows, cols);
     }, 100);  // 100ms debounce per research
   }, [sendResize]);
   ```

4. **Main useEffect for terminal initialization:**
   ```typescript
   useEffect(() => {
     if (!containerRef.current) return;

     // Initialize xterm.js (same theme as Terminal.tsx)
     const terminal = new XTerm({
       theme: {
         background: "#09090b",
         foreground: "#fafafa",
         cursor: "#fafafa",
         cursorAccent: "#09090b",
         selectionBackground: "#3f3f46",
         black: "#18181b",
         red: "#ef4444",
         green: "#22c55e",
         yellow: "#eab308",
         blue: "#3b82f6",
         magenta: "#a855f7",
         cyan: "#06b6d4",
         white: "#fafafa",
         brightBlack: "#52525b",
         brightRed: "#f87171",
         brightGreen: "#4ade80",
         brightYellow: "#facc15",
         brightBlue: "#60a5fa",
         brightMagenta: "#c084fc",
         brightCyan: "#22d3ee",
         brightWhite: "#ffffff",
       },
       fontFamily: "'JetBrains Mono', 'Fira Code', Consolas, monospace",
       fontSize: 12,
       lineHeight: 1.2,
       cursorBlink: true,
       cursorStyle: "block",
       scrollback: 10000,
       allowProposedApi: true,
       convertEol: true,
     });

     const fitAddon = new FitAddon();
     terminal.loadAddon(fitAddon);
     terminal.open(containerRef.current);

     // Wait for animation frame before initial fit (Pitfall 1 from research)
     requestAnimationFrame(() => {
       fitAddon.fit();
       // Connect WebSocket AFTER terminal is ready (Pitfall 4 from research)
       connect();
       // Send initial dimensions
       sendResizeDebounced(terminal.rows, terminal.cols);
     });

     terminalRef.current = terminal;
     fitAddonRef.current = fitAddon;

     // User input -> WebSocket (INPUT-01, INPUT-02, INPUT-03)
     // Ctrl+C (\x03), Ctrl+D (\x04), Enter (\r), etc. all flow through here
     // NO local echo - PTY handles echo (Pitfall 2 from research)
     const dataDisposable = terminal.onData((data) => {
       sendInput(data);
     });

     // Container resize -> WebSocket (debounced - Pitfall 3 from research)
     const resizeObserver = new ResizeObserver(() => {
       try {
         fitAddon.fit();
         sendResizeDebounced(terminal.rows, terminal.cols);
       } catch {
         // Ignore fit errors during rapid resize
       }
     });
     resizeObserver.observe(containerRef.current);

     // Cleanup
     return () => {
       if (resizeTimeoutRef.current) {
         clearTimeout(resizeTimeoutRef.current);
       }
       dataDisposable.dispose();
       resizeObserver.disconnect();
       disconnect();
       terminal.dispose();
       terminalRef.current = null;
       fitAddonRef.current = null;
     };
   }, [milestoneId]);  // Only re-run if milestoneId changes
   ```

   **IMPORTANT:** The sendInput, sendResize callbacks must NOT be in the dependency array to avoid recreating terminal on every render. Use refs pattern from research (Pitfall 5).

5. **Fix for stale closure (Pitfall 5):**
   Create refs for the callback functions:
   ```typescript
   const sendInputRef = useRef(sendInput);
   sendInputRef.current = sendInput;

   const sendResizeRef = useRef(sendResizeDebounced);
   sendResizeRef.current = sendResizeDebounced;

   // In useEffect, use refs:
   terminal.onData((data) => sendInputRef.current(data));
   // ...
   sendResizeRef.current(terminal.rows, terminal.cols);
   ```

6. **JSX return:**
   ```tsx
   return (
     <div
       ref={containerRef}
       className={`bg-zinc-950 p-2 overflow-hidden h-full ${className || ""}`}
     />
   );
   ```

**How requirements are satisfied:**
- INPUT-01 (keystrokes captured): terminal.onData captures all keystrokes
- INPUT-02 (Enter sends line): Enter key (\r) flows through onData -> sendInput -> WebSocket
- INPUT-03 (Ctrl+C SIGINT): Ctrl+C sends \x03 through onData, PTY interprets as SIGINT
- INPUT-04 (Backspace works): PTY handles backspace line editing, xterm.js renders result
- INPUT-05 (Echo): PTY echoes characters back via output message, xterm.js renders
- INPUT-06 (Paste): xterm.js fires onData for pasted text, same as typing
  </action>
  <verify>Run `cd frontend && npx tsc --noEmit` - no type errors</verify>
  <done>InteractiveTerminal.tsx exists, imports xterm.js and hook, wires onData to WebSocket</done>
</task>

<task type="auto">
  <name>Task 2: Update terminal exports</name>
  <files>frontend/src/components/terminal/index.ts</files>
  <action>
Update `frontend/src/components/terminal/index.ts` to export the new InteractiveTerminal component.

**New content:**
```typescript
export { Terminal, type TerminalRef, type TerminalProps } from "./Terminal";
export {
  InteractiveTerminal,
  type InteractiveTerminalProps,
} from "./InteractiveTerminal";
```
  </action>
  <verify>Run `cd frontend && npx tsc --noEmit` - no type errors</verify>
  <done>index.ts exports both Terminal and InteractiveTerminal</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
InteractiveTerminal component with full bidirectional terminal support:
- Keystrokes are captured and sent via WebSocket
- Terminal output from PTY is rendered in xterm.js
- Ctrl+C, Enter, Backspace, and paste all work correctly
  </what-built>
  <how-to-verify>
1. Start the backend: `cd /Users/gilberto/projetos/wxk/wxcode && make dev`
2. Start the frontend: `cd frontend && npm run dev`
3. Navigate to an existing milestone with a terminal session
4. Test the following:
   - Type text: characters should appear in terminal (echoed by PTY)
   - Press Enter: line should be sent and processed
   - Press Ctrl+C: should interrupt running process (if any)
   - Press Backspace: should delete characters (PTY handles line editing)
   - Paste text (Ctrl+V / Cmd+V): pasted text should appear in terminal
5. Verify WebSocket connection status in browser dev tools Network tab
  </how-to-verify>
  <resume-signal>Type "approved" if all input scenarios work, or describe issues found</resume-signal>
</task>

</tasks>

<verification>
1. Type check: `cd frontend && npx tsc --noEmit` - should pass
2. Component imports hook: InteractiveTerminal.tsx uses useTerminalWebSocket
3. Component exports: Can import { InteractiveTerminal } from "@/components/terminal"
4. No local echo: terminal.write only called for output messages, not input
5. Debounced resize: Only one resize message per 100ms during window drag
</verification>

<success_criteria>
- InteractiveTerminal.tsx compiles without errors
- Component is exported from terminal/index.ts
- INPUT-01 through INPUT-06 requirements satisfied
- Human verification confirms interactive terminal works end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/26-frontend-integration/26-02-SUMMARY.md`
</output>
