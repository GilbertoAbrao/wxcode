---
phase: 16-output-project-ui
plan: 02
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - frontend/src/types/output-project.ts
  - frontend/src/types/index.ts
  - frontend/src/hooks/useStacks.ts
  - frontend/src/hooks/useOutputProjects.ts
  - frontend/src/hooks/index.ts
autonomous: true

must_haves:
  truths:
    - "TypeScript types match backend Pydantic models"
    - "useStacksGrouped hook fetches and caches stacks"
    - "useOutputProjects hook fetches output projects by kb_id"
    - "useCreateOutputProject mutation creates project and invalidates cache"
  artifacts:
    - path: "frontend/src/types/output-project.ts"
      provides: "Stack and OutputProject TypeScript interfaces"
      exports: ["Stack", "StacksGroupedResponse", "OutputProject", "CreateOutputProjectRequest"]
    - path: "frontend/src/hooks/useStacks.ts"
      provides: "TanStack Query hook for stacks"
      exports: ["useStacksGrouped"]
    - path: "frontend/src/hooks/useOutputProjects.ts"
      provides: "TanStack Query hooks for output projects"
      exports: ["useOutputProjects", "useCreateOutputProject"]
  key_links:
    - from: "frontend/src/hooks/useStacks.ts"
      to: "/api/stacks/grouped"
      via: "fetch call"
      pattern: "fetch.*api/stacks/grouped"
    - from: "frontend/src/hooks/useOutputProjects.ts"
      to: "/api/output-projects"
      via: "fetch call"
      pattern: "fetch.*api/output-projects"
---

<objective>
Create TypeScript types and TanStack Query hooks for stack and output project data fetching.

Purpose: Establish the frontend data layer that connects to the backend API created in Plan 01. Types ensure type safety, hooks provide caching, loading states, and cache invalidation.

Output: Type definitions and hooks ready for use by UI components in Plan 03.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/16-output-project-ui/16-RESEARCH.md
@.planning/phases/16-output-project-ui/16-01-SUMMARY.md

# Existing patterns
@frontend/src/types/product.ts
@frontend/src/hooks/useProducts.ts
@frontend/src/hooks/index.ts
@frontend/src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create output-project TypeScript types</name>
  <files>frontend/src/types/output-project.ts, frontend/src/types/index.ts</files>
  <action>
Create TypeScript interfaces matching backend Pydantic models.

File: frontend/src/types/output-project.ts

```typescript
/**
 * Types for Output Project and Stack management.
 *
 * Output Projects are conversion targets from a Knowledge Base
 * to a specific technology stack.
 */

// Stack interface matching backend StackResponse
export interface Stack {
  stack_id: string;
  name: string;
  group: string;
  language: string;
  framework: string;
  orm: string;
  template_engine: string;
}

// Grouped stacks response
export interface StacksGroupedResponse {
  server_rendered: Stack[];
  spa: Stack[];
  fullstack: Stack[];
}

// Stack list response
export interface StackListResponse {
  stacks: Stack[];
  total: number;
}

// Configuration from Project (KB)
export interface Configuration {
  name: string;
  configuration_id: string;
  config_type: number;
}

// Output project status
export type OutputProjectStatus = "created" | "initialized" | "active";

// Output project interface matching backend OutputProjectResponse
export interface OutputProject {
  id: string;
  kb_id: string;
  kb_name: string;
  name: string;
  stack_id: string;
  configuration_id: string | null;
  workspace_path: string;
  status: OutputProjectStatus;
  created_at: string;
  updated_at: string;
}

// List response
export interface OutputProjectListResponse {
  projects: OutputProject[];
  total: number;
}

// Create request
export interface CreateOutputProjectRequest {
  kb_id: string;
  name: string;
  stack_id: string;
  configuration_id?: string;
}

// Status configuration for UI display
export const outputProjectStatusConfig: Record<
  OutputProjectStatus,
  { label: string; color: string; icon: string }
> = {
  created: { label: "Created", color: "yellow", icon: "circle" },
  initialized: { label: "Initialized", color: "blue", icon: "play" },
  active: { label: "Active", color: "green", icon: "check" },
};

// Group labels for stack selector
export const STACK_GROUP_LABELS: Record<string, string> = {
  server_rendered: "Server-rendered",
  spa: "SPA",
  fullstack: "Fullstack",
};
```

Update frontend/src/types/index.ts to export the new types:
```typescript
export * from "./output-project";
```
Add this line with other exports.
  </action>
  <verify>
```bash
cd /Users/gilberto/projetos/wxk/wxcode/frontend
npx tsc --noEmit src/types/output-project.ts 2>&1 | head -20 || echo "Type check done"
```
  </verify>
  <done>
- output-project.ts exists with all interfaces
- Types exported from index.ts
- No TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useStacks hook</name>
  <files>frontend/src/hooks/useStacks.ts</files>
  <action>
Create TanStack Query hook for fetching stacks following useProducts.ts pattern.

File: frontend/src/hooks/useStacks.ts

```typescript
"use client";

/**
 * Hooks for fetching stack configurations.
 *
 * Uses TanStack Query with long staleTime since stacks rarely change.
 */

import { useQuery } from "@tanstack/react-query";
import type { StacksGroupedResponse, StackListResponse } from "@/types/output-project";

/**
 * Fetch stacks grouped by category.
 */
async function fetchStacksGrouped(): Promise<StacksGroupedResponse> {
  const response = await fetch("/api/stacks/grouped");
  if (!response.ok) {
    throw new Error("Failed to fetch stacks");
  }
  return response.json();
}

/**
 * Fetch all stacks as flat list.
 */
async function fetchStacks(group?: string): Promise<StackListResponse> {
  const params = new URLSearchParams();
  if (group) params.set("group", group);

  const url = `/api/stacks${params.toString() ? `?${params}` : ""}`;
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error("Failed to fetch stacks");
  }
  return response.json();
}

/**
 * Hook to fetch stacks grouped by category.
 *
 * @returns Query result with grouped stacks
 */
export function useStacksGrouped() {
  return useQuery({
    queryKey: ["stacks", "grouped"],
    queryFn: fetchStacksGrouped,
    staleTime: 1000 * 60 * 60, // 1 hour - stacks rarely change
  });
}

/**
 * Hook to fetch stacks as flat list with optional filtering.
 *
 * @param group - Optional group filter ("server-rendered", "spa", "fullstack")
 * @returns Query result with stack list
 */
export function useStacks(group?: string) {
  return useQuery({
    queryKey: ["stacks", "list", group],
    queryFn: () => fetchStacks(group),
    staleTime: 1000 * 60 * 60, // 1 hour
  });
}
```
  </action>
  <verify>
```bash
cd /Users/gilberto/projetos/wxk/wxcode/frontend
npx tsc --noEmit src/hooks/useStacks.ts 2>&1 | head -20 || echo "Type check done"
```
  </verify>
  <done>
- useStacks.ts exists with useStacksGrouped and useStacks hooks
- Uses TanStack Query with 1-hour staleTime
- No TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Create useOutputProjects hook and update exports</name>
  <files>frontend/src/hooks/useOutputProjects.ts, frontend/src/hooks/index.ts</files>
  <action>
Create TanStack Query hooks for output project CRUD following useProducts.ts pattern.

File: frontend/src/hooks/useOutputProjects.ts

```typescript
"use client";

/**
 * Hooks for output project management.
 *
 * Uses TanStack Query for fetching and mutation with automatic cache invalidation.
 */

import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import type {
  OutputProject,
  OutputProjectListResponse,
  CreateOutputProjectRequest,
} from "@/types/output-project";

/**
 * Fetch output projects for a KB.
 */
async function fetchOutputProjects(kbId: string): Promise<OutputProjectListResponse> {
  const response = await fetch(`/api/output-projects?kb_id=${kbId}`);
  if (!response.ok) {
    throw new Error("Failed to fetch output projects");
  }
  return response.json();
}

/**
 * Fetch single output project by ID.
 */
async function fetchOutputProject(id: string): Promise<OutputProject> {
  const response = await fetch(`/api/output-projects/${id}`);
  if (!response.ok) {
    throw new Error("Failed to fetch output project");
  }
  return response.json();
}

/**
 * Create a new output project.
 */
async function createOutputProject(request: CreateOutputProjectRequest): Promise<OutputProject> {
  const response = await fetch("/api/output-projects", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(request),
  });
  if (!response.ok) {
    const error = await response.json().catch(() => ({ detail: "Failed to create output project" }));
    throw new Error(error.detail || "Failed to create output project");
  }
  return response.json();
}

/**
 * Hook to fetch output projects for a Knowledge Base.
 *
 * @param kbId - Knowledge Base (Project) ID
 * @returns Query result with output project list
 */
export function useOutputProjects(kbId: string) {
  return useQuery({
    queryKey: ["output-projects", kbId],
    queryFn: () => fetchOutputProjects(kbId),
    enabled: !!kbId,
  });
}

/**
 * Hook to fetch a single output project.
 *
 * @param id - Output project ID
 * @returns Query result with output project
 */
export function useOutputProject(id: string) {
  return useQuery({
    queryKey: ["output-project", id],
    queryFn: () => fetchOutputProject(id),
    enabled: !!id,
  });
}

/**
 * Hook to create a new output project.
 *
 * @returns Mutation for creating output project with automatic cache invalidation
 */
export function useCreateOutputProject() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: createOutputProject,
    onSuccess: (data) => {
      // Invalidate output projects list for this KB
      queryClient.invalidateQueries({
        queryKey: ["output-projects", data.kb_id],
      });
    },
  });
}
```

Update frontend/src/hooks/index.ts to export the new hooks:
```typescript
export * from "./useStacks";
export * from "./useOutputProjects";
```
Add these lines with other exports (after useProducts export).
  </action>
  <verify>
```bash
cd /Users/gilberto/projetos/wxk/wxcode/frontend
npx tsc --noEmit src/hooks/useOutputProjects.ts src/hooks/useStacks.ts 2>&1 | head -20 || echo "Type check done"

# Verify exports
grep -E "useStacks|useOutputProjects" src/hooks/index.ts
```
  </verify>
  <done>
- useOutputProjects.ts exists with useOutputProjects, useOutputProject, useCreateOutputProject
- Hooks exported from index.ts
- Mutation invalidates cache on success
- No TypeScript errors
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/gilberto/projetos/wxk/wxcode/frontend

# 1. Verify all files exist
ls -la src/types/output-project.ts src/hooks/useStacks.ts src/hooks/useOutputProjects.ts

# 2. Type check all new files
npx tsc --noEmit src/types/output-project.ts src/hooks/useStacks.ts src/hooks/useOutputProjects.ts 2>&1 | tail -10

# 3. Verify exports work
echo "import { useStacksGrouped, useOutputProjects, useCreateOutputProject } from './hooks';" > /tmp/test-imports.ts
echo "import { Stack, OutputProject, CreateOutputProjectRequest } from './types';" >> /tmp/test-imports.ts
echo "console.log('Imports OK');" >> /tmp/test-imports.ts

# 4. Check no lint errors
npx eslint src/types/output-project.ts src/hooks/useStacks.ts src/hooks/useOutputProjects.ts --quiet 2>&1 | tail -10 || echo "Lint done"
```
</verification>

<success_criteria>
- All TypeScript types match backend models
- useStacksGrouped returns StacksGroupedResponse
- useOutputProjects(kbId) returns OutputProjectListResponse
- useCreateOutputProject mutation works with cache invalidation
- No TypeScript or ESLint errors
</success_criteria>

<output>
After completion, create `.planning/phases/16-output-project-ui/16-02-SUMMARY.md`
</output>
