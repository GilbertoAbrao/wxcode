---
phase: 29-session-lifecycle-frontend
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/types/terminal.ts
  - frontend/src/hooks/useTerminalWebSocket.ts
autonomous: true

must_haves:
  truths:
    - "Hook returns connectionState for UI rendering"
    - "Hook distinguishes between connecting, resuming, connected, error, disconnected states"
    - "Error messages include code for mapping to user-friendly text"
  artifacts:
    - path: "frontend/src/types/terminal.ts"
      provides: "ConnectionState type and error code mapping"
      contains: "ConnectionState"
    - path: "frontend/src/hooks/useTerminalWebSocket.ts"
      provides: "Extended hook with connectionState and errorMessage"
      exports: ["useTerminalWebSocket", "UseTerminalWebSocketReturn"]
  key_links:
    - from: "useTerminalWebSocket"
      to: "ConnectionState type"
      via: "return type includes connectionState field"
      pattern: "connectionState.*ConnectionState"
---

<objective>
Extend useTerminalWebSocket hook to track connection lifecycle state for UI rendering.

Purpose: The UI needs to know when the terminal is connecting, resuming a session, connected, or in error state to display appropriate visual feedback. The existing hook only tracks isConnected boolean, which is insufficient for nuanced UX.

Output: Extended types in terminal.ts and useTerminalWebSocket hook with connectionState, errorMessage, and errorCode fields.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-session-lifecycle-frontend/29-RESEARCH.md

@frontend/src/types/terminal.ts
@frontend/src/hooks/useTerminalWebSocket.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add connection state types to terminal.ts</name>
  <files>frontend/src/types/terminal.ts</files>
  <action>
Add ConnectionState type and error code mapping at the end of the file:

1. Add ConnectionState type union:
```typescript
export type ConnectionState =
  | "idle"       // Initial state, not connected
  | "connecting" // WebSocket connecting
  | "resuming"   // Resuming existing Claude session
  | "connected"  // Fully connected
  | "error"      // Error occurred
  | "disconnected"; // Was connected, now disconnected
```

2. Add ERROR_MESSAGES constant for user-friendly messages:
```typescript
export const TERMINAL_ERROR_MESSAGES: Record<string, string> = {
  NO_SESSION: "Sessao nao encontrada. Inicialize o milestone primeiro.",
  INVALID_ID: "ID de milestone invalido.",
  NOT_FOUND: "Milestone nao encontrado.",
  ALREADY_FINISHED: "Milestone ja finalizado.",
  SESSION_ERROR: "Erro ao criar sessao. Tente novamente.",
  EXPIRED_SESSION: "Sessao expirada. Reconectando...",
  UNKNOWN: "Erro de conexao. Tente novamente.",
};
```

3. Add helper function:
```typescript
export function getTerminalErrorMessage(code: string | null, fallback?: string): string {
  if (!code) return fallback || TERMINAL_ERROR_MESSAGES.UNKNOWN;
  return TERMINAL_ERROR_MESSAGES[code] || fallback || TERMINAL_ERROR_MESSAGES.UNKNOWN;
}
```
  </action>
  <verify>TypeScript compiles without errors: `cd frontend && npx tsc --noEmit`</verify>
  <done>ConnectionState type and error messages exported from terminal.ts</done>
</task>

<task type="auto">
  <name>Task 2: Extend useTerminalWebSocket hook with connection state</name>
  <files>frontend/src/hooks/useTerminalWebSocket.ts</files>
  <action>
Extend the hook to track and expose connection lifecycle state:

1. Import ConnectionState from types:
```typescript
import type {
  IncomingTerminalMessage,
  OutgoingTerminalMessage,
  ConnectionState,
} from "../types/terminal";
```

2. Add new fields to UseTerminalWebSocketReturn interface:
```typescript
export interface UseTerminalWebSocketReturn {
  // Existing fields remain unchanged
  isConnected: boolean;
  sessionId: string | null;
  connect: () => void;
  disconnect: () => void;
  sendInput: (data: string) => void;
  sendResize: (rows: number, cols: number) => void;
  sendSignal: (signal: "SIGINT" | "SIGTERM" | "EOF") => void;

  // NEW: Connection state for UI
  connectionState: ConnectionState;
  errorMessage: string | null;
  errorCode: string | null;
}
```

3. Add state hooks at the start of useTerminalWebSocket:
```typescript
const [connectionState, setConnectionState] = useState<ConnectionState>("idle");
const [errorMessage, setErrorMessage] = useState<string | null>(null);
const [errorCode, setErrorCode] = useState<string | null>(null);
const hadSessionRef = useRef(false); // Track if we had a session before (for resume detection)
```

4. Update connect function:
- Set connectionState to "connecting" at the start of connect()
- Clear errorMessage and errorCode when starting new connection

5. Update ws.onopen handler:
```typescript
ws.onopen = () => {
  console.log("[useTerminalWebSocket] Connected");
  isConnectingRef.current = false;
  retryCountRef.current = 0;
  setIsConnected(true);
  // Don't set connectionState here - wait for status message with session_id
};
```

6. Update ws.onmessage handler for "status" case:
```typescript
case "status":
  setSessionId(msg.session_id);
  if (msg.connected && msg.session_id) {
    // Detect resume scenario: we had a session before
    if (hadSessionRef.current) {
      setConnectionState("resuming");
      // Brief display of resuming message, then connected
      setTimeout(() => setConnectionState("connected"), 1000);
    } else {
      setConnectionState("connected");
    }
    hadSessionRef.current = true;
  }
  callbacksRef.current.onStatus?.(msg.connected, msg.session_id);
  break;
```

7. Update ws.onmessage handler for "error" case:
```typescript
case "error":
  console.error("[useTerminalWebSocket] Error:", msg.message, msg.code);
  // Don't call onError for NO_SESSION - we'll retry instead
  if (msg.code !== "NO_SESSION") {
    setErrorMessage(msg.message);
    setErrorCode(msg.code);
    setConnectionState("error");
    callbacksRef.current.onError?.(msg.message, msg.code);
  }
  break;
```

8. Update ws.onclose handler:
```typescript
ws.onclose = (event) => {
  console.log("[useTerminalWebSocket] Disconnected, code:", event.code);
  isConnectingRef.current = false;
  setIsConnected(false);
  setSessionId(null);
  wsRef.current = null;

  // Set disconnected state unless we're retrying
  if (event.code !== 4004) {
    setConnectionState("disconnected");
  }

  // ... rest of retry logic unchanged
};
```

9. Update disconnect function to reset connection state:
```typescript
const disconnect = useCallback(() => {
  shouldRetryRef.current = false;
  // ... existing cleanup ...
  setConnectionState("idle");
  setErrorMessage(null);
  setErrorCode(null);
  hadSessionRef.current = false; // Reset for next connection
}, []);
```

10. Add new fields to return object:
```typescript
return {
  isConnected,
  sessionId,
  connect,
  disconnect,
  sendInput,
  sendResize,
  sendSignal,
  // NEW
  connectionState,
  errorMessage,
  errorCode,
};
```
  </action>
  <verify>
1. TypeScript compiles: `cd frontend && npx tsc --noEmit`
2. Existing functionality preserved: hook still exports all original fields
  </verify>
  <done>useTerminalWebSocket returns connectionState, errorMessage, and errorCode fields</done>
</task>

</tasks>

<verification>
- [ ] `cd frontend && npx tsc --noEmit` passes without errors
- [ ] ConnectionState type exported from terminal.ts
- [ ] useTerminalWebSocket returns connectionState, errorMessage, errorCode
- [ ] Error codes map to user-friendly messages
</verification>

<success_criteria>
- Types and hook extended without breaking existing functionality
- connectionState accurately reflects WebSocket lifecycle
- Resume detection distinguishes first connection from session resume
- Error messages captured with codes for UI display
</success_criteria>

<output>
After completion, create `.planning/phases/29-session-lifecycle-frontend/29-01-SUMMARY.md`
</output>
