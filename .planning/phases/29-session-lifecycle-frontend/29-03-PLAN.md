---
phase: 29-session-lifecycle-frontend
plan: 03
type: execute
wave: 2
depends_on: ["29-01"]
files_modified:
  - frontend/src/contexts/TerminalSessionContext.tsx
  - frontend/src/contexts/index.ts
  - frontend/src/app/project/[id]/output-projects/[projectId]/layout.tsx
autonomous: true

must_haves:
  truths:
    - "User can navigate away from Output Project page and return without losing session"
    - "Terminal reconnects to existing session when returning to page"
    - "Session state preserved across sibling page navigations within Output Project"
  artifacts:
    - path: "frontend/src/contexts/TerminalSessionContext.tsx"
      provides: "Context for terminal session persistence across navigation"
      exports: ["TerminalSessionProvider", "useTerminalSession"]
    - path: "frontend/src/app/project/[id]/output-projects/[projectId]/layout.tsx"
      provides: "Layout wrapper with TerminalSessionProvider"
      contains: "TerminalSessionProvider"
  key_links:
    - from: "layout.tsx"
      to: "TerminalSessionContext"
      via: "Provider wrapper"
      pattern: "TerminalSessionProvider"
---

<objective>
Create TerminalSessionContext for session persistence across page navigation within Output Project.

Purpose: When user navigates between pages within an Output Project (e.g., viewing different milestones), the terminal session should persist. This prevents unnecessary reconnections and maintains Claude Code context continuity. Implements TERM-04 requirement.

Output: TerminalSessionContext provider, hook, and Output Project layout with provider.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/29-session-lifecycle-frontend/29-RESEARCH.md
@.planning/phases/29-session-lifecycle-frontend/29-01-SUMMARY.md

@frontend/src/app/project/[id]/output-projects/[projectId]/page.tsx
@frontend/src/types/terminal.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TerminalSessionContext</name>
  <files>frontend/src/contexts/TerminalSessionContext.tsx, frontend/src/contexts/index.ts</files>
  <action>
Create a new contexts directory (if needed) and TerminalSessionContext:

1. Create frontend/src/contexts/TerminalSessionContext.tsx:
```typescript
"use client";

/**
 * TerminalSessionContext - Preserves terminal session state across page navigation.
 *
 * Within an Output Project, users may navigate between milestone details,
 * file views, and settings. This context ensures the terminal session
 * persists across these navigations without unnecessary reconnections.
 */

import {
  createContext,
  useContext,
  useState,
  useCallback,
  ReactNode,
} from "react";
import type { ConnectionState } from "@/types/terminal";

interface TerminalSessionState {
  /** The output project ID for current session */
  outputProjectId: string | null;
  /** The milestone ID currently displayed in terminal */
  activeMilestoneId: string | null;
  /** Last known connection state */
  lastConnectionState: ConnectionState;
  /** Claude session ID (for reconnection) */
  claudeSessionId: string | null;
  /** Whether to attempt reconnection on next terminal mount */
  shouldReconnect: boolean;
}

interface TerminalSessionContextValue extends TerminalSessionState {
  /** Update the active output project */
  setOutputProject: (id: string | null) => void;
  /** Update the active milestone */
  setActiveMilestone: (id: string | null) => void;
  /** Update connection state */
  setConnectionState: (state: ConnectionState) => void;
  /** Store Claude session ID */
  setClaudeSessionId: (id: string | null) => void;
  /** Mark for reconnection on next mount */
  markForReconnection: () => void;
  /** Clear reconnection flag */
  clearReconnectionFlag: () => void;
  /** Reset all state (on project change) */
  reset: () => void;
}

const initialState: TerminalSessionState = {
  outputProjectId: null,
  activeMilestoneId: null,
  lastConnectionState: "idle",
  claudeSessionId: null,
  shouldReconnect: false,
};

const TerminalSessionContext = createContext<TerminalSessionContextValue | null>(
  null
);

export interface TerminalSessionProviderProps {
  children: ReactNode;
  /** Initial output project ID (from route params) */
  outputProjectId?: string;
}

export function TerminalSessionProvider({
  children,
  outputProjectId: initialProjectId,
}: TerminalSessionProviderProps) {
  const [state, setState] = useState<TerminalSessionState>({
    ...initialState,
    outputProjectId: initialProjectId || null,
  });

  const setOutputProject = useCallback((id: string | null) => {
    setState((prev) => {
      // If project changes, reset session state
      if (prev.outputProjectId !== id) {
        return { ...initialState, outputProjectId: id };
      }
      return prev;
    });
  }, []);

  const setActiveMilestone = useCallback((id: string | null) => {
    setState((prev) => ({ ...prev, activeMilestoneId: id }));
  }, []);

  const setConnectionState = useCallback((connectionState: ConnectionState) => {
    setState((prev) => ({ ...prev, lastConnectionState: connectionState }));
  }, []);

  const setClaudeSessionId = useCallback((id: string | null) => {
    setState((prev) => ({ ...prev, claudeSessionId: id }));
  }, []);

  const markForReconnection = useCallback(() => {
    setState((prev) => ({ ...prev, shouldReconnect: true }));
  }, []);

  const clearReconnectionFlag = useCallback(() => {
    setState((prev) => ({ ...prev, shouldReconnect: false }));
  }, []);

  const reset = useCallback(() => {
    setState(initialState);
  }, []);

  return (
    <TerminalSessionContext.Provider
      value={{
        ...state,
        setOutputProject,
        setActiveMilestone,
        setConnectionState,
        setClaudeSessionId,
        markForReconnection,
        clearReconnectionFlag,
        reset,
      }}
    >
      {children}
    </TerminalSessionContext.Provider>
  );
}

export function useTerminalSession() {
  const ctx = useContext(TerminalSessionContext);
  if (!ctx) {
    throw new Error(
      "useTerminalSession must be used within TerminalSessionProvider"
    );
  }
  return ctx;
}

export default TerminalSessionContext;
```

2. Create frontend/src/contexts/index.ts:
```typescript
export { TerminalSessionProvider, useTerminalSession } from "./TerminalSessionContext";
export type { TerminalSessionProviderProps } from "./TerminalSessionContext";
```
  </action>
  <verify>TypeScript compiles: `cd frontend && npx tsc --noEmit`</verify>
  <done>TerminalSessionContext created with session state management</done>
</task>

<task type="auto">
  <name>Task 2: Create Output Project layout with provider</name>
  <files>frontend/src/app/project/[id]/output-projects/[projectId]/layout.tsx</files>
  <action>
Create a layout.tsx file that wraps the Output Project pages with TerminalSessionProvider:

```typescript
"use client";

/**
 * Output Project Layout
 *
 * Wraps all Output Project pages with TerminalSessionProvider to preserve
 * terminal session state across navigation within the project.
 */

import { use } from "react";
import { TerminalSessionProvider } from "@/contexts";

interface OutputProjectLayoutProps {
  children: React.ReactNode;
  params: Promise<{ id: string; projectId: string }>;
}

export default function OutputProjectLayout({
  children,
  params,
}: OutputProjectLayoutProps) {
  const { projectId } = use(params);

  return (
    <TerminalSessionProvider outputProjectId={projectId}>
      {children}
    </TerminalSessionProvider>
  );
}
```

Key design decisions:
- Layout provides TerminalSessionProvider at the Output Project route level
- All pages under /project/[id]/output-projects/[projectId]/* share the same context
- projectId passed as initial value for context setup
- When navigating to different output project, new layout instance = fresh context
  </action>
  <verify>
1. TypeScript compiles: `cd frontend && npx tsc --noEmit`
2. Layout file exists at correct path
  </verify>
  <done>Output Project layout wraps pages with TerminalSessionProvider</done>
</task>

<task type="auto">
  <name>Task 3: Wire useTerminalSession into InteractiveTerminal</name>
  <files>frontend/src/components/terminal/InteractiveTerminal.tsx</files>
  <action>
Update InteractiveTerminal to use TerminalSessionContext for session persistence:

1. Add import:
```typescript
import { useTerminalSession } from "@/contexts";
```

2. Add try-catch wrapper for useTerminalSession (graceful fallback if used outside provider):
```typescript
// Inside component, after other hooks
let terminalSession: ReturnType<typeof useTerminalSession> | null = null;
try {
  terminalSession = useTerminalSession();
} catch {
  // Not inside TerminalSessionProvider - operate independently
}
```

3. Sync connection state to context when it changes (add useEffect after main effect):
```typescript
// Sync connection state to context for persistence
useEffect(() => {
  if (terminalSession) {
    terminalSession.setConnectionState(connectionState);
    if (sessionId) {
      terminalSession.setClaudeSessionId(sessionId);
    }
  }
}, [connectionState, sessionId, terminalSession]);
```

4. Check shouldReconnect on mount (add to main terminal effect, after requestAnimationFrame):
```typescript
// Inside requestAnimationFrame callback, after connect call:
if (terminalSession?.shouldReconnect) {
  terminalSession.clearReconnectionFlag();
}
```

5. Mark for reconnection on unmount (add to cleanup return):
```typescript
return () => {
  // ... existing cleanup ...

  // Mark for reconnection if we were connected
  if (terminalSession && connectionState === "connected") {
    terminalSession.markForReconnection();
  }
};
```

Note: connectionState needs to be captured in a ref to avoid stale closure:
```typescript
const connectionStateRef = useRef(connectionState);
connectionStateRef.current = connectionState;
```

Then in cleanup:
```typescript
if (terminalSession && connectionStateRef.current === "connected") {
  terminalSession.markForReconnection();
}
```
  </action>
  <verify>
1. TypeScript compiles: `cd frontend && npx tsc --noEmit`
2. No errors when used outside provider (graceful fallback)
  </verify>
  <done>InteractiveTerminal syncs state with TerminalSessionContext for navigation persistence</done>
</task>

</tasks>

<verification>
- [ ] `cd frontend && npx tsc --noEmit` passes without errors
- [ ] TerminalSessionContext.tsx exports provider and hook
- [ ] contexts/index.ts exports from TerminalSessionContext
- [ ] layout.tsx exists and wraps children with provider
- [ ] InteractiveTerminal syncs connectionState to context
- [ ] InteractiveTerminal gracefully handles missing provider
</verification>

<success_criteria>
- TERM-04: Session survives page navigation within Output Project
- Context correctly resets when navigating to different Output Project
- Terminal reconnects to same session when returning to page
- Works independently when used outside provider (e.g., in tests)
</success_criteria>

<output>
After completion, create `.planning/phases/29-session-lifecycle-frontend/29-03-SUMMARY.md`
</output>
