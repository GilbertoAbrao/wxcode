# Phase 20: Global State Extraction - Research

**Researched:** 2026-01-24
**Domain:** PromptBuilder CONTEXT.md generation with global variables from Project Code and WDG elements
**Confidence:** HIGH

## Summary

This phase adds global variable information to the CONTEXT.md file generated by PromptBuilder. The infrastructure partially exists:

1. **GlobalStateExtractor** (`parser/global_state_extractor.py`) already extracts GLOBAL declarations from WLanguage code with scope detection (APP, MODULE, REQUEST)
2. **GlobalStateContext** (`models/global_state_context.py`) provides an IR that aggregates variables from multiple sources
3. **Orchestrator._extract_global_state()** (`generator/orchestrator.py`) queries for `Element.windevType == 0` (Project Code) and `windevType == 31` (WDG)

**Critical Gap:** Project Code (the `code_elements` section with `type_code: 0` in .wwp files) is **NOT currently imported** as a separate Element. The current import only processes items from the `elements:` section (pages, procedures, classes). This means:
- Requirement GSTATE-01 requires **new import capability**
- The orchestrator's query `Element.windevType == 0` currently returns empty results

**Primary recommendation:** Modify the project import pipeline to extract and store Project Code as a special Element (windev_type=0), then extend PromptBuilder to format global variables using the existing GlobalStateExtractor infrastructure.

## Current State Analysis

### What Already Works (HIGH confidence)

| Component | File | Status | Notes |
|-----------|------|--------|-------|
| GlobalStateExtractor | `parser/global_state_extractor.py` | Complete | Parses GLOBAL blocks, extracts variables with type/default |
| GlobalVariable dataclass | `parser/global_state_extractor.py` | Complete | name, wlanguage_type, default_value, scope, source |
| Scope enum | `parser/global_state_extractor.py` | Complete | APP (type=0), MODULE (type=31), REQUEST (type=38/60) |
| GlobalStateContext IR | `models/global_state_context.py` | Complete | Aggregates variables, provides filtering methods |
| InitializationBlock | `parser/global_state_extractor.py` | Complete | Captures init code after GLOBAL declarations |
| Orchestrator query pattern | `generator/orchestrator.py` | Reference | Lines 253-287 show query for type 0 and 31 |

### What's Missing

| Gap | Description | Requirement |
|-----|-------------|-------------|
| Project Code import | .wwp `code_elements` section not parsed during import | GSTATE-01 |
| Project Code Element | No Element with windev_type=0 stored in MongoDB | GSTATE-01 |
| PromptBuilder format | No method to format global variables as markdown | GSTATE-04 |
| Scope annotation | No mapping pattern documentation in template | GSTATE-05 |
| Global state extraction function | No async function like `extract_connections_for_project()` | GSTATE-02, GSTATE-03 |

## Architecture Patterns

### Current Project Import Flow
```
project_mapper.py
    |
    v
parse .wwp file
    |
    v
extract items from "elements:" section
    |
    v (for each element)
create Element with windev_type from file
    |
    v
store in MongoDB
```

The `code_elements:` section with `type_code: 0` in .wwp is **completely ignored**.

### Required Flow
```
project_mapper.py (MODIFIED)
    |
    v
parse .wwp file
    |
    +---> extract items from "elements:" section (existing)
    |
    +---> extract "code_elements:" section with type_code=0 (NEW)
              |
              v
          create special Element with windev_type=0
          sourceName = "{project_name}_ProjectCode"
          rawContent = code from p_codes[0].code
    |
    v
store all Elements in MongoDB
```

### Global State Extraction Flow (for PromptBuilder)
```
schema_extractor.py (ADD new function)
    |
    v
extract_global_state_for_project(project_id)
    |
    v
Query Elements where windevType in [0, 31]
    |
    v
For each element with rawContent:
    GlobalStateExtractor.extract_variables(rawContent, type, source)
    |
    v
Return GlobalStateContext with all variables
```

### PromptBuilder Integration Flow
```
output_projects.py API
    |
    v
extract_schema_for_configuration() (existing)
extract_connections_for_project() (existing)
extract_global_state_for_project() (NEW)
    |
    v (all data)
PromptBuilder.write_context_file(
    output_project, stack, tables,
    connections=connections,
    global_state=global_state  # NEW
)
    |
    v
CONTEXT.md with tables + connections + global_state
```

### Recommended Project Structure Changes

Modifications to existing files:

```
src/wxcode/
├── parser/
│   └── project_mapper.py         # Add Project Code extraction
├── services/
│   ├── schema_extractor.py       # Add extract_global_state_for_project()
│   └── prompt_builder.py         # Extend template with global state section
└── api/
    └── output_projects.py        # Call new extractor and pass to PromptBuilder
```

## Standard Stack

This phase uses only existing project infrastructure:

| Component | Version | Purpose | Already in Project |
|-----------|---------|---------|-------------------|
| Beanie | 1.x | MongoDB ODM for Element queries | Yes |
| GlobalStateExtractor | - | Parse GLOBAL declarations | Yes |
| GlobalStateContext | - | Aggregate variables from sources | Yes |
| PromptBuilder | - | Template generation | Yes |

No new dependencies required.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| GLOBAL block parsing | Custom regex in PromptBuilder | `GlobalStateExtractor.extract_variables()` | Already handles multi-var declarations, default values, type parsing |
| Variable aggregation | Manual list management | `GlobalStateContext.from_extractor_results()` | Already provides filtering by scope/source |
| Scope determination | Manual type_code checks | `GlobalStateExtractor._determine_scope()` | Already maps type codes to Scope enum |
| Element query pattern | Custom query building | Follow `orchestrator._extract_global_state()` pattern | Already knows correct type codes |

**Key insight:** The GlobalStateExtractor is production-ready. The work is wiring it to import and PromptBuilder, not building new extraction logic.

## Common Pitfalls

### Pitfall 1: Project Code Not In Elements List
**What goes wrong:** Expecting `code_elements` to be part of `elements:` section
**Why it happens:** Project Code is embedded in .wwp top-level structure, not listed as an element
**How to avoid:** Parse `code_elements` section separately in project_mapper after `_process_elements_line()`
**Warning signs:** `Element.find(windevType=0)` returns empty results

### Pitfall 2: Multiple code_elements Sections
**What goes wrong:** Assuming single code_elements section
**Why it happens:** WinDev may have multiple p_codes entries in code_elements
**How to avoid:** Iterate through all p_codes entries, not just first one
**Warning signs:** Missing constants or globals that appear in .wwp file

### Pitfall 3: COMPILE IF Blocks in Global Code
**What goes wrong:** Including configuration-specific code without context
**Why it happens:** Project Code uses `<COMPILE IF Configuration="X">` for environment-specific init
**How to avoid:** Document that init code contains compile conditionals (Phase 21 handles this)
**Warning signs:** Connection settings hardcoded in global state output

### Pitfall 4: Large Global State Token Budget
**What goes wrong:** Exceeding token budget with extensive global declarations
**Why it happens:** Real projects may have 50+ global variables with long type names
**How to avoid:** Consider scope filtering (APP scope most important), table format compact
**Warning signs:** CONTEXT.md global state section > 500 lines

### Pitfall 5: Sensitive Data in Global Variables
**What goes wrong:** Including API keys, passwords in CONTEXT.md
**Why it happens:** WinDev globals may contain sensitive defaults (gsAccessToken, etc.)
**How to avoid:** Flag variables with sensitive naming patterns; show type but redact default values for sensitive-looking names
**Warning signs:** Variable names containing "token", "secret", "password", "key"

## Code Examples

### GlobalVariable Structure (existing)
```python
# Source: src/wxcode/parser/global_state_extractor.py lines 22-46
@dataclass
class GlobalVariable:
    name: str                    # "gCnn", "gnTimeout"
    wlanguage_type: str          # "Connection", "int", "JSON"
    default_value: str | None    # "20", None
    scope: Scope                 # APP, MODULE, REQUEST
    source_element: str          # "Linkpay_ADM.wwp"
    source_type_code: int        # 0, 31, 38
```

### Scope Enum (existing)
```python
# Source: src/wxcode/parser/global_state_extractor.py lines 13-18
class Scope(Enum):
    APP = "app"        # Project Code (type_code: 0) -> env vars / settings
    MODULE = "module"  # WDG (type_code: 31) -> module-level singletons
    REQUEST = "request"  # Page (type_code: 38, 60) -> request context
```

### Orchestrator Pattern for Querying Elements (existing)
```python
# Source: src/wxcode/generator/orchestrator.py lines 253-271
# Query Project Code (type_code: 0)
project_elements = await Element.find(
    Element.projectId == ObjectId(self.project_id),
    Element.windevType == 0,  # Project Code
).to_list()

# Query WDGs (type_code: 31)
wdg_elements = await Element.find(
    Element.projectId == ObjectId(self.project_id),
    Element.windevType == 31,  # WDG
).to_list()

# Extract from each element
for elem in project_elements:
    if elem.rawContent:
        variables = extractor.extract_variables(
            elem.rawContent, elem.windevType, elem.sourceName
        )
```

### Pattern: Format Global Variables as Markdown Table
```python
# Recommended implementation pattern
@staticmethod
def format_global_state(global_state: GlobalStateContext) -> str:
    """Format global variables as markdown table with scope annotations."""
    if not global_state or not global_state.variables:
        return "*No global variables defined.*"

    lines = []
    lines.append("| Variable | Type | Default | Scope | Recommended Mapping |")
    lines.append("|----------|------|---------|-------|---------------------|")

    # Group by scope for better organization
    for var in global_state.variables:
        # Redact sensitive-looking defaults
        default = var.default_value or "*none*"
        if _is_sensitive_name(var.name):
            default = "*[REDACTED]*"

        # Recommend mapping based on scope
        mapping = _scope_to_mapping(var.scope)

        lines.append(
            f"| {var.name} | {var.wlanguage_type} | {default} | {var.scope.value} | {mapping} |"
        )

    return "\n".join(lines)

def _scope_to_mapping(scope: Scope) -> str:
    """Map WinDev scope to Python pattern."""
    return {
        Scope.APP: "Environment variable / Settings class",
        Scope.MODULE: "Module-level singleton / DI container",
        Scope.REQUEST: "Request context / Depends()",
    }.get(scope, "Unknown")

def _is_sensitive_name(name: str) -> bool:
    """Detect potentially sensitive variable names."""
    sensitive_patterns = ["token", "secret", "password", "key", "pwd", "auth"]
    name_lower = name.lower()
    return any(p in name_lower for p in sensitive_patterns)
```

### Pattern: Project Code Extraction in project_mapper
```python
# Recommended implementation pattern for project_mapper.py
async def _extract_project_code(self, project: Project) -> Optional[Element]:
    """
    Extract Project Code from code_elements section of .wwp file.

    The code_elements section with type_code=0 contains project-level
    constants, globals, and initialization code.
    """
    # Parse .wwp as YAML-like structure
    data = self._parse_wwp_structure()

    code_elements = data.get("code_elements", {})
    if not code_elements or code_elements.get("type_code") != 0:
        return None

    # Extract code from p_codes section
    p_codes = code_elements.get("p_codes", [])
    if not p_codes:
        return None

    # Combine all p_codes into single rawContent
    raw_content_parts = []
    for p_code in p_codes:
        if isinstance(p_code, dict) and "code" in p_code:
            raw_content_parts.append(p_code["code"])

    if not raw_content_parts:
        return None

    raw_content = "\n".join(raw_content_parts)

    return Element(
        project_id=project.id,
        source_type=ElementType.UNKNOWN,  # Special type for Project Code
        source_name=f"{project.name}_ProjectCode",
        source_file=self.file_path.name,
        windev_type=0,  # Project Code marker
        raw_content=raw_content,
        dependencies=ElementDependencies(),
        conversion=ElementConversion(),
    )
```

## Scope Mapping Pattern

WinDev global scopes map to Python patterns as follows:

| WinDev Scope | type_code | Python Pattern | Example |
|--------------|-----------|----------------|---------|
| APP (Project Code) | 0 | `os.environ`, `pydantic.BaseSettings`, Config file | `gCnn` -> `settings.DB_CONNECTION` |
| MODULE (WDG) | 31 | Module singleton, FastAPI `Depends()`, DI container | `gHttpClient` -> `get_http_client()` |
| REQUEST (Page) | 38, 60 | Request context, middleware, `Depends()` | `gCurrentUser` -> `request.state.user` |

**Documentation Pattern for CONTEXT.md:**
```markdown
## Global State Conversion Patterns

| Original Scope | Recommended Python Pattern |
|----------------|---------------------------|
| APP (Project Code) | Environment variables via `pydantic.BaseSettings` |
| MODULE (Set of Procedures) | FastAPI dependency injection or module-level singleton |
| REQUEST (Page-level) | Request context via `request.state` or `Depends()` |

### Example Conversions

**Connection globals (`gCnn is Connection`):**
- Use `DATABASE_URL` environment variable
- Configure in `app/core/config.py` as Settings field
- Inject via `Depends(get_db_session)`

**JSON parameter globals (`gjParametros is JSON`):**
- Move to Settings class if static configuration
- Use request context if per-request data
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Ignore Project Code during import | Should parse code_elements section | Phase 20 | Enables global state extraction |
| Manual global detection in pages | Use GlobalStateExtractor with type awareness | Existing | Consistent extraction across elements |

## Open Questions

### 1. Project Code Source Name Convention
**What we know:** Need unique source_name for Project Code element
**What's unclear:** Best naming convention for synthetic element
**Recommendation:** Use `{project_name}_ProjectCode` (e.g., "Linkpay_ADM_ProjectCode")

### 2. WDG Global Variables Scope
**What we know:** WDG files have GLOBAL declarations (type=31 -> MODULE scope)
**What's unclear:** Whether to include all WDG globals or only "common" ones
**Recommendation:** Include all WDG globals; Claude can filter by relevance

### 3. Sensitive Variable Detection
**What we know:** Some globals contain tokens, secrets
**What's unclear:** Comprehensive list of sensitive patterns
**Recommendation:** Use conservative pattern matching: token, secret, password, key, auth, pwd

## Implementation Plan

### Task 1: Add Project Code extraction to project_mapper
**File:** `src/wxcode/parser/project_mapper.py`

1. Add method `_extract_project_code_element()` that:
   - Parses `code_elements` section from .wwp
   - Creates Element with windev_type=0
   - Sets source_name = `{project_name}_ProjectCode`
   - Stores rawContent from p_codes

2. Call after elements are processed in `map_project()`:
   - After `await self._save_batch(project)` final call
   - Create Project Code element
   - Save to MongoDB

### Task 2: Add global state extraction function
**File:** `src/wxcode/services/schema_extractor.py`

Add `extract_global_state_for_project()`:
```python
async def extract_global_state_for_project(
    project_id: PydanticObjectId,
) -> GlobalStateContext:
    """Extract global variables from Project Code and WDG elements."""
    # Query elements with windevType in [0, 31]
    # Use GlobalStateExtractor on each
    # Return aggregated GlobalStateContext
```

### Task 3: Extend PromptBuilder
**File:** `src/wxcode/services/prompt_builder.py`

1. Add `format_global_state()` static method
2. Add `format_scope_patterns()` static method
3. Extend `PROMPT_TEMPLATE` with Global State section
4. Update `build_context()` to accept `global_state` parameter
5. Update `write_context_file()` signature

### Task 4: Update API to extract and pass global state
**File:** `src/wxcode/api/output_projects.py`

1. Import `extract_global_state_for_project`
2. Call after connection extraction
3. Pass global_state to PromptBuilder

## Success Criteria Verification

| Requirement | How to Verify |
|-------------|---------------|
| GSTATE-01: Project Code parsed during import | Query `Element.find(windevType=0)` returns element with rawContent |
| GSTATE-02: Extract from Project Code | `extract_global_state_for_project()` returns variables with scope=APP |
| GSTATE-03: Extract from WDG | `extract_global_state_for_project()` returns variables with scope=MODULE |
| GSTATE-04: Global variables table in CONTEXT.md | Generated CONTEXT.md contains markdown table with name/type/default/scope |
| GSTATE-05: Mapping pattern documented | CONTEXT.md includes scope-to-pattern conversion table |

## Sources

### Primary (HIGH confidence)
- `src/wxcode/parser/global_state_extractor.py` - GlobalStateExtractor implementation
- `src/wxcode/models/global_state_context.py` - GlobalStateContext IR
- `src/wxcode/generator/orchestrator.py` lines 238-287 - Element query pattern
- `src/wxcode/parser/project_mapper.py` - Current import implementation
- `project-refs/Linkpay_ADM/Linkpay_ADM.wwp` lines 2440-2530 - Real Project Code example

### Secondary (MEDIUM confidence)
- Phase 19 research and implementation - Pattern for extending PromptBuilder

## Metadata

**Confidence breakdown:**
- Current state analysis: HIGH - direct code inspection
- Project Code import gap: HIGH - verified by code and .wwp file analysis
- Implementation plan: HIGH - follows established Phase 19 patterns
- Sensitive data handling: MEDIUM - pattern-based detection may miss edge cases

**Research date:** 2026-01-24
**Valid until:** 60 days (stable internal API, no external dependencies)
