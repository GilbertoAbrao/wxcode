---
phase: 20-global-state-extraction
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/wxcode/parser/project_mapper.py
  - src/wxcode/services/schema_extractor.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Project Code (type_code: 0) from .wwp code_elements section is stored as Element in MongoDB"
    - "Element query for windevType=0 returns Project Code element with rawContent containing GLOBAL declarations"
    - "extract_global_state_for_project() returns GlobalStateContext with variables from Project Code and WDG elements"
  artifacts:
    - path: "src/wxcode/parser/project_mapper.py"
      provides: "_extract_project_code_element() method and integration into map()"
      min_lines: 620
    - path: "src/wxcode/services/schema_extractor.py"
      provides: "extract_global_state_for_project() function"
      exports: ["extract_global_state_for_project"]
  key_links:
    - from: "src/wxcode/parser/project_mapper.py"
      to: "Element model"
      via: "creates Element with windev_type=0"
      pattern: "windev_type=0"
    - from: "src/wxcode/services/schema_extractor.py"
      to: "GlobalStateExtractor"
      via: "import and use extract_variables()"
      pattern: "GlobalStateExtractor"
    - from: "src/wxcode/services/schema_extractor.py"
      to: "GlobalStateContext"
      via: "returns GlobalStateContext.from_extractor_results()"
      pattern: "GlobalStateContext"
---

<objective>
Add Project Code import and global state extraction infrastructure.

Purpose: Project Code (code_elements section in .wwp with type_code=0) contains global constants, variables, and initialization code that converted projects need. This plan enables extraction of global state from both Project Code and WDG elements.

Output:
- project_mapper.py extracts code_elements section and creates Project Code Element
- schema_extractor.py has extract_global_state_for_project() function
- MongoDB stores Project Code elements with rawContent for global variable parsing
</objective>

<execution_context>
@/Users/gilberto/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gilberto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-global-state-extraction/20-RESEARCH.md

# Source files being modified
@src/wxcode/parser/project_mapper.py
@src/wxcode/services/schema_extractor.py

# Reference for existing extractors
@src/wxcode/parser/global_state_extractor.py
@src/wxcode/models/global_state_context.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Project Code extraction to project_mapper.py</name>
  <files>src/wxcode/parser/project_mapper.py</files>
  <action>
  Modify ProjectElementMapper to extract and store Project Code from the code_elements section of .wwp files.

  **Add new ParserState value** after existing states (around line 40):
  ```python
  IN_CODE_ELEMENTS = "in_code_elements"
  ```

  **Add new instance variables** in __init__ (after line 175):
  ```python
  self._code_elements_data: dict = {}
  self._code_elements_indent: int = -1
  self._in_code_block: bool = False
  self._code_block_content: list[str] = []
  ```

  **Add new method** `_extract_project_code_element()` after `_count_elements_by_type()`:
  ```python
  def _extract_project_code_element(self, project: Project) -> Optional[Element]:
      """
      Cria Element de Project Code a partir dos dados extraidos da secao code_elements.

      O Project Code contem constantes globais, variaveis globais e codigo de
      inicializacao que afeta todo o projeto.

      Args:
          project: Projeto pai

      Returns:
          Element com windev_type=0 se code_elements foi encontrado, None caso contrario
      """
      if not self._code_elements_data.get("code"):
          return None

      # type_code deve ser 0 para Project Code
      type_code = self._code_elements_data.get("type_code", 0)
      if type_code != 0:
          logger.warning(f"code_elements tem type_code={type_code}, esperado 0")
          return None

      raw_content = self._code_elements_data["code"]

      return Element(
          project_id=project.id,
          source_type=ElementType.UNKNOWN,  # Tipo especial para Project Code
          source_name=f"{project.name.split('_')[0]}_ProjectCode",  # Remove workspace suffix
          source_file=self.project_file.name,
          windev_type=0,  # Marcador de Project Code
          layer=ElementLayer.BUSINESS,  # Camada logica
          raw_content=raw_content,
          dependencies=ElementDependencies(),
          conversion=ElementConversion(),
      )
  ```

  **Modify _process_line()** to detect code_elements section. After the `elements :` detection block (around line 345), add:
  ```python
  # Detecta secao code_elements no nivel do projeto
  if ctx.stripped == "code_elements :" and ctx.indent < 3:
      self._state = ParserState.IN_CODE_ELEMENTS
      self._code_elements_indent = ctx.indent
      return
  ```

  **Add handler** in the process based on state section (after line 352):
  ```python
  elif self._state == ParserState.IN_CODE_ELEMENTS:
      self._process_code_elements_line(ctx)
  ```

  **Add new method** `_process_code_elements_line()` after `_process_element_line()`:
  ```python
  def _process_code_elements_line(self, ctx: LineContext):
      """Processa linha dentro da secao code_elements."""
      # Fim da secao (nova secao de mesmo nivel ou menor)
      if ctx.indent <= self._code_elements_indent and ctx.stripped and ":" in ctx.stripped:
          # Finaliza code block se estava em um
          if self._in_code_block and self._code_block_content:
              self._code_elements_data["code"] = "\n".join(self._code_block_content)
          self._state = ParserState.DONE
          return

      # Detecta inicio de code block (|1+ ou similar)
      if ctx.stripped.startswith("|"):
          self._in_code_block = True
          self._code_block_content = []
          return

      # Dentro do code block - acumula linhas
      if self._in_code_block:
          # Preserva conteudo original (com indentacao relativa)
          self._code_block_content.append(ctx.line.rstrip())
          return

      # Propriedades da code_elements
      if ctx.is_key_value:
          key, value = ctx.parse_key_value()
          if key == "type_code":
              self._code_elements_data["type_code"] = int(value) if value else 0
  ```

  **Modify map() method** to save Project Code element. After the final `await self._save_batch(project)` call (around line 205), add:
  ```python
  # Extrai e salva Project Code se existir
  project_code_element = self._extract_project_code_element(project)
  if project_code_element:
      await project_code_element.insert()
      self.stats.elements_saved += 1
      logger.info(f"Project Code element criado: {project_code_element.source_name}")
  ```

  **IMPORTANT:**
  - The code_elements section appears AFTER elements section in .wwp files (around line 2441 in Linkpay_ADM.wwp)
  - The code block starts with `|1+` marker and contains multiline WLanguage code
  - Preserve the full code content including GLOBAL declarations and initialization code
  - type_code=0 identifies Project Code specifically
  </action>
  <verify>
  ```bash
  cd /Users/gilberto/projetos/wxk/wxcode
  python -c "from wxcode.parser.project_mapper import ProjectElementMapper, ParserState; print('ParserState.IN_CODE_ELEMENTS:', 'IN_CODE_ELEMENTS' in [s.name for s in ParserState])"
  python -c "from wxcode.parser.project_mapper import ProjectElementMapper; print('_extract_project_code_element:', hasattr(ProjectElementMapper, '_extract_project_code_element'))"
  python -c "from wxcode.parser.project_mapper import ProjectElementMapper; print('_process_code_elements_line:', hasattr(ProjectElementMapper, '_process_code_elements_line'))"
  ```
  </verify>
  <done>
  - ParserState has IN_CODE_ELEMENTS value
  - ProjectElementMapper has _extract_project_code_element() method
  - ProjectElementMapper has _process_code_elements_line() method
  - After import, Element.find(windevType=0) will return Project Code element
  </done>
</task>

<task type="auto">
  <name>Task 2: Add global state extraction function to schema_extractor.py</name>
  <files>src/wxcode/services/schema_extractor.py</files>
  <action>
  Add extract_global_state_for_project() function that queries Project Code and WDG elements, uses GlobalStateExtractor on each, and returns aggregated GlobalStateContext.

  **Add imports** at top of file (after existing imports):
  ```python
  from wxcode.parser.global_state_extractor import GlobalStateExtractor
  from wxcode.models.global_state_context import GlobalStateContext
  ```

  **Add new function** at end of file after extract_connections_for_project():
  ```python
  async def extract_global_state_for_project(
      project_id: PydanticObjectId,
  ) -> GlobalStateContext:
      """
      Extrai variaveis globais de Project Code e elementos WDG.

      Consulta elementos com windevType em [0, 31] e usa GlobalStateExtractor
      para parsear declaracoes GLOBAL do codigo WLanguage.

      Args:
          project_id: ID do Knowledge Base (Project)

      Returns:
          GlobalStateContext com todas as variaveis globais agregadas
      """
      extractor = GlobalStateExtractor()
      all_variables = []
      all_init_blocks = []

      # Query Project Code (type_code: 0) e WDG (type_code: 31)
      elements = await Element.find(
          Element.project_id == project_id,
          {"windev_type": {"$in": [0, 31]}}
      ).to_list()

      for elem in elements:
          if not elem.raw_content:
              continue

          # Extrai variaveis globais
          variables = extractor.extract_variables(
              elem.raw_content,
              elem.windev_type or 0,
              elem.source_name,
          )
          all_variables.extend(variables)

          # Extrai blocos de inicializacao (apenas de Project Code)
          if elem.windev_type == 0:
              init_blocks = extractor.extract_initialization(elem.raw_content)
              all_init_blocks.extend(init_blocks)

      return GlobalStateContext.from_extractor_results(
          variables=all_variables,
          initialization_blocks=all_init_blocks,
      )
  ```

  **IMPORTANT:**
  - Use `{"windev_type": {"$in": [0, 31]}}` for MongoDB query (not Element.windevType)
  - GlobalStateExtractor is already production-ready - just use its methods
  - Initialization blocks only come from Project Code (type 0), not WDGs
  - The function follows the same pattern as extract_connections_for_project()
  </action>
  <verify>
  ```bash
  cd /Users/gilberto/projetos/wxk/wxcode
  python -c "from wxcode.services.schema_extractor import extract_global_state_for_project; print('Import OK')"
  python -c "
from wxcode.services.schema_extractor import extract_global_state_for_project
import inspect
sig = inspect.signature(extract_global_state_for_project)
print('Parameters:', list(sig.parameters.keys()))
print('Return annotation:', sig.return_annotation)
"
  ```
  </verify>
  <done>
  - extract_global_state_for_project() function exists and imports successfully
  - Function queries Elements with windev_type in [0, 31]
  - Function uses GlobalStateExtractor.extract_variables() on each element
  - Function returns GlobalStateContext with aggregated variables
  </done>
</task>

</tasks>

<verification>
Run full verification after both tasks:

```bash
cd /Users/gilberto/projetos/wxk/wxcode

# 1. Verify all imports work
python -c "
from wxcode.parser.project_mapper import ProjectElementMapper, ParserState
from wxcode.services.schema_extractor import extract_global_state_for_project
from wxcode.models.global_state_context import GlobalStateContext
print('All imports OK')
"

# 2. Verify ParserState has new value
python -c "
from wxcode.parser.project_mapper import ParserState
print('IN_CODE_ELEMENTS' in [s.name for s in ParserState])
"

# 3. Verify ProjectElementMapper has new methods
python -c "
from wxcode.parser.project_mapper import ProjectElementMapper
methods = ['_extract_project_code_element', '_process_code_elements_line']
for m in methods:
    print(f'{m}: {hasattr(ProjectElementMapper, m)}')
"

# 4. Run existing tests (should still pass)
pytest tests/test_project_mapper*.py -v 2>/dev/null || echo "No mapper tests or test passed"
```
</verification>

<success_criteria>
Requirements covered:

| Requirement | Verification |
|-------------|--------------|
| GSTATE-01: Project Code parsed during import | ProjectElementMapper extracts code_elements section with type_code=0 |
| GSTATE-02: Extract from Project Code | extract_global_state_for_project() queries windevType=0 elements |
| GSTATE-03: Extract from WDG | extract_global_state_for_project() queries windevType=31 elements |
</success_criteria>

<output>
After completion, create `.planning/phases/20-global-state-extraction/20-01-SUMMARY.md`
</output>
