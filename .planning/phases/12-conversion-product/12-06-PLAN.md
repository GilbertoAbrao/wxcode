---
phase: 12-conversion-product
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/hooks/useConversionStream.ts
  - frontend/src/app/project/[id]/products/[productId]/page.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "start() accepts element_names parameter"
    - "WebSocket start message includes element_names when provided"
    - "Product dashboard passes elementNames to stream.start()"
  artifacts:
    - path: "frontend/src/hooks/useConversionStream.ts"
      provides: "start() function with element_names parameter"
      min_lines: 5
      contains: "element_names"
    - path: "frontend/src/app/project/[id]/products/[productId]/page.tsx"
      provides: "Auto-start with elementNames passed"
      min_lines: 3
      contains: "stream.start(elementNames)"
  key_links:
    - from: "frontend/src/app/project/[id]/products/[productId]/page.tsx"
      to: "useConversionStream.start()"
      via: "function call with elementNames"
      pattern: "stream\\.start\\(elementNames\\)"
    - from: "useConversionStream.start()"
      to: "WebSocket message"
      via: "JSON.stringify with element_names"
      pattern: "element_names.*JSON\\.stringify"
---

<objective>
Fix element_names not being passed from wizard to conversion stream.

Purpose: Close blocker gap preventing conversion from starting with selected elements.
Output: Conversion starts with element selected in wizard.
</objective>

<execution_context>
@/Users/gilberto/projetos/wxk/wxcode/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gilberto/projetos/wxk/wxcode/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/gilberto/projetos/wxk/wxcode/.planning/PROJECT.md
@/Users/gilberto/projetos/wxk/wxcode/.planning/ROADMAP.md
@/Users/gilberto/projetos/wxk/wxcode/.planning/STATE.md
@/Users/gilberto/projetos/wxk/wxcode/.planning/phases/12-conversion-product/12-UAT.md
</context>

<tasks>

<task type="auto">
  <name>Modify start() to accept and send element_names</name>
  <files>frontend/src/hooks/useConversionStream.ts</files>
  <action>
Update the start() function in useConversionStream hook:

1. Change signature from `const start = useCallback(() => {` to `const start = useCallback((elementNames?: string[]) => {`

2. Update WebSocket message to include element_names:
   ```typescript
   wsRef.current.send(JSON.stringify({
     action: "start",
     element_names: elementNames
   }));
   ```

This matches the backend expectation where ConversionWizard.start() accepts element_names parameter.
  </action>
  <verify>
1. Check TypeScript compilation: `npm run build` in frontend directory
2. Grep for the updated signature: `grep -A 5 "const start = useCallback" frontend/src/hooks/useConversionStream.ts`
  </verify>
  <done>
- start() accepts optional elementNames parameter
- WebSocket message includes element_names field
- No TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Pass elementNames to stream.start() in dashboard</name>
  <files>frontend/src/app/project/[id]/products/[productId]/page.tsx</files>
  <action>
Update the auto-start useEffect in product dashboard (around line 114):

Change `stream.start();` to `stream.start(elementNames);`

This passes the elementNames extracted from URL query params to the WebSocket start message.

Context:
- elementNames is already parsed from URL query params (line ~69)
- Auto-start effect already checks elementNames.length > 0 (line ~110)
- Just need to pass the array to start()
  </action>
  <verify>
1. Check TypeScript compilation: `npm run build` in frontend directory
2. Grep for the call: `grep -B 2 -A 2 "stream.start" frontend/src/app/project/[id]/products/[productId]/page.tsx`
  </verify>
  <done>
- stream.start() receives elementNames array
- No TypeScript errors
- Auto-start flow complete: URL params -> start() -> WebSocket message
  </done>
</task>

</tasks>

<verification>
1. Build check: `cd frontend && npm run build` - no errors
2. Pattern check: Verify element_names flows from dashboard -> start() -> WebSocket
3. Gap closure: UAT Test 5 should now pass (conversion starts with selected element)
</verification>

<success_criteria>
- start() signature accepts optional elementNames parameter
- WebSocket start message includes element_names field
- Product dashboard passes elementNames to stream.start()
- Code compiles without TypeScript errors
- Element selected in wizard reaches backend conversion flow
</success_criteria>

<output>
After completion, create `.planning/phases/12-conversion-product/12-06-SUMMARY.md`
</output>
