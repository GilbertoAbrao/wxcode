---
phase: 12-conversion-product
plan: 04
type: execute
wave: 2
depends_on: ["12-01", "12-02"]
files_modified:
  - frontend/src/app/project/[id]/products/[productId]/page.tsx
  - frontend/src/components/conversion/ConversionProgress.tsx
  - frontend/src/components/conversion/PhaseCheckpoint.tsx
  - frontend/src/hooks/useConversionStream.ts
  - frontend/src/components/conversion/index.ts
autonomous: true

must_haves:
  truths:
    - "User sees real-time conversion output in terminal-like display"
    - "Checkpoint UI appears when phase completes"
    - "User can click 'Continuar' to resume conversion"
    - "Status badge reflects current product status"
  artifacts:
    - path: "frontend/src/app/project/[id]/products/[productId]/page.tsx"
      provides: "Product dashboard page with conversion view"
      min_lines: 100
    - path: "frontend/src/components/conversion/ConversionProgress.tsx"
      provides: "Terminal-like output display"
      min_lines: 50
    - path: "frontend/src/components/conversion/PhaseCheckpoint.tsx"
      provides: "Checkpoint review UI"
      min_lines: 40
    - path: "frontend/src/hooks/useConversionStream.ts"
      provides: "WebSocket hook for streaming"
      exports: ["useConversionStream"]
  key_links:
    - from: "products/[productId]/page.tsx"
      to: "useConversionStream hook"
      via: "WebSocket streaming"
      pattern: "useConversionStream"
    - from: "products/[productId]/page.tsx"
      to: "/api/products/{id}/resume"
      via: "resume button"
      pattern: "fetch.*resume"
---

<objective>
Create product dashboard with conversion progress and checkpoint UI.

Purpose: Shows real-time conversion output (CONV-05) and allows users to review and resume at checkpoints (CONV-06). The dashboard displays streaming output and checkpoint controls.

Output: Product dashboard page and conversion progress components.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-conversion-product/12-RESEARCH.md
@.planning/phases/12-conversion-product/12-01-SUMMARY.md
@.planning/phases/12-conversion-product/12-02-SUMMARY.md

# Existing patterns
@frontend/src/app/project/[id]/factory/page.tsx
@src/wxcode/api/conversions.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useConversionStream hook</name>
  <files>frontend/src/hooks/useConversionStream.ts</files>
  <action>
Create `frontend/src/hooks/useConversionStream.ts`:

```typescript
"use client";

import { useCallback, useEffect, useRef, useState } from "react";

export interface StreamMessage {
  type: "log" | "status" | "checkpoint" | "complete" | "error" | "ping";
  level?: string;
  message?: string;
  status?: string;
  checkpoint_type?: string;
  can_resume?: boolean;
  success?: boolean;
  exit_code?: number;
  content?: string;
  timestamp: string;
}

export interface ConversionStreamState {
  isConnected: boolean;
  isRunning: boolean;
  isPaused: boolean;
  isComplete: boolean;
  hasError: boolean;
  messages: StreamMessage[];
  lastCheckpoint: StreamMessage | null;
}

interface UseConversionStreamOptions {
  productId: string;
  autoConnect?: boolean;
  elementNames?: string[];
  onCheckpoint?: (message: StreamMessage) => void;
  onComplete?: (success: boolean) => void;
}

export function useConversionStream({
  productId,
  autoConnect = false,
  elementNames = [],
  onCheckpoint,
  onComplete,
}: UseConversionStreamOptions) {
  const wsRef = useRef<WebSocket | null>(null);
  const [state, setState] = useState<ConversionStreamState>({
    isConnected: false,
    isRunning: false,
    isPaused: false,
    isComplete: false,
    hasError: false,
    messages: [],
    lastCheckpoint: null,
  });

  // Connect to WebSocket
  const connect = useCallback(() => {
    if (wsRef.current?.readyState === WebSocket.OPEN) return;

    // Use the product ID as conversation ID for the WebSocket
    // The backend uses conversion_manager which tracks by ID
    const wsUrl = `${window.location.protocol === "https:" ? "wss:" : "ws:"}//${window.location.host}/api/conversions/ws/${productId}`;

    const ws = new WebSocket(wsUrl);
    wsRef.current = ws;

    ws.onopen = () => {
      setState((prev) => ({ ...prev, isConnected: true }));
    };

    ws.onmessage = (event) => {
      try {
        const message: StreamMessage = JSON.parse(event.data);

        // Skip ping messages
        if (message.type === "ping") return;

        setState((prev) => {
          const newState = { ...prev };

          // Add message to history
          newState.messages = [...prev.messages, message];

          // Update state based on message type
          switch (message.type) {
            case "status":
              if (message.status === "running") {
                newState.isRunning = true;
                newState.isPaused = false;
              } else if (message.status === "resuming") {
                newState.isRunning = true;
                newState.isPaused = false;
              }
              break;

            case "checkpoint":
              newState.isPaused = true;
              newState.isRunning = false;
              newState.lastCheckpoint = message;
              onCheckpoint?.(message);
              break;

            case "complete":
              newState.isComplete = true;
              newState.isRunning = false;
              newState.isPaused = false;
              newState.hasError = !message.success;
              onComplete?.(message.success ?? false);
              break;

            case "error":
              newState.hasError = true;
              break;
          }

          return newState;
        });
      } catch (e) {
        console.error("Failed to parse WebSocket message:", e);
      }
    };

    ws.onclose = () => {
      setState((prev) => ({ ...prev, isConnected: false }));
      wsRef.current = null;
    };

    ws.onerror = (error) => {
      console.error("WebSocket error:", error);
      setState((prev) => ({ ...prev, hasError: true }));
    };
  }, [productId, onCheckpoint, onComplete]);

  // Disconnect
  const disconnect = useCallback(() => {
    if (wsRef.current) {
      wsRef.current.close();
      wsRef.current = null;
    }
  }, []);

  // Start conversion
  const start = useCallback(() => {
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify({
        action: "start",
        element_names: elementNames,
      }));
      setState((prev) => ({ ...prev, isRunning: true }));
    }
  }, [elementNames]);

  // Resume conversion
  const resume = useCallback((message?: string) => {
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify({
        action: "resume",
        content: message,
      }));
      setState((prev) => ({
        ...prev,
        isRunning: true,
        isPaused: false,
        lastCheckpoint: null,
      }));
    }
  }, []);

  // Send message
  const sendMessage = useCallback((content: string) => {
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify({
        action: "message",
        content,
      }));
    }
  }, []);

  // Cancel
  const cancel = useCallback(() => {
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify({ action: "cancel" }));
    }
  }, []);

  // Auto-connect if enabled
  useEffect(() => {
    if (autoConnect) {
      connect();
    }
    return () => disconnect();
  }, [autoConnect, connect, disconnect]);

  return {
    ...state,
    connect,
    disconnect,
    start,
    resume,
    sendMessage,
    cancel,
  };
}

export default useConversionStream;
```
  </action>
  <verify>test -f frontend/src/hooks/useConversionStream.ts && echo "OK"</verify>
  <done>useConversionStream hook exists with WebSocket streaming and state management</done>
</task>

<task type="auto">
  <name>Task 2: Create ConversionProgress and PhaseCheckpoint components</name>
  <files>frontend/src/components/conversion/ConversionProgress.tsx, frontend/src/components/conversion/PhaseCheckpoint.tsx</files>
  <action>
Create `frontend/src/components/conversion/ConversionProgress.tsx`:

```typescript
"use client";

import { useEffect, useRef } from "react";
import { cn } from "@/lib/utils";
import type { StreamMessage } from "@/hooks/useConversionStream";

interface ConversionProgressProps {
  messages: StreamMessage[];
  isRunning: boolean;
  className?: string;
}

export function ConversionProgress({
  messages,
  isRunning,
  className,
}: ConversionProgressProps) {
  const containerRef = useRef<HTMLDivElement>(null);

  // Auto-scroll to bottom on new messages
  useEffect(() => {
    if (containerRef.current) {
      containerRef.current.scrollTop = containerRef.current.scrollHeight;
    }
  }, [messages]);

  // Filter to only show log messages
  const logMessages = messages.filter(
    (m) => m.type === "log" || m.type === "error"
  );

  return (
    <div
      ref={containerRef}
      className={cn(
        "bg-zinc-950 border border-zinc-800 rounded-lg p-4 font-mono text-sm overflow-y-auto",
        className
      )}
    >
      {logMessages.length === 0 ? (
        <div className="text-zinc-500 text-center py-8">
          {isRunning ? "Aguardando output..." : "Nenhum output ainda"}
        </div>
      ) : (
        <div className="space-y-1">
          {logMessages.map((msg, i) => (
            <div
              key={i}
              className={cn(
                "whitespace-pre-wrap break-words",
                msg.type === "error" || msg.level === "error"
                  ? "text-red-400"
                  : msg.level === "warning"
                  ? "text-amber-400"
                  : "text-zinc-300"
              )}
            >
              {msg.message || msg.content}
            </div>
          ))}
          {isRunning && (
            <div className="text-blue-400 animate-pulse">...</div>
          )}
        </div>
      )}
    </div>
  );
}

export default ConversionProgress;
```

Create `frontend/src/components/conversion/PhaseCheckpoint.tsx`:

```typescript
"use client";

import { motion } from "framer-motion";
import { CheckCircle2, Play, MessageSquare } from "lucide-react";
import type { StreamMessage } from "@/hooks/useConversionStream";

interface PhaseCheckpointProps {
  checkpoint: StreamMessage;
  onResume: (message?: string) => void;
  isResuming?: boolean;
}

export function PhaseCheckpoint({
  checkpoint,
  onResume,
  isResuming = false,
}: PhaseCheckpointProps) {
  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      className="bg-emerald-500/10 border border-emerald-500/30 rounded-xl p-6"
    >
      <div className="flex items-start gap-4">
        <div className="w-10 h-10 rounded-full bg-emerald-500/20 flex items-center justify-center flex-shrink-0">
          <CheckCircle2 className="w-5 h-5 text-emerald-400" />
        </div>

        <div className="flex-1">
          <h3 className="text-lg font-semibold text-emerald-100 mb-2">
            Fase Completada
          </h3>
          <p className="text-emerald-200/80 mb-4">
            {checkpoint.message || "Revise as mudancas antes de continuar."}
          </p>

          <div className="flex items-center gap-3">
            <motion.button
              onClick={() => onResume()}
              disabled={isResuming}
              whileHover={{ scale: 1.02 }}
              whileTap={{ scale: 0.98 }}
              className="px-4 py-2 bg-emerald-600 hover:bg-emerald-500 disabled:bg-zinc-700 text-white font-medium rounded-lg transition-colors flex items-center gap-2"
            >
              {isResuming ? (
                <>
                  <div className="w-4 h-4 border-2 border-white/30 border-t-white rounded-full animate-spin" />
                  Retomando...
                </>
              ) : (
                <>
                  <Play className="w-4 h-4" />
                  Continuar
                </>
              )}
            </motion.button>

            <span className="text-sm text-emerald-300/60">
              O assistente continuara de onde parou
            </span>
          </div>
        </div>
      </div>
    </motion.div>
  );
}

export default PhaseCheckpoint;
```

Update `frontend/src/components/conversion/index.ts`:

```typescript
export { ElementSelector } from "./ElementSelector";
export { ConversionProgress } from "./ConversionProgress";
export { PhaseCheckpoint } from "./PhaseCheckpoint";
```
  </action>
  <verify>test -f frontend/src/components/conversion/ConversionProgress.tsx && test -f frontend/src/components/conversion/PhaseCheckpoint.tsx && echo "OK"</verify>
  <done>ConversionProgress and PhaseCheckpoint components exist</done>
</task>

<task type="auto">
  <name>Task 3: Create product dashboard page</name>
  <files>frontend/src/app/project/[id]/products/[productId]/page.tsx</files>
  <action>
Create directory and page:

`mkdir -p frontend/src/app/project/[id]/products/[productId]`

Create `frontend/src/app/project/[id]/products/[productId]/page.tsx`:

```typescript
"use client";

import { use, useEffect, useState } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { useQuery, useQueryClient } from "@tanstack/react-query";
import { useProject } from "@/hooks/useProject";
import { useConversionStream } from "@/hooks/useConversionStream";
import { ConversionProgress, PhaseCheckpoint } from "@/components/conversion";
import {
  Loader2,
  ArrowLeft,
  Play,
  CheckCircle2,
  XCircle,
  PauseCircle,
  Clock,
} from "lucide-react";
import Link from "next/link";
import { motion } from "framer-motion";

interface ProductResponse {
  id: string;
  project_id: string;
  project_name: string;
  product_type: string;
  status: string;
  workspace_path: string;
  session_id: string | null;
  output_directory: string | null;
  created_at: string;
  updated_at: string;
}

interface PageProps {
  params: Promise<{ id: string; productId: string }>;
}

// Status badge component
function StatusBadge({ status }: { status: string }) {
  const config: Record<string, { icon: React.ComponentType<any>; color: string; label: string }> = {
    pending: { icon: Clock, color: "bg-zinc-500/20 text-zinc-400", label: "Pendente" },
    in_progress: { icon: Loader2, color: "bg-blue-500/20 text-blue-400", label: "Em andamento" },
    paused: { icon: PauseCircle, color: "bg-amber-500/20 text-amber-400", label: "Pausado" },
    completed: { icon: CheckCircle2, color: "bg-emerald-500/20 text-emerald-400", label: "Concluido" },
    failed: { icon: XCircle, color: "bg-red-500/20 text-red-400", label: "Falhou" },
  };

  const { icon: Icon, color, label } = config[status] || config.pending;

  return (
    <div className={`inline-flex items-center gap-1.5 px-2.5 py-1 rounded-full text-sm ${color}`}>
      <Icon className={`w-4 h-4 ${status === "in_progress" ? "animate-spin" : ""}`} />
      {label}
    </div>
  );
}

export default function ProductDashboardPage({ params }: PageProps) {
  const { id: projectId, productId } = use(params);
  const router = useRouter();
  const searchParams = useSearchParams();
  const queryClient = useQueryClient();

  // Get element names from query params (passed from wizard)
  const elementNamesParam = searchParams.get("elements");
  const elementNames = elementNamesParam ? elementNamesParam.split(",") : [];

  // State
  const [hasStarted, setHasStarted] = useState(false);

  // Fetch project
  const { data: project, isLoading: projectLoading } = useProject(projectId);

  // Fetch product
  const { data: product, isLoading: productLoading } = useQuery<ProductResponse>({
    queryKey: ["product", productId],
    queryFn: async () => {
      const res = await fetch(`/api/products/${productId}`);
      if (!res.ok) throw new Error("Failed to fetch product");
      return res.json();
    },
    refetchInterval: 5000, // Refetch every 5s to catch status changes
  });

  // WebSocket streaming
  const stream = useConversionStream({
    productId,
    autoConnect: true,
    elementNames,
    onCheckpoint: (msg) => {
      // Refetch product to get updated status
      queryClient.invalidateQueries({ queryKey: ["product", productId] });
    },
    onComplete: (success) => {
      queryClient.invalidateQueries({ queryKey: ["product", productId] });
    },
  });

  // Auto-start if product is pending and we have elements
  useEffect(() => {
    if (
      stream.isConnected &&
      !hasStarted &&
      product?.status === "pending" &&
      elementNames.length > 0
    ) {
      // Small delay to ensure connection is stable
      const timer = setTimeout(() => {
        stream.start();
        setHasStarted(true);
      }, 500);
      return () => clearTimeout(timer);
    }
  }, [stream.isConnected, hasStarted, product?.status, elementNames, stream]);

  // Handle resume
  const handleResume = async (message?: string) => {
    // First call the resume API endpoint
    try {
      await fetch(`/api/products/${productId}/resume`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ user_message: message }),
      });
    } catch (e) {
      console.error("Resume API call failed:", e);
    }

    // Then resume via WebSocket
    stream.resume(message);
  };

  // Loading state
  if (projectLoading || productLoading) {
    return (
      <div className="flex items-center justify-center h-full bg-zinc-950">
        <Loader2 className="w-8 h-8 text-zinc-500 animate-spin" />
      </div>
    );
  }

  // Product not found
  if (!product) {
    return (
      <div className="flex flex-col items-center justify-center h-full bg-zinc-950">
        <XCircle className="w-12 h-12 text-red-400 mb-4" />
        <p className="text-zinc-400">Produto nao encontrado</p>
        <Link
          href={`/project/${projectId}/factory`}
          className="mt-4 text-blue-400 hover:text-blue-300"
        >
          Voltar para produtos
        </Link>
      </div>
    );
  }

  return (
    <div className="max-w-4xl mx-auto p-8 bg-zinc-950 min-h-full">
      {/* Header */}
      <div className="flex items-start justify-between mb-8">
        <div>
          <Link
            href={`/project/${projectId}/factory`}
            className="inline-flex items-center gap-2 text-sm text-zinc-400 hover:text-zinc-100 transition-colors mb-4"
          >
            <ArrowLeft className="w-4 h-4" />
            Voltar
          </Link>

          <h1 className="text-2xl font-bold text-zinc-100 mb-2">
            Conversao FastAPI
          </h1>
          <p className="text-zinc-400">
            {elementNames.length > 0
              ? `Convertendo: ${elementNames.join(", ")}`
              : "Conversao em andamento"}
          </p>
        </div>

        <StatusBadge status={product.status} />
      </div>

      {/* Checkpoint UI (when paused) */}
      {stream.isPaused && stream.lastCheckpoint && (
        <div className="mb-6">
          <PhaseCheckpoint
            checkpoint={stream.lastCheckpoint}
            onResume={handleResume}
            isResuming={stream.isRunning}
          />
        </div>
      )}

      {/* Conversion Progress */}
      <div className="mb-6">
        <h2 className="text-lg font-semibold text-zinc-100 mb-3">
          Output do Assistente
        </h2>
        <ConversionProgress
          messages={stream.messages}
          isRunning={stream.isRunning}
          className="h-96"
        />
      </div>

      {/* Manual start button (if not auto-started) */}
      {product.status === "pending" && !hasStarted && elementNames.length === 0 && (
        <motion.button
          onClick={() => {
            stream.start();
            setHasStarted(true);
          }}
          disabled={!stream.isConnected}
          whileHover={{ scale: 1.02 }}
          whileTap={{ scale: 0.98 }}
          className="w-full py-3 px-4 bg-blue-600 hover:bg-blue-500 disabled:bg-zinc-800 disabled:text-zinc-500 text-white font-medium rounded-lg transition-colors flex items-center justify-center gap-2"
        >
          <Play className="w-4 h-4" />
          Iniciar Conversao
        </motion.button>
      )}

      {/* Completed state */}
      {stream.isComplete && (
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          className={`p-6 rounded-xl ${
            stream.hasError
              ? "bg-red-500/10 border border-red-500/30"
              : "bg-emerald-500/10 border border-emerald-500/30"
          }`}
        >
          <div className="flex items-center gap-3">
            {stream.hasError ? (
              <XCircle className="w-6 h-6 text-red-400" />
            ) : (
              <CheckCircle2 className="w-6 h-6 text-emerald-400" />
            )}
            <div>
              <h3 className={`font-semibold ${stream.hasError ? "text-red-100" : "text-emerald-100"}`}>
                {stream.hasError ? "Conversao falhou" : "Conversao concluida"}
              </h3>
              <p className={`text-sm ${stream.hasError ? "text-red-200/80" : "text-emerald-200/80"}`}>
                {stream.hasError
                  ? "Verifique o output acima para detalhes do erro"
                  : "Os arquivos foram gerados no workspace do projeto"}
              </p>
            </div>
          </div>
        </motion.div>
      )}

      {/* Connection status */}
      <div className="mt-4 text-center text-xs text-zinc-500">
        {stream.isConnected ? (
          <span className="text-emerald-500">Conectado</span>
        ) : (
          <span className="text-amber-500">Desconectado</span>
        )}
        {" â€¢ "}
        {stream.messages.length} mensagens
      </div>
    </div>
  );
}
```
  </action>
  <verify>test -f frontend/src/app/project/[id]/products/[productId]/page.tsx && echo "OK"</verify>
  <done>Product dashboard page exists with streaming output and checkpoint UI</done>
</task>

</tasks>

<verification>
1. Files exist: `ls frontend/src/app/project/[id]/products/[productId]/page.tsx`
2. Hook exists: `ls frontend/src/hooks/useConversionStream.ts`
3. Components exist: `ls frontend/src/components/conversion/`
4. Build check: `cd frontend && npm run build`
</verification>

<success_criteria>
- Product dashboard page renders at /project/[id]/products/[productId]
- Real-time streaming output displays in terminal-like component
- Checkpoint UI appears when phase completes
- "Continuar" button resumes conversion via WebSocket
- Status badge reflects current product status
</success_criteria>

<output>
After completion, create `.planning/phases/12-conversion-product/12-04-SUMMARY.md`
</output>
