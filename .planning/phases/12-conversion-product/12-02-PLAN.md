---
phase: 12-conversion-product
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/wxcode/api/conversions.py
autonomous: true

must_haves:
  truths:
    - "Phase completion patterns are detected in WebSocket output"
    - "Checkpoint message is sent to frontend when phase completes"
    - "n8n fallback works when webhook is unavailable"
    - "Product status updated to PAUSED on checkpoint"
  artifacts:
    - path: "src/wxcode/api/conversions.py"
      provides: "WebSocket handler with checkpoint detection"
      contains: "PHASE_COMPLETION_PATTERNS"
  key_links:
    - from: "conversions.py"
      to: "Product model"
      via: "status update on checkpoint"
      pattern: "ProductStatus\\.PAUSED"
---

<objective>
Add checkpoint detection and n8n fallback to conversions WebSocket handler.

Purpose: Enables conversion to pause at phase boundaries for user review (CONV-05) and ensures conversion works without n8n dependency (CONV-04). Users can review GSD phase output before continuing.

Output: Updated conversions.py with checkpoint detection in stream processing.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-conversion-product/12-RESEARCH.md

# Existing code to modify
@src/wxcode/api/conversions.py
@src/wxcode/models/product.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add checkpoint detection constants and helper</name>
  <files>src/wxcode/api/conversions.py</files>
  <action>
Add checkpoint detection constants after the imports section in `src/wxcode/api/conversions.py`:

```python
import re

# Phase completion patterns for checkpoint detection (CONV-05)
# These patterns indicate GSD phase boundaries where we should pause
PHASE_COMPLETION_PATTERNS = [
    r"## PHASE COMPLETE",
    r"## PLAN(?:NING)? COMPLETE",
    r"## RESEARCH COMPLETE",
    r"## VERIFICATION COMPLETE",
    r"### Phase \d+ Complete",
    r"Ready for next phase",
    r"Awaiting user confirmation",
    r"PLANNING COMPLETE",  # From plan-phase workflow
]

# Compile patterns for efficiency
_CHECKPOINT_REGEX = re.compile(
    "|".join(PHASE_COMPLETION_PATTERNS),
    re.IGNORECASE
)
```

Add checkpoint detection helper method to ConversionConnectionManager class:

```python
async def send_checkpoint(
    self,
    conversion_id: str,
    checkpoint_type: str,
    message: str,
    can_resume: bool = True,
):
    """
    Send checkpoint notification to frontend.

    Checkpoints pause the conversion for user review.
    """
    msg = {
        "type": "checkpoint",
        "checkpoint_type": checkpoint_type,
        "message": message,
        "can_resume": can_resume,
        "timestamp": datetime.utcnow().isoformat()
    }
    # Store in history
    self._add_to_history(conversion_id, msg)
    # Send to connected client
    ws = self.active_connections.get(conversion_id)
    if ws:
        try:
            await ws.send_json(msg)
        except Exception:
            pass
```
  </action>
  <verify>grep -q "PHASE_COMPLETION_PATTERNS" src/wxcode/api/conversions.py && echo "OK"</verify>
  <done>Checkpoint patterns and send_checkpoint method exist in conversions.py</done>
</task>

<task type="auto">
  <name>Task 2: Integrate checkpoint detection into stream processing</name>
  <files>src/wxcode/api/conversions.py</files>
  <action>
Modify the `process_line` function inside `stream_pty_output` (in both `invoke_with_streaming` within GSDInvoker and in the conversion streaming functions) to detect checkpoints.

In `run_conversion_with_streaming`, add checkpoint detection after processing each line. Update the function to:

1. Add product_id parameter to track which product to update
2. Check each line against checkpoint patterns
3. Send checkpoint message and update product status when detected

Add this helper function before `run_conversion_with_streaming`:

```python
async def check_and_handle_checkpoint(
    text: str,
    conversion_id: str,
    product_id: Optional[str] = None,
) -> bool:
    """
    Check if text indicates a phase boundary checkpoint.

    If checkpoint detected:
    1. Sends checkpoint message to frontend
    2. Updates product status to PAUSED (if product_id provided)

    Returns True if checkpoint detected (caller should pause).
    """
    if not _CHECKPOINT_REGEX.search(text):
        return False

    # Send checkpoint notification
    await conversion_manager.send_checkpoint(
        conversion_id,
        checkpoint_type="phase_complete",
        message="Fase completada. Revise as mudancas antes de continuar.",
        can_resume=True,
    )

    # Update product status if we have product_id
    if product_id:
        try:
            from wxcode.models.product import Product, ProductStatus
            from beanie import PydanticObjectId

            product = await Product.get(PydanticObjectId(product_id))
            if product:
                product.status = ProductStatus.PAUSED
                product.updated_at = datetime.utcnow()
                await product.save()
        except Exception as e:
            import logging
            logging.getLogger(__name__).warning(f"Failed to update product status: {e}")

    return True
```

Also ensure the n8n fallback in GSDInvoker's `send_chat` function works properly. The fallback already exists via `_send_fallback_chat`. Verify it's being called on HTTP errors by checking the try/except block handles httpx.HTTPError and httpx.TimeoutException.
  </action>
  <verify>grep -q "check_and_handle_checkpoint" src/wxcode/api/conversions.py && echo "OK"</verify>
  <done>Checkpoint detection integrated into WebSocket stream processing</done>
</task>

<task type="auto">
  <name>Task 3: Add product-aware conversion streaming</name>
  <files>src/wxcode/api/conversions.py</files>
  <action>
Create a new function `run_product_conversion_with_streaming` that uses ConversionWizard and is product-aware.

Add this function after `run_conversion_with_streaming`:

```python
async def run_product_conversion_with_streaming(
    product_id: str,
    product: "Product",
    project: Project,
    element_names: list[str],
    websocket: WebSocket,
):
    """
    Executa conversao de produto com streaming e deteccao de checkpoints.

    Diferente de run_conversion_with_streaming, esta funcao:
    1. Usa ConversionWizard para setup de workspace isolado
    2. Detecta checkpoints e pausa conversao
    3. Atualiza status do Product (nao Conversion)
    """
    from pathlib import Path
    from motor.motor_asyncio import AsyncIOMotorClient
    from wxcode.config import get_settings
    from wxcode.services.conversion_wizard import ConversionWizard, ConversionWizardError
    from wxcode.models.product import ProductStatus

    await conversion_manager.send_status(product_id, "running")
    await conversion_manager.send_log(product_id, "info", "Iniciando conversao de produto...")

    try:
        # Update product status
        product.status = ProductStatus.IN_PROGRESS
        product.started_at = datetime.utcnow()
        product.updated_at = datetime.utcnow()
        await product.save()

        # Get MongoDB client
        settings = get_settings()
        client = AsyncIOMotorClient(settings.mongodb_url)

        # Setup conversion workspace using wizard
        wizard = ConversionWizard(product, project)

        await conversion_manager.send_log(
            product_id, "info",
            f"Configurando workspace para: {', '.join(element_names)}"
        )

        try:
            conversion_dir = await wizard.setup_conversion_workspace(
                element_names=element_names,
                mongo_client=client,
                neo4j_conn=None,  # Neo4j optional
            )
        except ConversionWizardError as e:
            await conversion_manager.send_log(product_id, "error", str(e))
            product.status = ProductStatus.FAILED
            product.updated_at = datetime.utcnow()
            await product.save()
            await conversion_manager.send_complete(product_id, False, 1)
            return

        await conversion_manager.send_log(
            product_id, "info",
            f"Workspace configurado: {conversion_dir}"
        )

        # Get GSDInvoker with correct cwd
        invoker = wizard.get_gsd_invoker(conversion_dir)

        # Check Claude Code availability
        if not invoker.check_claude_code_available():
            await conversion_manager.send_log(
                product_id, "error",
                "Claude Code CLI nao encontrado. Instale com: npm install -g @anthropic-ai/claude-code"
            )
            product.status = ProductStatus.FAILED
            product.updated_at = datetime.utcnow()
            await product.save()
            await conversion_manager.send_complete(product_id, False, 1)
            return

        # Run with streaming
        def on_process_start(process):
            conversion_manager.active_processes[product_id] = process

        def on_process_end():
            conversion_manager.active_processes.pop(product_id, None)

        await conversion_manager.send_log(
            product_id, "info",
            "Iniciando Claude Code GSD workflow..."
        )

        exit_code = await invoker.invoke_with_streaming(
            websocket,
            product_id,
            on_process_start=on_process_start,
            on_process_end=on_process_end,
        )

        # Update product status based on result
        if exit_code == 0:
            product.status = ProductStatus.COMPLETED
            product.completed_at = datetime.utcnow()
            await product.save()
            await conversion_manager.send_complete(product_id, True, exit_code)
        else:
            product.status = ProductStatus.FAILED
            product.completed_at = datetime.utcnow()
            await product.save()
            await conversion_manager.send_complete(product_id, False, exit_code)

    except Exception as e:
        import traceback
        error_msg = f"Erro: {str(e)}"
        await conversion_manager.send_log(product_id, "error", error_msg)
        await conversion_manager.send_log(product_id, "error", traceback.format_exc())

        # Update product status
        try:
            product.status = ProductStatus.FAILED
            product.updated_at = datetime.utcnow()
            await product.save()
        except Exception:
            pass

        await conversion_manager.send_complete(product_id, False, 1)
```

This function will be called from the frontend via a new WebSocket endpoint (in Plan 03).
  </action>
  <verify>grep -q "run_product_conversion_with_streaming" src/wxcode/api/conversions.py && echo "OK"</verify>
  <done>Product-aware conversion streaming function exists with ConversionWizard integration</done>
</task>

</tasks>

<verification>
1. Pattern check: `grep "PHASE_COMPLETION_PATTERNS" src/wxcode/api/conversions.py`
2. Checkpoint method: `grep "send_checkpoint" src/wxcode/api/conversions.py`
3. Product conversion: `grep "run_product_conversion_with_streaming" src/wxcode/api/conversions.py`
4. Import check: `python -c "from wxcode.api.conversions import conversion_manager; print('OK')"`
</verification>

<success_criteria>
- PHASE_COMPLETION_PATTERNS constant exists
- send_checkpoint method exists in ConversionConnectionManager
- check_and_handle_checkpoint helper function exists
- run_product_conversion_with_streaming function exists
- n8n fallback already works via existing _send_fallback_chat
</success_criteria>

<output>
After completion, create `.planning/phases/12-conversion-product/12-02-SUMMARY.md`
</output>
