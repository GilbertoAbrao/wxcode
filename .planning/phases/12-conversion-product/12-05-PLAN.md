---
phase: 12-conversion-product
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - src/wxcode/api/products.py
  - src/wxcode/api/conversions.py
  - frontend/src/hooks/useConversionStream.ts
  - frontend/src/app/project/[id]/products/[productId]/page.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Conversion pauses at phase boundaries for user review (CONV-05)"
    - "User can resume paused conversion with claude --continue (CONV-06)"
  artifacts:
    - path: "src/wxcode/api/products.py"
      provides: "WebSocket endpoint for product conversions"
      contains: "@router.websocket"
    - path: "src/wxcode/api/conversions.py"
      provides: "Checkpoint detection in stream processing"
      contains: "check_and_handle_checkpoint"
    - path: "frontend/src/hooks/useConversionStream.ts"
      provides: "Product-aware WebSocket connection"
      contains: "/api/products/ws/"
  key_links:
    - from: "frontend useConversionStream"
      to: "/api/products/ws/{product_id}"
      via: "WebSocket URL construction"
      pattern: "api/products/ws"
    - from: "products.py websocket_product_stream"
      to: "run_product_conversion_with_streaming"
      via: "function call"
      pattern: "await run_product_conversion_with_streaming"
    - from: "run_product_conversion_with_streaming"
      to: "check_and_handle_checkpoint"
      via: "checkpoint detection in stream loop"
      pattern: "check_and_handle_checkpoint"
---

<objective>
Wire product WebSocket endpoint to existing streaming function with checkpoint detection.

Purpose: Close gaps preventing CONV-05 (checkpoints) and CONV-06 (resume) from working.
Output: Working end-to-end product conversion with pause/resume at phase boundaries.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-conversion-product/12-VERIFICATION.md

# Gap analysis shows:
# 1. run_product_conversion_with_streaming exists but is NEVER called (orphaned)
# 2. check_and_handle_checkpoint exists but is NEVER called (orphaned)
# 3. Frontend connects to /api/conversions/ws/{id} which expects Conversion model, not Product
# 4. Product dashboard passes productId but backend tries to load as Conversion

# Existing code to wire together:
@src/wxcode/api/conversions.py (lines 539-579: check_and_handle_checkpoint)
@src/wxcode/api/conversions.py (lines 756-879: run_product_conversion_with_streaming)
@src/wxcode/api/products.py (resume endpoint at lines 273-322)
@frontend/src/hooks/useConversionStream.ts (WebSocket URL at line 104)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add WebSocket endpoint to products.py</name>
  <files>src/wxcode/api/products.py</files>
  <action>
Add a new WebSocket endpoint at `/ws/{product_id}` that:

1. Add necessary imports at top of file (after existing imports from fastapi):
   - Add `WebSocket, WebSocketDisconnect` to the fastapi import
   - Add import: `from wxcode.api.conversions import conversion_manager, run_product_conversion_with_streaming`

2. Add WebSocket endpoint AFTER the `resume_product` endpoint (after line 322):
```python
@router.websocket("/ws/{product_id}")
async def websocket_product_stream(websocket: WebSocket, product_id: str):
    """
    WebSocket para streaming de conversao de produto.

    Diferente de /api/conversions/ws, este endpoint:
    1. Trabalha com Product (nao Conversion)
    2. Usa ConversionWizard para workspace isolado
    3. Suporta checkpoints com pausa automatica

    Protocolo:
    - Cliente conecta e recebe eventos
    - Servidor envia: {"type": "log", "level": "info|error", "message": "..."}
    - Servidor envia: {"type": "checkpoint", "checkpoint_type": "phase_complete", ...}
    - Servidor envia: {"type": "complete", "success": true/false}
    """
```

3. Inside the endpoint:
   - Accept WebSocket connection via `conversion_manager.connect(websocket, product_id)`
   - Load Product by ID (using PydanticObjectId)
   - Load Project from product.project_id
   - Handle `action: start` by calling `run_product_conversion_with_streaming`
   - Handle `action: resume` by calling resume workflow (via ConversionWizard)
   - Handle `action: cancel` to terminate process
   - Use same ping/timeout pattern as conversions.py websocket_conversion_stream

WHY: The existing WebSocket endpoint in conversions.py uses the Conversion model, not Product. Products need their own endpoint that uses ConversionWizard and isolated workspaces.
  </action>
  <verify>
# Check function exists
grep -n "async def websocket_product_stream" src/wxcode/api/products.py && \
# Check WebSocket import exists
grep -n "from fastapi import.*WebSocket" src/wxcode/api/products.py && \
# Check run_product_conversion_with_streaming import exists
grep -n "from wxcode.api.conversions import.*run_product_conversion_with_streaming" src/wxcode/api/products.py
  </verify>
  <done>WebSocket endpoint `/api/products/ws/{product_id}` exists with proper imports for WebSocket and run_product_conversion_with_streaming</done>
</task>

<task type="auto">
  <name>Task 2: Integrate checkpoint detection into stream processing</name>
  <files>src/wxcode/api/conversions.py</files>
  <action>
Modify `run_product_conversion_with_streaming` to call `check_and_handle_checkpoint` during stream processing.

1. Add the CheckpointWebSocket wrapper class INSIDE the function `run_product_conversion_with_streaming`, immediately after the `try:` block that starts around line 780 (find the pattern `try:` followed by `# Update product status`):

```python
# Wrapper to detect checkpoints in stream output
class CheckpointWebSocket:
    """Wrapper that detects phase boundaries and triggers checkpoints."""

    def __init__(self, ws: WebSocket, product_id: str):
        self._ws = ws
        self._product_id = product_id

    async def send_json(self, data: dict):
        await self._ws.send_json(data)

        # Check log messages for checkpoint patterns
        if data.get("type") == "log":
            msg = data.get("message", "")
            await check_and_handle_checkpoint(msg, self._product_id, self._product_id)

    # Forward other websocket methods
    async def accept(self):
        return await self._ws.accept()

    async def receive_json(self):
        return await self._ws.receive_json()

    async def close(self):
        return await self._ws.close()
```

2. Instantiate the wrapper BEFORE the `invoker.invoke_with_streaming` call. Find the pattern `exit_code = await invoker.invoke_with_streaming(` and add wrapper instantiation right before it:

```python
# Wrap websocket for checkpoint detection
checkpoint_ws = CheckpointWebSocket(websocket, product_id)
```

3. Replace `websocket` with `checkpoint_ws` in the invoke_with_streaming call. Change from:
```python
exit_code = await invoker.invoke_with_streaming(
    websocket,
    product_id,
```
To:
```python
exit_code = await invoker.invoke_with_streaming(
    checkpoint_ws,
    product_id,
```

WHY: check_and_handle_checkpoint exists but is never called. By wrapping the websocket, we intercept all messages and check for checkpoint patterns, triggering pauses when detected.
  </action>
  <verify>
# Check wrapper class exists
grep -n "class CheckpointWebSocket" src/wxcode/api/conversions.py && \
# Check wrapper is instantiated
grep -n "checkpoint_ws = CheckpointWebSocket" src/wxcode/api/conversions.py && \
# Check wrapper is used in invoke call
grep -n "invoke_with_streaming.*checkpoint_ws" src/wxcode/api/conversions.py
  </verify>
  <done>run_product_conversion_with_streaming defines, instantiates, and uses CheckpointWebSocket wrapper that calls check_and_handle_checkpoint</done>
</task>

<task type="auto">
  <name>Task 3: Update frontend to connect to product WebSocket endpoint</name>
  <files>frontend/src/hooks/useConversionStream.ts, frontend/src/app/project/[id]/products/[productId]/page.tsx</files>
  <action>
Modify useConversionStream to support both Conversion and Product endpoints:

1. In useConversionStream.ts, add endpointType to the UseConversionStreamOptions interface (find the interface around line 28):
```typescript
export interface UseConversionStreamOptions {
  // ... existing options
  /** Endpoint type: "conversion" uses /api/conversions/ws/, "product" uses /api/products/ws/ */
  endpointType?: "conversion" | "product";
}
```

2. In the hook function, destructure endpointType from options (find the destructuring around line 66, after `const { onMessage, ...`):
```typescript
const {
  // ... existing destructuring
  endpointType = "conversion",  // Default to conversion for backward compatibility
} = options;
```

3. REPLACE the hardcoded WebSocket URL construction. Find the line (around line 104):
```typescript
const wsUrl = `${wsProtocol}//${apiHost}/api/conversions/ws/${conversionId}`;
```

REPLACE it with conditional logic:
```typescript
const basePath = endpointType === "product"
  ? "/api/products/ws/"
  : "/api/conversions/ws/";
const wsUrl = `${wsProtocol}//${apiHost}${basePath}${conversionId}`;
```

Note: The conversionId variable name is reused for both conversion IDs and product IDs.

4. In the product dashboard page (page.tsx), find the useConversionStream call (around line 85):
```typescript
const stream = useConversionStream(productId, {
  autoConnect: true,
  autoStart: false,
```

Add the endpointType option:
```typescript
const stream = useConversionStream(productId, {
  autoConnect: true,
  autoStart: false,
  endpointType: "product",  // Add this line - connects to /api/products/ws/
  onCheckpoint: () => {
```

WHY: The frontend currently hardcodes /api/conversions/ws/{id} which expects a Conversion model. Product conversions need to connect to /api/products/ws/{product_id} which handles the Product model and workspace isolation.
  </action>
  <verify>
# Check interface has endpointType
grep -n 'endpointType.*"conversion".*"product"' frontend/src/hooks/useConversionStream.ts && \
# Check conditional URL construction (basePath pattern)
grep -n "basePath.*product" frontend/src/hooks/useConversionStream.ts && \
# Check product dashboard uses endpointType
grep -n 'endpointType.*product' frontend/src/app/project/[id]/products/[productId]/page.tsx
  </verify>
  <done>Frontend useConversionStream has endpointType option with conditional URL construction, product dashboard specifies endpointType: "product"</done>
</task>

</tasks>

<verification>
1. Backend WebSocket endpoint exists with proper imports:
   ```bash
   grep -n "websocket_product_stream" src/wxcode/api/products.py && \
   grep -n "from wxcode.api.conversions import.*run_product_conversion_with_streaming" src/wxcode/api/products.py
   ```

2. Checkpoint detection wired (wrapper defined, instantiated, and used):
   ```bash
   grep -n "class CheckpointWebSocket\|checkpoint_ws = CheckpointWebSocket\|invoke_with_streaming.*checkpoint_ws" src/wxcode/api/conversions.py
   ```

3. Frontend uses product endpoint with conditional URL:
   ```bash
   grep -n 'endpointType.*product\|basePath.*product' frontend/src/hooks/useConversionStream.ts frontend/src/app/project/[id]/products/[productId]/page.tsx
   ```

4. Run type checks:
   ```bash
   cd frontend && npx tsc --noEmit
   ```

5. Backend syntax check:
   ```bash
   python -c "from wxcode.api.products import router; from wxcode.api.conversions import run_product_conversion_with_streaming"
   ```
</verification>

<success_criteria>
- [ ] WebSocket endpoint `/api/products/ws/{product_id}` exists in products.py with WebSocket import
- [ ] products.py imports run_product_conversion_with_streaming from conversions
- [ ] CheckpointWebSocket class defined in run_product_conversion_with_streaming
- [ ] checkpoint_ws wrapper instantiated before invoke_with_streaming call
- [ ] invoke_with_streaming uses checkpoint_ws instead of raw websocket
- [ ] useConversionStream has endpointType option in interface
- [ ] useConversionStream has conditional basePath URL construction
- [ ] Product dashboard page uses endpointType: "product"
- [ ] No TypeScript errors in frontend
- [ ] No Python syntax errors in backend
</success_criteria>

<output>
After completion, create `.planning/phases/12-conversion-product/12-05-SUMMARY.md`
</output>
