# Stack Research: WinDev Initialization Context Extraction

**Project:** wxcode Initialization Context for PromptBuilder
**Researched:** 2026-01-24
**Overall confidence:** HIGH

## Executive Summary

This research focuses on extracting WinDev initialization context (database connections, global variables, Project Code, initialization blocks) to enrich CONTEXT.md generated by PromptBuilder. The existing wxcode stack already provides all necessary infrastructure - no new dependencies are needed. The work involves:

1. **Connection extraction** from existing `schemas.connections[]` (already populated by `xdd_parser.py`)
2. **Global state extraction** using existing `GlobalStateExtractor` (already implemented)
3. **Project Code parsing** from type_code: 0 elements in .wwp files
4. **PromptBuilder extension** to include new context sections

**Key finding:** All data sources already exist in MongoDB. This is purely an integration task using existing extractors and models.

## Recommended Stack Additions

### No New Dependencies Required

The existing wxcode stack provides everything needed:

| Existing Component | Location | Purpose for This Task |
|-------------------|----------|----------------------|
| `DatabaseSchema.connections[]` | `models/schema.py` | Connection details already parsed |
| `GlobalStateExtractor` | `parser/global_state_extractor.py` | GLOBAL declaration parsing |
| `GlobalStateContext` | `models/global_state_context.py` | IR for global variables |
| `WWPParser` | `parser/wwp_parser.py` | Project file parsing |
| `PromptBuilder` | `services/prompt_builder.py` | Target for integration |
| `schema_extractor` | `services/schema_extractor.py` | Pattern to follow |

## Implementation Strategy

### 1. Connection Extraction

**Source:** `DatabaseSchema.connections[]` in schemas collection

**Current state:** Already populated by `xdd_parser.py` lines 146-195. The `SchemaConnection` model includes:
- `name`, `source` (host), `port`, `database`, `user`, `driver_name`

**What to add:**

```python
# New function in services/schema_extractor.py

async def extract_connections_for_configuration(
    project_id: PydanticObjectId,
    configuration_id: Optional[str] = None,
) -> list[dict]:
    """
    Extrai conexoes de banco do schema.

    Returns:
        Lista de dicts com estrutura de conexoes:
        - name: Nome da conexao
        - host: Servidor (source)
        - port: Porta
        - database: Nome do banco
        - user: Usuario (se disponivel)
        - driver: Tipo do banco (sqlserver, mysql, etc)
    """
    schema = await DatabaseSchema.find_one(
        DatabaseSchema.project_id == project_id
    )
    if not schema or not schema.connections:
        return []

    return [
        {
            "name": conn.name,
            "host": conn.source,
            "port": conn.port,
            "database": conn.database,
            "user": conn.user,
            "driver": conn.database_type,
        }
        for conn in schema.connections
    ]
```

**Rationale:** Simple function following existing `extract_schema_for_configuration` pattern. No filtering by configuration needed since connections are project-wide.

### 2. Project Code Extraction

**Source:** .wwp file `code_elements` section with `type_code: 0`

**Current state:** `wwp_parser.py` parses the .wwp but does NOT extract Project Code. The parser focuses on element metadata, not the code sections.

**What to add:**

Option A: Extend WWPParser (RECOMMENDED)
```python
# Add to parser/wwp_parser.py

def _extract_project_code(self) -> Optional[str]:
    """
    Extrai o Project Code (type_code: 0) do arquivo .wwp.

    O Project Code contem:
    - Constantes globais (CONSTANT)
    - Declaracoes GLOBAL
    - Codigo de inicializacao

    Returns:
        Codigo raw do Project Code ou None
    """
    self._read_file()

    # Procura secao code_elements com type_code: 0
    in_code_elements = False
    in_p_codes = False
    code_lines = []

    for i, line in enumerate(self._lines):
        stripped = line.strip()

        if stripped == "code_elements :":
            in_code_elements = True
            continue

        if in_code_elements and stripped == "type_code : 0":
            # Encontrou Project Code
            continue

        if in_code_elements and stripped == "p_codes :":
            in_p_codes = True
            continue

        if in_p_codes and stripped.startswith("code : |1"):
            # Inicio do bloco de codigo
            # Coleta linhas ate proximo campo
            j = i + 1
            while j < len(self._lines):
                code_line = self._lines[j]
                if code_line.strip() and not code_line.startswith(" " * 6):
                    break
                code_lines.append(code_line.rstrip())
                j += 1
            break

    if code_lines:
        # Remove indentacao base
        return "\n".join(line[6:] if len(line) > 6 else "" for line in code_lines)
    return None
```

Option B: Store during import (BETTER LONG-TERM)
```python
# Modify parser/project_mapper.py to store Project Code as Element

# During import, create a special element for Project Code:
project_code_element = Element(
    project_id=project.id,
    source_type=ElementType.PROJECT_CODE,  # New enum value
    source_name=f"{project.name}_ProjectCode",
    source_file=project.source_path,
    windev_type=0,
    raw_content=project_code_content,
    layer=ElementLayer.BUSINESS,  # Initialization is business logic
)
```

**Recommendation:** Option A for immediate use, plan Option B for future. Option A avoids schema changes and is sufficient for milestone scope.

### 3. Global State Extraction

**Source:** Multiple - Project Code (type_code: 0), Set of Procedures (.wdg)

**Current state:** `GlobalStateExtractor` fully implemented but NOT integrated with PromptBuilder or any service.

**What to add:**

```python
# New function in services/global_state_service.py

from wxcode.parser.global_state_extractor import GlobalStateExtractor, Scope
from wxcode.models.global_state_context import GlobalStateContext

async def extract_global_state_for_project(
    project_id: PydanticObjectId,
    include_modules: bool = True,
) -> GlobalStateContext:
    """
    Extrai estado global de um projeto.

    Combina variaveis de:
    1. Project Code (type_code: 0) - escopo APP
    2. Set of Procedures (.wdg) - escopo MODULE (se include_modules=True)

    Args:
        project_id: ID do projeto
        include_modules: Se True, inclui variaveis de WDGs

    Returns:
        GlobalStateContext com todas as variaveis
    """
    extractor = GlobalStateExtractor()
    context = GlobalStateContext()

    # 1. Extrai do Project Code
    # (requer parser do .wwp ou elemento armazenado)
    project = await Project.get(project_id)
    wwp_parser = WWPParser(Path(project.source_path))
    project_code = wwp_parser._extract_project_code()

    if project_code:
        variables = extractor.extract_variables(
            code=project_code,
            type_code=0,
            source=project.name
        )
        init_blocks = extractor.extract_initialization(project_code)
        context = GlobalStateContext.from_extractor_results(variables, init_blocks)

    # 2. Extrai de WDGs (opcional)
    if include_modules:
        wdg_elements = await Element.find(
            Element.project_id == project_id,
            Element.source_type == ElementType.PROCEDURE_GROUP
        ).to_list()

        for wdg in wdg_elements:
            if wdg.raw_content:
                wdg_vars = extractor.extract_variables(
                    code=wdg.raw_content,
                    type_code=31,  # WDG type code
                    source=wdg.source_name
                )
                wdg_blocks = extractor.extract_initialization(wdg.raw_content)
                wdg_context = GlobalStateContext.from_extractor_results(wdg_vars, wdg_blocks)
                context = context.merge(wdg_context)

    return context
```

**Rationale:** Creates a service layer function that orchestrates existing components. Follows the same async pattern as other services.

### 4. PromptBuilder Extension

**Target:** Add new sections to CONTEXT.md template

**What to add:**

```python
# Extend PROMPT_TEMPLATE in services/prompt_builder.py

PROMPT_TEMPLATE = '''# Project Context for GSD

> **IMPORTANT: HEADLESS MODE**
> ...existing content...

## Project Information

- **Name:** {project_name}
- **Stack:** {stack_name}
- **Language:** {language}
- **Framework:** {framework}

## Database Connections

{database_connections}

## Global State

### App-Level Variables (Project Code)
{app_variables}

### Module-Level Variables (Set of Procedures)
{module_variables}

## Initialization Code

{initialization_code}

## Target Stack Characteristics
...existing content...
'''

# Extend build_context method signature
@classmethod
def build_context(
    cls,
    output_project: OutputProject,
    stack: Stack,
    tables: list[dict],
    connections: list[dict] = None,
    global_state: GlobalStateContext = None,
) -> str:
```

**New formatting methods:**

```python
@staticmethod
def format_connections(connections: list[dict]) -> str:
    """
    Formata conexoes como lista markdown.
    """
    if not connections:
        return "*No database connections defined.*"

    lines = []
    for conn in connections:
        lines.append(f"### {conn['name']}")
        lines.append(f"- **Host:** `{conn['host']}`")
        lines.append(f"- **Port:** `{conn['port']}`")
        lines.append(f"- **Database:** `{conn['database']}`")
        if conn.get('user'):
            lines.append(f"- **User:** `{conn['user']}`")
        lines.append(f"- **Driver:** `{conn['driver']}`")
        lines.append("")

    return "\n".join(lines)

@staticmethod
def format_global_variables(context: GlobalStateContext, scope: Scope) -> str:
    """
    Formata variaveis globais como tabela markdown.
    """
    variables = context.get_by_scope(scope)
    if not variables:
        return "*No variables in this scope.*"

    lines = ["| Variable | Type | Default | Source |",
             "|----------|------|---------|--------|"]
    for var in variables:
        default = var.default_value or "-"
        lines.append(f"| `{var.name}` | {var.wlanguage_type} | {default} | {var.source_element} |")

    return "\n".join(lines)

@staticmethod
def format_initialization_code(context: GlobalStateContext) -> str:
    """
    Formata blocos de inicializacao.
    """
    if not context.initialization_blocks:
        return "*No initialization code.*"

    lines = []
    for block in context.initialization_blocks:
        lines.append(f"**Order {block.order}** (uses: {', '.join(block.dependencies)})")
        lines.append("```wlanguage")
        lines.append(block.code[:500])  # Truncate for context
        if len(block.code) > 500:
            lines.append("... (truncated)")
        lines.append("```")
        lines.append("")

    return "\n".join(lines)
```

## Integration Flow

```
1. CLI/API calls gsd-context or milestone conversion
2. schema_extractor.extract_connections_for_configuration()  --> connections
3. global_state_service.extract_global_state_for_project()   --> GlobalStateContext
4. schema_extractor.extract_schema_for_configuration()       --> tables (existing)
5. PromptBuilder.build_context(
       output_project, stack, tables,
       connections=connections,
       global_state=global_state
   )
6. CONTEXT.md now includes initialization context
```

## File Changes Summary

| File | Change Type | Description |
|------|-------------|-------------|
| `services/schema_extractor.py` | ADD FUNCTION | `extract_connections_for_configuration()` |
| `parser/wwp_parser.py` | ADD METHOD | `_extract_project_code()` |
| `services/global_state_service.py` | NEW FILE | Orchestrates GlobalStateExtractor |
| `services/prompt_builder.py` | EXTEND | New template sections, new format methods |
| `models/element.py` | OPTIONAL | Add `ElementType.PROJECT_CODE` enum |

## Confidence Assessment

| Area | Confidence | Notes |
|------|------------|-------|
| Connection extraction from schema | HIGH | Data already in MongoDB, just need getter |
| Project Code parsing from .wwp | HIGH | Verified format in Linkpay_ADM.wwp |
| GlobalStateExtractor usage | HIGH | Already implemented and tested |
| PromptBuilder extension | HIGH | Simple template + formatting changes |
| No new dependencies needed | HIGH | All components exist |

## Key Findings

### 1. SchemaConnection Already Has Everything

```python
# From models/schema.py lines 14-26
class SchemaConnection(BaseModel):
    name: str       # "CNX_BASE_HOMOLOG"
    type_code: int  # 1 = SQL Server
    database_type: str  # "sqlserver"
    driver_name: str    # "SQL Server"
    source: str     # host
    port: str       # "1433"
    database: str   # "linkpay_db"
    user: str       # nullable
    extended_info: str  # connection string extras
```

**No parsing needed** - just extract and format.

### 2. Project Code Location Verified

From `Linkpay_ADM.wwp` analysis:
```yaml
code_elements :
  type_code : 0
  p_codes :
   -
     code : |1+
      CONSTANT NOME_PROJETO = "Linkpay_ADM"

      GLOBAL
        xUSUARIO_NOME,xUSUARIO_EMAIL... are strings
        gjsonParametros, gjsonSaldoCasa... are JSON
        gsUrlAPI is string
        gnTempoSessao is int = 20
```

The code block contains:
- CONSTANT declarations
- GLOBAL block with typed variables
- Initialization code after GLOBAL

### 3. GlobalStateExtractor is Complete

The existing `GlobalStateExtractor` handles:
- Single declarations: `gCnn is Connection`
- Multiple declarations: `a, b, c are string`
- Default values: `gnTimeout is int = 20`
- Initialization blocks after GLOBAL

### 4. gCnn Pattern is Universal

From grep search, `gCnn` is used across all files:
- `HExecuteSQLQuery(dsSel, gCnn, ...)`
- This confirms global connection variable pattern

This variable should be extracted and documented in CONTEXT.md.

## Not In Scope (Future Work)

1. **Storing Project Code as Element** - Would require schema migration and import changes
2. **Page-level initialization** - Request scope globals (type_code 38, 60)
3. **Automatic connection string generation** - Mapping WinDev connections to Python/Node connection strings
4. **Environment variable mapping** - Suggesting .env structure

## Sources

### HIGH Confidence (Verified in Codebase)
- `src/wxcode/models/schema.py` - SchemaConnection model
- `src/wxcode/parser/xdd_parser.py` - Connection parsing logic
- `src/wxcode/parser/global_state_extractor.py` - GLOBAL extraction
- `src/wxcode/models/global_state_context.py` - IR for globals
- `project-refs/Linkpay_ADM/Linkpay_ADM.wwp` - Project Code format verification

### MEDIUM Confidence (Pattern Inference)
- Project Code storage strategy based on existing Element patterns
- PromptBuilder extension based on existing template structure
