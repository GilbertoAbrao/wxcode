# Project Research Summary: v5 Initialization Context

**Project:** wxcode v5 - Full Initialization Context
**Domain:** WinDev to Modern Stack Converter - PromptBuilder Enhancement
**Researched:** 2026-01-24
**Confidence:** HIGH

## Executive Summary

This milestone extends PromptBuilder to include comprehensive initialization context for starter projects generated by Claude Code. The research reveals that all required data sources already exist in the wxcode codebase - this is purely an integration and formatting task. No new dependencies are needed.

The enhancement adds four critical context sections to CONTEXT.md: (1) Database Connections extracted from existing `DatabaseSchema.connections[]`, (2) Global State from Project Code and WDGs using the existing `GlobalStateExtractor`, (3) Initialization Code showing startup execution patterns, and (4) MCP Server Instructions for dynamic database queries. When completed, a converted PAGE_LOGIN will work immediately because the generated starter project will have proper database configuration, environment variables, and initialization patterns pre-configured.

The primary risk is credential leakage - database connection strings and passwords must be filtered before being passed to LLM prompts. Secondary risks include prompt injection via user-controlled data (table/connection names), and improper conversion of WinDev global state to singleton patterns instead of dependency injection. These risks have clear mitigation strategies and should be addressed in implementation phases.

## Key Findings

### Recommended Stack

**No new dependencies required.** The existing wxcode stack provides all necessary infrastructure:

**Core technologies already in place:**
- **MongoDB/Beanie** — `DatabaseSchema.connections[]` already stores connection details (host, port, database, driver) populated by `xdd_parser.py`
- **GlobalStateExtractor** — Fully implemented parser for `GLOBAL` declarations with type inference, default values, and multi-declaration support (exists at `parser/global_state_extractor.py`)
- **GlobalStateContext** — IR model for global variables with scope tracking (APP vs MODULE), initialization blocks, and dependency tracking (exists at `models/global_state_context.py`)
- **PromptBuilder** — Existing template-based CONTEXT.md generator with clean separation of concerns (exists at `services/prompt_builder.py`)
- **schema_extractor** — Established pattern for extracting data from MongoDB and formatting for prompts (exists at `services/schema_extractor.py`)

**Key finding:** All data is already in MongoDB. The work is purely integration - connecting existing extractors to PromptBuilder and adding formatting logic for new sections.

### Expected Features

**Must have (table stakes):**
- **Database Connection Config** — Every converted page uses `gCnn` connection variable; starter must have connection pre-configured with environment variables (.env template)
- **Environment-Specific Settings** — WinDev has COMPILE IF for Homolog/Producao; generated project needs environment selection mechanism (dev/staging/prod)
- **Settings/Config File Generation** — Modern apps expect .env, settings.py, config.yaml following stack conventions (FastAPI needs settings.py, Node needs config.ts)
- **Database URL Pattern** — `DATABASE_URL` standard for Python/Node ORMs; must be formatted correctly for target stack
- **Session Timeout Config** — `gnTempoSessao` controls session duration in original project; must be configurable in generated project

**Should have (competitive differentiators):**
- **API Endpoint Mapping** — Extract external API URLs from global state (Fitbank, APICartoes, etc.) into config so integrations are pre-configured
- **OAuth/Client Credentials** — Extract `ClientId`, `ClientSecret` patterns from COMPILE IF blocks for auth services
- **Lifespan Event Generation** — Generate Python `@asynccontextmanager` or Node startup hooks for database connection pooling
- **Multiple Connections Support** — Some projects have `gCnn`, `gCnn_Log`, etc.; all should be configured
- **Initialization Order** — Respect dependency order (connect before query) to avoid startup crashes

**Defer (v2+):**
- Feature flags extraction (`sAmbiente` style environment indicators)
- Automatic connection string generation (mapping WinDev connections to Python/Node patterns)
- Environment variable best practices suggestions
- Page-level initialization (request scope globals)

### Architecture Approach

The architecture maintains clean separation between data extraction (service layer), prompt formatting (PromptBuilder), and GSD invocation. The integration extends existing layers without introducing new components.

**Data flow:** WebSocket `/initialize` endpoint → parallel extraction (connections, schema, global state) → PromptBuilder.build_context() with extended parameters → CONTEXT.md with new sections → GSDInvoker.invoke_with_streaming() → Claude Code generates starter project.

**Major components:**
1. **schema_extractor.py (EXTEND)** — Add `extract_connections_for_configuration()` function that queries `DatabaseSchema.connections[]` and returns list of connection dicts
2. **init_context_extractor.py (NEW)** — Service layer function `extract_global_state_for_configuration()` that orchestrates GlobalStateExtractor across Project Code and WDG elements
3. **PromptBuilder (EXTEND)** — Add optional parameters `connections`, `global_state` to `build_context()` method; add formatting helpers `format_connections()`, `format_global_variables()`, `format_initialization_code()`
4. **PROMPT_TEMPLATE (EXTEND)** — Add four new sections after Database Schema: Database Connections, Global State (App-level + Module-level), Initialization Code, MCP Server Instructions

**Design decisions:**
- Keep connection extraction in `schema_extractor.py` since connections are part of DatabaseSchema model
- Create separate `init_context_extractor.py` for global state (different data source, more complex logic)
- Backward compatibility via optional parameters with defaults
- Stack-agnostic IR (GlobalStateContext uses WLanguage types, not Python/TypeScript types)

### Critical Pitfalls

1. **Credentials Leaked to LLM Prompts** — Database user/password from `SchemaConnection` passed to CONTEXT.md ends up in Claude API calls (potentially logged). **Prevention:** Create `SafeConnectionInfo` dataclass that omits `user`, `password`, `extended_info`; use placeholders like `{{ DB_USER }}` in generated config; add explicit warning in CONTEXT.md to configure .env with actual credentials; scan prompts for credential patterns before sending

2. **MCP Tool Instructions Enable Prompt Injection** — Connection names and table names are user-controllable data from WinDev project; attacker crafts table named `USUARIOS"; DROP TABLE USUARIOS; --` or `data\n\nIGNORE PREVIOUS INSTRUCTIONS`. **Prevention:** Sanitize ALL extracted names to `[A-Za-z0-9_]` only; use XML/JSON structured sections with clear data boundaries; mark user-derived content explicitly: `<user_data>...</user_data>`; never interpolate raw source content into instruction sections

3. **Global State Converted to Singletons** — `Scope.APP` variables mapped to Python module-level singletons creates untestable code, concurrency issues in async FastAPI, memory leaks, deployment nightmares (global state shared across workers). **Prevention:** Annotate variables with conversion strategy in CONTEXT.md; recommend dependency injection (FastAPI `Depends()`) for APP scope; use request context (`request.state`) for REQUEST scope; use proper connection pooling (SQLAlchemy's `create_async_engine`); flag `gCnn` patterns for special handling

4. **Initialization Order Lost in Translation** — WinDev executes GLOBAL declarations then initialization code in strict order; multiple GLOBAL blocks across WDGs have implicit order; extraction to flat structures loses ordering. **Prevention:** Parse `InitializationBlock` dependencies on variables; build initialization dependency graph; store topological order in `InitializationBlock`; generate code respecting order with explicit comments: `// Init order: 1`

5. **Context Window Overflow** — CONTEXT.md grows too large with all connections, global variables, initialization code, MCP documentation; Claude truncates important information, costs increase 10-50x. **Prevention:** Budget context (~4K tokens for instructions, ~4K for data); prioritize connections > globals > init code (summarized); use references like "See element.json for full code"; measure token count before sending

## Implications for Roadmap

Based on research, the work naturally divides into 4 sequential phases with a clear dependency chain. Phase 1 has no dependencies and can start immediately. Phase 4 depends on Phases 1-3 being complete. Phases 2-3 can run in parallel after Phase 1.

### Phase 1: Connection Extraction
**Rationale:** No dependencies - connection data already exists in MongoDB. Foundation for all subsequent work. Addresses critical security pitfall early.

**Delivers:**
- `extract_connections_for_configuration()` function in schema_extractor.py
- `SafeConnectionInfo` dataclass that filters credentials
- `format_connections()` helper in PromptBuilder
- Database Connections section in PROMPT_TEMPLATE

**Addresses:**
- **Table Stakes Feature:** Database Connection Config
- **Critical Pitfall #1:** Credentials leaked to LLM prompts

**Implementation notes:**
- Simple function following existing `extract_schema_for_configuration` pattern
- Return list of dicts with `name`, `database_type`, `driver_name`, `source`, `port`, `database`
- MUST NOT include `user`, `password`, or `extended_info` with credentials
- Connection names normalized to lowercase for case-insensitive matching

### Phase 2: Global State Extraction
**Rationale:** Depends on Phase 1 (connection patterns). Unlocks initialization code extraction. Enables environment-specific settings.

**Delivers:**
- New file: `services/init_context_extractor.py`
- `extract_global_state_for_configuration()` function
- `format_global_variables()` helper in PromptBuilder
- Global State sections (App-level + Module-level) in PROMPT_TEMPLATE

**Addresses:**
- **Table Stakes Feature:** Environment-Specific Settings
- **Should Have Feature:** Multiple Connections Support
- **Critical Pitfall #3:** Global state converted to singletons
- **Moderate Pitfall #4:** Initialization order lost

**Implementation notes:**
- Orchestrates existing GlobalStateExtractor across Project Code (windev_type: 0) and WDGs (windev_type: 31)
- Respects configuration_id exclusion scope
- Returns GlobalStateContext IR (stack-agnostic)
- Annotates variables with recommended conversion strategy (DI vs request scope)
- Tracks variable dependencies for init order

### Phase 3: Initialization Code Extraction
**Rationale:** Depends on Phase 2 (global state extraction). Completes the initialization context picture.

**Delivers:**
- `format_initialization_code()` helper in PromptBuilder
- Initialization Code section in PROMPT_TEMPLATE
- Dependency-ordered init blocks

**Addresses:**
- **Should Have Feature:** Initialization Order
- **Should Have Feature:** Lifespan Event Generation (documentation)
- **Moderate Pitfall #4:** Initialization order lost

**Implementation notes:**
- Uses `GlobalStateContext.initialization_blocks` from Phase 2
- Formats blocks with dependency comments
- Truncates large blocks (use references to full code)
- Generates lifespan pattern documentation (not code generation)

### Phase 4: MCP Tool Instructions
**Rationale:** Independent of Phases 1-3 but completes the CONTEXT.md enhancement. Addresses prompt injection risk.

**Delivers:**
- MCP Server Instructions section in PROMPT_TEMPLATE
- Input sanitization for user-derived data
- Structured data boundary markers

**Addresses:**
- **Critical Pitfall #2:** MCP tool instructions enable prompt injection
- **Table Stakes Feature:** Database URL Pattern (for MCP tools)

**Implementation notes:**
- Sanitize all connection/table names before template insertion: `[A-Za-z0-9_]` only
- Use XML/JSON structured sections: `<connections>...</connections>`
- Mark user-derived content explicitly
- Document MCP server environment variables

### Phase 5: Integration & Testing
**Rationale:** Depends on Phases 1-4 being complete. Orchestrates all extractors and validates end-to-end flow.

**Delivers:**
- Updated `PromptBuilder.build_context()` signature with optional parameters
- Updated WebSocket `/initialize` endpoint to call new extractors
- End-to-end test with Linkpay_ADM project
- Token budget validation

**Addresses:**
- **Critical Pitfall #5:** Context window overflow
- **Table Stakes Features:** Settings/Config File Generation, Database URL Pattern

**Implementation notes:**
- Add optional parameters: `connections: list[dict] = None`, `global_state: GlobalStateContext = None`
- Backward compatibility preserved (existing calls work)
- Measure token count and enforce budget (~8K total)
- Test with adversarial inputs (connection names with special chars, large global state)

### Phase Ordering Rationale

- **Sequential dependency:** Phase 5 depends on 1-4 → Must be last
- **Parallel opportunity:** Phases 2-3 can run in parallel after Phase 1 completes
- **Security first:** Phase 1 addresses credential leakage immediately
- **Complexity gradient:** Phase 1 (simple) → Phase 2-3 (medium) → Phase 4 (security-sensitive) → Phase 5 (integration)
- **Incremental value:** Each phase delivers testable functionality
- **Pitfall mitigation:** Critical pitfalls addressed in early phases (1, 2, 4)

### Research Flags

**Phases with standard patterns (skip research-phase):**
- **Phase 1:** Connection extraction is a simple database query and filter operation
- **Phase 3:** Initialization code formatting follows existing template patterns
- **Phase 5:** Integration follows established WebSocket endpoint pattern

**Phases needing validation during implementation:**
- **Phase 2:** GlobalStateExtractor is implemented but never used in production; may discover edge cases
- **Phase 4:** Prompt injection mitigations need security review; test with adversarial inputs

**No phases need deeper research** - all patterns are established, all components exist in codebase.

## Confidence Assessment

| Area | Confidence | Notes |
|------|------------|-------|
| Stack | HIGH | No new dependencies; all components verified in codebase |
| Features | HIGH | Based on existing codebase analysis and Linkpay_ADM reference project |
| Architecture | HIGH | Direct codebase analysis; follows established patterns |
| Pitfalls | HIGH | Security pitfalls sourced from Microsoft/OWASP/CWE; architectural pitfalls from industry best practices |

**Overall confidence:** HIGH

### Gaps to Address

**Minor gaps requiring validation during implementation:**

- **GlobalStateExtractor edge cases** — The extractor is fully implemented but has not been used in production. Implementation should test with:
  - Multiple GLOBAL blocks in same file
  - French keyword variants (HOuvreConnexion vs HOpenConnection)
  - Multi-line declarations
  - Complex types (array of structures, class references)

  **How to handle:** Add comprehensive unit tests before integration; test with Linkpay_ADM Project Code

- **Extended info parsing completeness** — The `_extract_port_from_extended_info` method in xdd_parser.py handles limited patterns. Extended info format varies by database driver.

  **How to handle:** Document unparsed remainder; log warnings for unrecognized patterns; accept manual configuration as fallback

- **Token budget empirical validation** — The 8K token budget (4K instructions + 4K data) is estimated. Actual usage depends on project size.

  **How to handle:** Measure token count with Linkpay_ADM in Phase 5; adjust budget if needed; implement truncation strategies

- **HOpenConnection parsing robustness** — WLanguage has flexible syntax (multi-line, named parameters, variable references, French keywords). Regex-based parsing may be fragile.

  **How to handle:** Start with simple patterns; log unparsed cases; iterate based on real projects; consider AST-based parsing for complex cases

**No blockers identified** - all gaps have clear mitigation strategies and fallback options.

## Sources

### Primary (HIGH confidence - Codebase Analysis)
- `/Users/gilberto/projetos/wxk/wxcode/src/wxcode/models/schema.py` — SchemaConnection model structure, connection fields
- `/Users/gilberto/projetos/wxk/wxcode/src/wxcode/parser/xdd_parser.py` — Connection parsing logic (lines 146-195)
- `/Users/gilberto/projetos/wxk/wxcode/src/wxcode/parser/global_state_extractor.py` — GLOBAL declaration parser, fully implemented
- `/Users/gilberto/projetos/wxk/wxcode/src/wxcode/models/global_state_context.py` — IR for global variables
- `/Users/gilberto/projetos/wxk/wxcode/src/wxcode/services/prompt_builder.py` — Current PROMPT_TEMPLATE and build_context()
- `/Users/gilberto/projetos/wxk/wxcode/src/wxcode/services/schema_extractor.py` — Established extraction pattern
- `/Users/gilberto/projetos/wxk/wxcode/src/wxcode/api/output_projects.py` — WebSocket /initialize endpoint (line 267)
- `/Users/gilberto/projetos/wxk/wxcode/src/wxcode/generator/orchestrator.py` — Reference implementation of global state extraction (lines 238-287)
- `/Users/gilberto/projetos/wxk/wxcode/project-refs/Linkpay_ADM/Linkpay_ADM.wwp` — Project Code format verification (lines 2450-2700)

### Secondary (HIGH confidence - Security Best Practices)
- [Protecting Connection Information - Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/framework/data/adonet/protecting-connection-information) — Credential protection patterns
- [CWE-798: Hard-coded Credentials](https://cwe.mitre.org/data/definitions/798.html) — Security vulnerability classification
- [Environment Variables Don't Keep Secrets - CyberArk](https://developer.cyberark.com/blog/environment-variables-dont-keep-secrets-best-practices-for-plugging-application-credential-leaks/) — Environment variable security
- [MCP Prompt Injection - Microsoft](https://developer.microsoft.com/blog/protecting-against-indirect-injection-attacks-mcp) — MCP security guidance
- [OWASP MCP Top 10](https://microsoft.github.io/mcp-azure-security-guide/mcp/mcp06-prompt-injection/) — Prompt injection mitigations
- [Prompt Injection via MCP - Snyk Labs](https://labs.snyk.io/resources/prompt-injection-mcp/) — Attack vectors

### Secondary (HIGH confidence - Architecture Best Practices)
- [Singleton Anti-Pattern - GeeksforGeeks](https://www.geeksforgeeks.org/system-design/why-is-singleton-design-pattern-is-considered-an-anti-pattern/) — Why avoid global state
- [Drawbacks of Singleton - Baeldung](https://www.baeldung.com/java-patterns-singleton-cons) — Concurrency issues
- [Context Management Techniques - Agenta](https://agenta.ai/blog/top-6-techniques-to-manage-context-length-in-llms) — LLM context budgeting
- [Lost-in-the-Middle Effect - Winder.ai](https://winder.ai/llm-prompt-best-practices-large-context-windows/) — Context window optimization

### Tertiary (MEDIUM confidence - WinDev Documentation)
- [WLanguage Documentation - PC SOFT](https://doc.windev.com/en-US/) — Language reference
- [HOpenConnection - PC SOFT](https://help.windev.com/?3044107=&product=WM) — Connection function documentation
- [Global and Local Variables - PC SOFT](https://doc.windev.com/en-US/?1514054=&product=WM) — Variable scope

---
*Research completed: 2026-01-24*
*Ready for roadmap: yes*
